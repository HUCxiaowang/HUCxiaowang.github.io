feloader.add("@cloud/pep-home-page/pc/index", ["@cloud/xtemplate-runtime", "@cloud/element-entrance", "@cloud/link-to",
	"@cloud/lazyload", "@cloud/parallax-scroll"
], (function(e, t, n) {
	n.exports = function(e) {
		var t = {};

		function n(r) {
			if (t[r]) return t[r].exports;
			var i = t[r] = {
				i: r,
				l: !1,
				exports: {}
			};
			return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
		}
		return n.m = e, n.c = t, n.d = function(e, t, r) {
			n.o(e, t) || Object.defineProperty(e, t, {
				enumerable: !0,
				get: r
			})
		}, n.r = function(e) {
			"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol
				.toStringTag, {
					value: "Module"
				}), Object.defineProperty(e, "__esModule", {
				value: !0
			})
		}, n.t = function(e, t) {
			if (1 & t && (e = n(e)), 8 & t) return e;
			if (4 & t && "object" == typeof e && e && e.__esModule) return e;
			var r = Object.create(null);
			if (n.r(r), Object.defineProperty(r, "default", {
					enumerable: !0,
					value: e
				}), 2 & t && "string" != typeof e)
				for (var i in e) n.d(r, i, function(t) {
					return e[t]
				}.bind(null, i));
			return r
		}, n.n = function(e) {
			var t = e && e.__esModule ? function() {
				return e.default
			} : function() {
				return e
			};
			return n.d(t, "a", t), t
		}, n.o = function(e, t) {
			return Object.prototype.hasOwnProperty.call(e, t)
		}, n.p = "/build/", n(n.s = 16)
	}([function(e, t) {
		e.exports = function(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		function n(e, t) {
			for (var n = 0; n < t.length; n++) {
				var r = t[n];
				r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r
					.writable = !0), Object.defineProperty(e, r.key, r)
			}
		}
		e.exports = function(e, t, r) {
			return t && n(e.prototype, t), r && n(e, r), e
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e, t, n) {
			return t in e ? Object.defineProperty(e, t, {
				value: n,
				enumerable: !0,
				configurable: !0,
				writable: !0
			}) : e[t] = n, e
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		"use strict";
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = function(e) {
			var t = "mediaQuery" + (new Date).getTime(),
				n = '<span class="' + t + '"><style>.' + t +
				"{font-size: 0 !important;}@media(min-width: " + e + "px){." + t +
				"{font-size: 20px !important;}}</style></span>",
				r = $("body").append(n).find("." + t),
				i = "20px" === r.css("font-size");
			return r.remove(), i
		}
	}, function(t, n) {
		t.exports = e("@cloud/parallax-scroll")
	}, function(e, t) {
		function n(t) {
			return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? (e
				.exports = n = function(e) {
					return typeof e
				}, e.exports.default = e.exports, e.exports.__esModule = !0) : (e.exports =
				n = function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol &&
						e !== Symbol.prototype ? "symbol" : typeof e
				}, e.exports.default = e.exports, e.exports.__esModule = !0), n(t)
		}
		e.exports = n, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		function n(t) {
			return e.exports = n = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
				return e.__proto__ || Object.getPrototypeOf(e)
			}, e.exports.default = e.exports, e.exports.__esModule = !0, n(t)
		}
		e.exports = n, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e) {
			if (void 0 === e) throw new ReferenceError(
				"this hasn't been initialised - super() hasn't been called");
			return e
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(t, n) {
		t.exports = e("@cloud/lazyload")
	}, function(e, t, n) {}, function(e, t, n) {
		e.exports = n(51)
	}, function(e, t) {
		function n(e, t, n, r, i, a, o) {
			try {
				var s = e[a](o),
					l = s.value
			} catch (e) {
				return void n(e)
			}
			s.done ? t(l) : Promise.resolve(l).then(r, i)
		}
		e.exports = function(e) {
			return function() {
				var t = this,
					r = arguments;
				return new Promise((function(i, a) {
					var o = e.apply(t, r);

					function s(e) {
						n(o, i, a, s, l, "next", e)
					}

					function l(e) {
						n(o, i, a, s, l, "throw", e)
					}
					s(void 0)
				}))
			}
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		"use strict";
		var r, i, a, o, s = n(0),
			l = s(n(11)),
			u = s(n(12)),
			c = s(n(52)),
			h = s(n(58)),
			d = s(n(3)),
			f = s(n(8)),
			p = s(n(14)),
			v = s(n(15)),
			m = s(n(7)),
			g = s(n(1)),
			y = s(n(2)),
			x = s(n(6));

		function _(e, t) {
			var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
			if (!n) {
				if (Array.isArray(e) || (n = function(e, t) {
						if (!e) return;
						if ("string" == typeof e) return b(e, t);
						var n = Object.prototype.toString.call(e).slice(8, -1);
						"Object" === n && e.constructor && (n = e.constructor.name);
						if ("Map" === n || "Set" === n) return Array.from(e);
						if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/
							.test(n)) return b(e, t)
					}(e)) || t && e && "number" == typeof e.length) {
					n && (e = n);
					var r = 0,
						i = function() {};
					return {
						s: i,
						n: function() {
							return r >= e.length ? {
								done: !0
							} : {
								done: !1,
								value: e[r++]
							}
						},
						e: function(e) {
							throw e
						},
						f: i
					}
				}
				throw new TypeError(
					"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
					)
			}
			var a, o = !0,
				s = !1;
			return {
				s: function() {
					n = n.call(e)
				},
				n: function() {
					var e = n.next();
					return o = e.done, e
				},
				e: function(e) {
					s = !0, a = e
				},
				f: function() {
					try {
						o || null == n.return || n.return()
					} finally {
						if (s) throw a
					}
				}
			}
		}

		function b(e, t) {
			(null == t || t > e.length) && (t = e.length);
			for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
			return r
		}

		function w(e, t) {
			var n = Object.keys(e);
			if (Object.getOwnPropertySymbols) {
				var r = Object.getOwnPropertySymbols(e);
				t && (r = r.filter((function(t) {
					return Object.getOwnPropertyDescriptor(e, t).enumerable
				}))), n.push.apply(n, r)
			}
			return n
		}

		function M(e) {
			var t = function() {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (
						function() {}))), !0
				} catch (e) {
					return !1
				}
			}
			/**
			 * @license
			 * Copyright 2010-2021 Three.js Authors
			 * SPDX-License-Identifier: MIT
			 */
			();
			return function() {
				var n, r = (0, m.default)(e);
				if (t) {
					var i = (0, m.default)(this).constructor;
					n = Reflect.construct(r, arguments, i)
				} else n = r.apply(this, arguments);
				return (0, v.default)(this, n)
			}
		}
		o = function(e) {
			for (var t, n = "129", r = 100, i = 300, a = 301, o = 302, s = 303, x = 304, b =
					306, S = 307, T = 1e3, E = 1001, A = 1002, L = 1003, k = 1004, R = 1005,
					C = 1006, P = 1007, I = 1008, D = 1009, N = 1012, O = 1014, B = 1015,
					z = 1016, F = 1020, H = 1022, U = 1023, G = 1026, V = 1027, W = 33776,
					j = 33777, q = 33778, X = 33779, Y = 35840, $ = 35841, Z = 35842, J =
					35843, Q = 37492, K = 37496, ee = 2300, te = 2301, ne = 2302, re = 2400,
					ie = 2401, ae = 2402, oe = 2500, se = 2501, le = 3e3, ue = 3001, ce =
					3007, he = 3002, de = 3004, fe = 3005, pe = 3006, ve = 7680, me = 35044,
					ge = 35048, ye = "300 es", xe = function() {
						function e() {
							(0, g.default)(this, e)
						}
						return (0, y.default)(e, [{
							key: "addEventListener",
							value: function(e, t) {
								void 0 === this._listeners && (this
									._listeners = {});
								var n = this._listeners;
								void 0 === n[e] && (n[e] = []), -1 === n[e]
									.indexOf(t) && n[e].push(t)
							}
						}, {
							key: "hasEventListener",
							value: function(e, t) {
								if (void 0 === this._listeners) return !1;
								var n = this._listeners;
								return void 0 !== n[e] && -1 !== n[e]
									.indexOf(t)
							}
						}, {
							key: "removeEventListener",
							value: function(e, t) {
								if (void 0 !== this._listeners) {
									var n = this._listeners[e];
									if (void 0 !== n) {
										var r = n.indexOf(t); - 1 !== r && n
											.splice(r, 1)
									}
								}
							}
						}, {
							key: "dispatchEvent",
							value: function(e) {
								if (void 0 !== this._listeners) {
									var t = this._listeners[e.type];
									if (void 0 !== t) {
										e.target = this;
										for (var n = t.slice(0), r = 0, i =
												n.length; r < i; r++) n[r]
											.call(this, e);
										e.target = null
									}
								}
							}
						}]), e
					}(), _e = [], be = 0; be < 256; be++) _e[be] = (be < 16 ? "0" : "") + be
				.toString(16);
			var we = 1234567,
				Me = Math.PI / 180,
				Se = 180 / Math.PI;

			function Te() {
				var e = 4294967295 * Math.random() | 0,
					t = 4294967295 * Math.random() | 0,
					n = 4294967295 * Math.random() | 0,
					r = 4294967295 * Math.random() | 0;
				return (_e[255 & e] + _e[e >> 8 & 255] + _e[e >> 16 & 255] + _e[e >> 24 &
					255] + "-" + _e[255 & t] + _e[t >> 8 & 255] + "-" + _e[t >> 16 &
					15 | 64] + _e[t >> 24 & 255] + "-" + _e[63 & n | 128] + _e[n >>
					8 & 255] + "-" + _e[n >> 16 & 255] + _e[n >> 24 & 255] + _e[
					255 & r] + _e[r >> 8 & 255] + _e[r >> 16 & 255] + _e[r >> 24 &
					255]).toUpperCase()
			}

			function Ee(e, t, n) {
				return Math.max(t, Math.min(n, e))
			}

			function Ae(e, t) {
				return (e % t + t) % t
			}

			function Le(e, t, n) {
				return (1 - n) * e + n * t
			}

			function ke(e) {
				return 0 == (e & e - 1) && 0 !== e
			}

			function Re(e) {
				return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
			}

			function Ce(e) {
				return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
			}
			var Pe = Object.freeze({
					__proto__: null,
					DEG2RAD: Me,
					RAD2DEG: Se,
					generateUUID: Te,
					clamp: Ee,
					euclideanModulo: Ae,
					mapLinear: function(e, t, n, r, i) {
						return r + (e - t) * (i - r) / (n - t)
					},
					inverseLerp: function(e, t, n) {
						return e !== t ? (n - e) / (t - e) : 0
					},
					lerp: Le,
					damp: function(e, t, n, r) {
						return Le(e, t, 1 - Math.exp(-n * r))
					},
					pingpong: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 1;
						return t - Math.abs(Ae(e, 2 * t) - t)
					},
					smoothstep: function(e, t, n) {
						return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) *
							e * (3 - 2 * e)
					},
					smootherstep: function(e, t, n) {
						return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) *
							e * e * (e * (6 * e - 15) + 10)
					},
					randInt: function(e, t) {
						return e + Math.floor(Math.random() * (t - e + 1))
					},
					randFloat: function(e, t) {
						return e + Math.random() * (t - e)
					},
					randFloatSpread: function(e) {
						return e * (.5 - Math.random())
					},
					seededRandom: function(e) {
						return void 0 !== e && (we = e % 2147483647), ((we = 16807 *
							we % 2147483647) - 1) / 2147483646
					},
					degToRad: function(e) {
						return e * Me
					},
					radToDeg: function(e) {
						return e * Se
					},
					isPowerOfTwo: ke,
					ceilPowerOfTwo: Re,
					floorPowerOfTwo: Ce,
					setQuaternionFromProperEuler: function(e, t, n, r, i) {
						var a = Math.cos,
							o = Math.sin,
							s = a(n / 2),
							l = o(n / 2),
							u = a((t + r) / 2),
							c = o((t + r) / 2),
							h = a((t - r) / 2),
							d = o((t - r) / 2),
							f = a((r - t) / 2),
							p = o((r - t) / 2);
						switch (i) {
							case "XYX":
								e.set(s * c, l * h, l * d, s * u);
								break;
							case "YZY":
								e.set(l * d, s * c, l * h, s * u);
								break;
							case "ZXZ":
								e.set(l * h, l * d, s * c, s * u);
								break;
							case "XZX":
								e.set(s * c, l * p, l * f, s * u);
								break;
							case "YXY":
								e.set(l * f, s * c, l * p, s * u);
								break;
							case "ZYZ":
								e.set(l * p, l * f, s * c, s * u);
								break;
							default:
								console.warn(
									"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
									i)
						}
					}
				}),
				Ie = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : 0,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						(0, g.default)(this, e), this.x = t, this.y = n
					}
					return (0, y.default)(e, [{
						key: "width",
						get: function() {
							return this.x
						},
						set: function(e) {
							this.x = e
						}
					}, {
						key: "height",
						get: function() {
							return this.y
						},
						set: function(e) {
							this.y = e
						}
					}, {
						key: "set",
						value: function(e, t) {
							return this.x = e, this.y = t, this
						}
					}, {
						key: "setScalar",
						value: function(e) {
							return this.x = e, this.y = e, this
						}
					}, {
						key: "setX",
						value: function(e) {
							return this.x = e, this
						}
					}, {
						key: "setY",
						value: function(e) {
							return this.y = e, this
						}
					}, {
						key: "setComponent",
						value: function(e, t) {
							switch (e) {
								case 0:
									this.x = t;
									break;
								case 1:
									this.y = t;
									break;
								default:
									throw new Error(
										"index is out of range: " + e)
							}
							return this
						}
					}, {
						key: "getComponent",
						value: function(e) {
							switch (e) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								default:
									throw new Error(
										"index is out of range: " + e)
							}
						}
					}, {
						key: "clone",
						value: function() {
							return new this.constructor(this.x, this.y)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.x = e.x, this.y = e.y, this
						}
					}, {
						key: "add",
						value: function(e, t) {
							return void 0 !== t ? (console.warn(
								"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
								), this.addVectors(e, t)) : (this.x += e
								.x, this.y += e.y, this)
						}
					}, {
						key: "addScalar",
						value: function(e) {
							return this.x += e, this.y += e, this
						}
					}, {
						key: "addVectors",
						value: function(e, t) {
							return this.x = e.x + t.x, this.y = e.y + t.y,
								this
						}
					}, {
						key: "addScaledVector",
						value: function(e, t) {
							return this.x += e.x * t, this.y += e.y * t,
								this
						}
					}, {
						key: "sub",
						value: function(e, t) {
							return void 0 !== t ? (console.warn(
								"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
								), this.subVectors(e, t)) : (this.x -= e
								.x, this.y -= e.y, this)
						}
					}, {
						key: "subScalar",
						value: function(e) {
							return this.x -= e, this.y -= e, this
						}
					}, {
						key: "subVectors",
						value: function(e, t) {
							return this.x = e.x - t.x, this.y = e.y - t.y,
								this
						}
					}, {
						key: "multiply",
						value: function(e) {
							return this.x *= e.x, this.y *= e.y, this
						}
					}, {
						key: "multiplyScalar",
						value: function(e) {
							return this.x *= e, this.y *= e, this
						}
					}, {
						key: "divide",
						value: function(e) {
							return this.x /= e.x, this.y /= e.y, this
						}
					}, {
						key: "divideScalar",
						value: function(e) {
							return this.multiplyScalar(1 / e)
						}
					}, {
						key: "applyMatrix3",
						value: function(e) {
							var t = this.x,
								n = this.y,
								r = e.elements;
							return this.x = r[0] * t + r[3] * n + r[6], this
								.y = r[1] * t + r[4] * n + r[7], this
						}
					}, {
						key: "min",
						value: function(e) {
							return this.x = Math.min(this.x, e.x), this.y =
								Math.min(this.y, e.y), this
						}
					}, {
						key: "max",
						value: function(e) {
							return this.x = Math.max(this.x, e.x), this.y =
								Math.max(this.y, e.y), this
						}
					}, {
						key: "clamp",
						value: function(e, t) {
							return this.x = Math.max(e.x, Math.min(t.x, this
								.x)), this.y = Math.max(e.y, Math.min(t
								.y, this.y)), this
						}
					}, {
						key: "clampScalar",
						value: function(e, t) {
							return this.x = Math.max(e, Math.min(t, this
								.x)), this.y = Math.max(e, Math.min(t, this
									.y)), this
						}
					}, {
						key: "clampLength",
						value: function(e, t) {
							var n = this.length();
							return this.divideScalar(n || 1).multiplyScalar(
								Math.max(e, Math.min(t, n)))
						}
					}, {
						key: "floor",
						value: function() {
							return this.x = Math.floor(this.x), this.y =
								Math.floor(this.y), this
						}
					}, {
						key: "ceil",
						value: function() {
							return this.x = Math.ceil(this.x), this.y = Math
								.ceil(this.y), this
						}
					}, {
						key: "round",
						value: function() {
							return this.x = Math.round(this.x), this.y =
								Math.round(this.y), this
						}
					}, {
						key: "roundToZero",
						value: function() {
							return this.x = this.x < 0 ? Math.ceil(this.x) :
								Math.floor(this.x), this.y = this.y < 0 ?
								Math.ceil(this.y) : Math.floor(this.y), this
						}
					}, {
						key: "negate",
						value: function() {
							return this.x = -this.x, this.y = -this.y, this
						}
					}, {
						key: "dot",
						value: function(e) {
							return this.x * e.x + this.y * e.y
						}
					}, {
						key: "cross",
						value: function(e) {
							return this.x * e.y - this.y * e.x
						}
					}, {
						key: "lengthSq",
						value: function() {
							return this.x * this.x + this.y * this.y
						}
					}, {
						key: "length",
						value: function() {
							return Math.sqrt(this.x * this.x + this.y * this
								.y)
						}
					}, {
						key: "manhattanLength",
						value: function() {
							return Math.abs(this.x) + Math.abs(this.y)
						}
					}, {
						key: "normalize",
						value: function() {
							return this.divideScalar(this.length() || 1)
						}
					}, {
						key: "angle",
						value: function() {
							return Math.atan2(-this.y, -this.x) + Math.PI
						}
					}, {
						key: "distanceTo",
						value: function(e) {
							return Math.sqrt(this.distanceToSquared(e))
						}
					}, {
						key: "distanceToSquared",
						value: function(e) {
							var t = this.x - e.x,
								n = this.y - e.y;
							return t * t + n * n
						}
					}, {
						key: "manhattanDistanceTo",
						value: function(e) {
							return Math.abs(this.x - e.x) + Math.abs(this
								.y - e.y)
						}
					}, {
						key: "setLength",
						value: function(e) {
							return this.normalize().multiplyScalar(e)
						}
					}, {
						key: "lerp",
						value: function(e, t) {
							return this.x += (e.x - this.x) * t, this.y += (
								e.y - this.y) * t, this
						}
					}, {
						key: "lerpVectors",
						value: function(e, t, n) {
							return this.x = e.x + (t.x - e.x) * n, this.y =
								e.y + (t.y - e.y) * n, this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.x === this.x && e.y === this.y
						}
					}, {
						key: "fromArray",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0;
							return this.x = e[t], this.y = e[t + 1], this
						}
					}, {
						key: "toArray",
						value: function() {
							var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : [],
								t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0;
							return e[t] = this.x, e[t + 1] = this.y, e
						}
					}, {
						key: "fromBufferAttribute",
						value: function(e, t, n) {
							return void 0 !== n && console.warn(
								"THREE.Vector2: offset has been removed from .fromBufferAttribute()."
								), this.x = e.getX(t), this.y = e.getY(
								t), this
						}
					}, {
						key: "rotateAround",
						value: function(e, t) {
							var n = Math.cos(t),
								r = Math.sin(t),
								i = this.x - e.x,
								a = this.y - e.y;
							return this.x = i * n - a * r + e.x, this.y =
								i * r + a * n + e.y, this
						}
					}, {
						key: "random",
						value: function() {
							return this.x = Math.random(), this.y = Math
								.random(), this
						}
					}]), e
				}();
			Ie.prototype.isVector2 = !0;
			var De, Ne = function() {
				function e() {
					(0, g.default)(this, e), this.elements = [1, 0, 0, 0, 1, 0, 0, 0,
						1], arguments.length > 0 && console.error(
							"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
							)
				}
				return (0, y.default)(e, [{
					key: "set",
					value: function(e, t, n, r, i, a, o, s, l) {
						var u = this.elements;
						return u[0] = e, u[1] = r, u[2] = o, u[3] = t,
							u[4] = i, u[5] = s, u[6] = n, u[7] = a, u[
							8] = l, this
					}
				}, {
					key: "identity",
					value: function() {
						return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
					}
				}, {
					key: "copy",
					value: function(e) {
						var t = this.elements,
							n = e.elements;
						return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[
								3] = n[3], t[4] = n[4], t[5] = n[5], t[
								6] = n[6], t[7] = n[7], t[8] = n[8],
							this
					}
				}, {
					key: "extractBasis",
					value: function(e, t, n) {
						return e.setFromMatrix3Column(this, 0), t
							.setFromMatrix3Column(this, 1), n
							.setFromMatrix3Column(this, 2), this
					}
				}, {
					key: "setFromMatrix4",
					value: function(e) {
						var t = e.elements;
						return this.set(t[0], t[4], t[8], t[1], t[5], t[
							9], t[2], t[6], t[10]), this
					}
				}, {
					key: "multiply",
					value: function(e) {
						return this.multiplyMatrices(this, e)
					}
				}, {
					key: "premultiply",
					value: function(e) {
						return this.multiplyMatrices(e, this)
					}
				}, {
					key: "multiplyMatrices",
					value: function(e, t) {
						var n = e.elements,
							r = t.elements,
							i = this.elements,
							a = n[0],
							o = n[3],
							s = n[6],
							l = n[1],
							u = n[4],
							c = n[7],
							h = n[2],
							d = n[5],
							f = n[8],
							p = r[0],
							v = r[3],
							m = r[6],
							g = r[1],
							y = r[4],
							x = r[7],
							_ = r[2],
							b = r[5],
							w = r[8];
						return i[0] = a * p + o * g + s * _, i[3] = a *
							v + o * y + s * b, i[6] = a * m + o * x +
							s * w, i[1] = l * p + u * g + c * _, i[4] =
							l * v + u * y + c * b, i[7] = l * m + u *
							x + c * w, i[2] = h * p + d * g + f * _, i[
								5] = h * v + d * y + f * b, i[8] = h *
							m + d * x + f * w, this
					}
				}, {
					key: "multiplyScalar",
					value: function(e) {
						var t = this.elements;
						return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *=
							e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *=
							e, t[8] *= e, this
					}
				}, {
					key: "determinant",
					value: function() {
						var e = this.elements,
							t = e[0],
							n = e[1],
							r = e[2],
							i = e[3],
							a = e[4],
							o = e[5],
							s = e[6],
							l = e[7],
							u = e[8];
						return t * a * u - t * o * l - n * i * u + n *
							o * s + r * i * l - r * a * s
					}
				}, {
					key: "invert",
					value: function() {
						var e = this.elements,
							t = e[0],
							n = e[1],
							r = e[2],
							i = e[3],
							a = e[4],
							o = e[5],
							s = e[6],
							l = e[7],
							u = e[8],
							c = u * a - o * l,
							h = o * s - u * i,
							d = l * i - a * s,
							f = t * c + n * h + r * d;
						if (0 === f) return this.set(0, 0, 0, 0, 0, 0,
							0, 0, 0);
						var p = 1 / f;
						return e[0] = c * p, e[1] = (r * l - u * n) * p,
							e[2] = (o * n - r * a) * p, e[3] = h * p, e[
								4] = (u * t - r * s) * p, e[5] = (r *
								i - o * t) * p, e[6] = d * p, e[7] = (
								n * s - l * t) * p, e[8] = (a * t - n *
								i) * p, this
					}
				}, {
					key: "transpose",
					value: function() {
						var e, t = this.elements;
						return e = t[1], t[1] = t[3], t[3] = e, e = t[
							2], t[2] = t[6], t[6] = e, e = t[5], t[5] =
							t[7], t[7] = e, this
					}
				}, {
					key: "getNormalMatrix",
					value: function(e) {
						return this.setFromMatrix4(e).invert()
							.transpose()
					}
				}, {
					key: "transposeIntoArray",
					value: function(e) {
						var t = this.elements;
						return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[
								3] = t[1], e[4] = t[4], e[5] = t[7], e[
								6] = t[2], e[7] = t[5], e[8] = t[8],
							this
					}
				}, {
					key: "setUvTransform",
					value: function(e, t, n, r, i, a, o) {
						var s = Math.cos(i),
							l = Math.sin(i);
						return this.set(n * s, n * l, -n * (s * a + l *
							o) + a + e, -r * l, r * s, -r * (-
							l * a + s * o) + o + t, 0, 0, 1), this
					}
				}, {
					key: "scale",
					value: function(e, t) {
						var n = this.elements;
						return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *=
							t, n[4] *= t, n[7] *= t, this
					}
				}, {
					key: "rotate",
					value: function(e) {
						var t = Math.cos(e),
							n = Math.sin(e),
							r = this.elements,
							i = r[0],
							a = r[3],
							o = r[6],
							s = r[1],
							l = r[4],
							u = r[7];
						return r[0] = t * i + n * s, r[3] = t * a + n *
							l, r[6] = t * o + n * u, r[1] = -n * i + t *
							s, r[4] = -n * a + t * l, r[7] = -n * o +
							t * u, this
					}
				}, {
					key: "translate",
					value: function(e, t) {
						var n = this.elements;
						return n[0] += e * n[2], n[3] += e * n[5], n[
							6] += e * n[8], n[1] += t * n[2], n[4] +=
							t * n[5], n[7] += t * n[8], this
					}
				}, {
					key: "equals",
					value: function(e) {
						for (var t = this.elements, n = e.elements, r =
								0; r < 9; r++)
							if (t[r] !== n[r]) return !1;
						return !0
					}
				}, {
					key: "fromArray",
					value: function(e) {
						for (var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0, n =
								0; n < 9; n++) this.elements[n] = e[n +
							t];
						return this
					}
				}, {
					key: "toArray",
					value: function() {
						var e = arguments.length > 0 && void 0 !==
							arguments[0] ? arguments[0] : [],
							t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0,
							n = this.elements;
						return e[t] = n[0], e[t + 1] = n[1], e[t + 2] =
							n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[
								t + 5] = n[5], e[t + 6] = n[6], e[t +
							7] = n[7], e[t + 8] = n[8], e
					}
				}, {
					key: "clone",
					value: function() {
						return (new this.constructor).fromArray(this
							.elements)
					}
				}]), e
			}();
			Ne.prototype.isMatrix3 = !0;
			var Oe = function() {
					function e() {
						(0, g.default)(this, e)
					}
					return (0, y.default)(e, null, [{
						key: "getDataURL",
						value: function(e) {
							if (/^data:/i.test(e.src)) return e.src;
							if ("undefined" == typeof HTMLCanvasElement)
								return e.src;
							var t;
							if (e instanceof HTMLCanvasElement) t = e;
							else {
								void 0 === De && (De = document
										.createElementNS(
											"http://www.w3.org/1999/xhtml",
											"canvas")), De.width = e.width,
									De.height = e.height;
								var n = De.getContext("2d");
								e instanceof ImageData ? n.putImageData(e,
									0, 0) : n.drawImage(e, 0, 0, e
									.width, e.height), t = De
							}
							return t.width > 2048 || t.height > 2048 ? (
									console.warn(
										"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
										e), t.toDataURL("image/jpeg", .6)) :
								t.toDataURL("image/png")
						}
					}]), e
				}(),
				Be = 0,
				ze = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : n.DEFAULT_IMAGE,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : n.DEFAULT_MAPPING,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1001,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1001,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 1006,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 1008,
							u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[
								6] : 1023,
							c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[
								7] : 1009,
							h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[
								8] : 1,
							d = arguments.length > 9 && void 0 !== arguments[9] ? arguments[
								9] : 3e3;
						return (0, g.default)(this, n), e = t.call(this), Object
							.defineProperty((0, f.default)(e), "id", {
								value: Be++
							}), e.uuid = Te(), e.name = "", e.image = r, e.mipmaps = [], e
							.mapping = i, e.wrapS = a, e.wrapT = o, e.magFilter = s, e
							.minFilter = l, e.anisotropy = h, e.format = u, e
							.internalFormat = null, e.type = c, e.offset = new Ie(0, 0), e
							.repeat = new Ie(1, 1), e.center = new Ie(0, 0), e.rotation = 0,
							e.matrixAutoUpdate = !0, e.matrix = new Ne, e
							.generateMipmaps = !0, e.premultiplyAlpha = !1, e.flipY = !0, e
							.unpackAlignment = 4, e.encoding = d, e.version = 0, e
							.onUpdate = null, e
					}
					return (0, y.default)(n, [{
						key: "updateMatrix",
						value: function() {
							this.matrix.setUvTransform(this.offset.x, this
								.offset.y, this.repeat.x, this.repeat.y,
								this.rotation, this.center.x, this
								.center.y)
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.name = e.name, this.image = e.image,
								this.mipmaps = e.mipmaps.slice(0), this
								.mapping = e.mapping, this.wrapS = e.wrapS,
								this.wrapT = e.wrapT, this.magFilter = e
								.magFilter, this.minFilter = e.minFilter,
								this.anisotropy = e.anisotropy, this
								.format = e.format, this.internalFormat = e
								.internalFormat, this.type = e.type, this
								.offset.copy(e.offset), this.repeat.copy(e
									.repeat), this.center.copy(e.center),
								this.rotation = e.rotation, this
								.matrixAutoUpdate = e.matrixAutoUpdate, this
								.matrix.copy(e.matrix), this
								.generateMipmaps = e.generateMipmaps, this
								.premultiplyAlpha = e.premultiplyAlpha, this
								.flipY = e.flipY, this.unpackAlignment = e
								.unpackAlignment, this.encoding = e
								.encoding, this
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = void 0 === e || "string" == typeof e;
							if (!t && void 0 !== e.textures[this.uuid])
								return e.textures[this.uuid];
							var n = {
								metadata: {
									version: 4.5,
									type: "Texture",
									generator: "Texture.toJSON"
								},
								uuid: this.uuid,
								name: this.name,
								mapping: this.mapping,
								repeat: [this.repeat.x, this.repeat.y],
								offset: [this.offset.x, this.offset.y],
								center: [this.center.x, this.center.y],
								rotation: this.rotation,
								wrap: [this.wrapS, this.wrapT],
								format: this.format,
								type: this.type,
								encoding: this.encoding,
								minFilter: this.minFilter,
								magFilter: this.magFilter,
								anisotropy: this.anisotropy,
								flipY: this.flipY,
								premultiplyAlpha: this.premultiplyAlpha,
								unpackAlignment: this.unpackAlignment
							};
							if (void 0 !== this.image) {
								var r = this.image;
								if (void 0 === r.uuid && (r.uuid = Te()), !
									t && void 0 === e.images[r.uuid]) {
									var i;
									if (Array.isArray(r)) {
										i = [];
										for (var a = 0, o = r.length; a <
											o; a++) r[a].isDataTexture ? i
											.push(Fe(r[a].image)) : i.push(
												Fe(r[a]))
									} else i = Fe(r);
									e.images[r.uuid] = {
										uuid: r.uuid,
										url: i
									}
								}
								n.image = r.uuid
							}
							return t || (e.textures[this.uuid] = n), n
						}
					}, {
						key: "dispose",
						value: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}, {
						key: "transformUv",
						value: function(e) {
							if (this.mapping !== i) return e;
							if (e.applyMatrix3(this.matrix), e.x < 0 || e
								.x > 1) switch (this.wrapS) {
								case T:
									e.x = e.x - Math.floor(e.x);
									break;
								case E:
									e.x = e.x < 0 ? 0 : 1;
									break;
								case A:
									1 === Math.abs(Math.floor(e.x) %
										2) ? e.x = Math.ceil(e.x) - e
										.x : e.x = e.x - Math.floor(e.x)
							}
							if (e.y < 0 || e.y > 1) switch (this.wrapT) {
								case T:
									e.y = e.y - Math.floor(e.y);
									break;
								case E:
									e.y = e.y < 0 ? 0 : 1;
									break;
								case A:
									1 === Math.abs(Math.floor(e.y) %
										2) ? e.y = Math.ceil(e.y) - e
										.y : e.y = e.y - Math.floor(e.y)
							}
							return this.flipY && (e.y = 1 - e.y), e
						}
					}, {
						key: "needsUpdate",
						set: function(e) {
							!0 === e && this.version++
						}
					}]), n
				}(xe);

			function Fe(e) {
				return "undefined" != typeof HTMLImageElement &&
					e instanceof HTMLImageElement || "undefined" !=
					typeof HTMLCanvasElement && e instanceof HTMLCanvasElement ||
					"undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Oe
					.getDataURL(e) : e.data ? {
						data: Array.prototype.slice.call(e.data),
						width: e.width,
						height: e.height,
						type: e.data.constructor.name
					} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
			}
			ze.DEFAULT_IMAGE = void 0, ze.DEFAULT_MAPPING = i, ze.prototype.isTexture = !0;
			var He = function() {
				function e() {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
							0] : 0,
						n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 0,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 0,
						i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1;
					(0, g.default)(this, e), this.x = t, this.y = n, this.z = r, this
						.w = i
				}
				return (0, y.default)(e, [{
					key: "width",
					get: function() {
						return this.z
					},
					set: function(e) {
						this.z = e
					}
				}, {
					key: "height",
					get: function() {
						return this.w
					},
					set: function(e) {
						this.w = e
					}
				}, {
					key: "set",
					value: function(e, t, n, r) {
						return this.x = e, this.y = t, this.z = n, this
							.w = r, this
					}
				}, {
					key: "setScalar",
					value: function(e) {
						return this.x = e, this.y = e, this.z = e, this
							.w = e, this
					}
				}, {
					key: "setX",
					value: function(e) {
						return this.x = e, this
					}
				}, {
					key: "setY",
					value: function(e) {
						return this.y = e, this
					}
				}, {
					key: "setZ",
					value: function(e) {
						return this.z = e, this
					}
				}, {
					key: "setW",
					value: function(e) {
						return this.w = e, this
					}
				}, {
					key: "setComponent",
					value: function(e, t) {
						switch (e) {
							case 0:
								this.x = t;
								break;
							case 1:
								this.y = t;
								break;
							case 2:
								this.z = t;
								break;
							case 3:
								this.w = t;
								break;
							default:
								throw new Error(
									"index is out of range: " + e)
						}
						return this
					}
				}, {
					key: "getComponent",
					value: function(e) {
						switch (e) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							case 3:
								return this.w;
							default:
								throw new Error(
									"index is out of range: " + e)
						}
					}
				}, {
					key: "clone",
					value: function() {
						return new this.constructor(this.x, this.y, this
							.z, this.w)
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.x = e.x, this.y = e.y, this.z = e.z,
							this.w = void 0 !== e.w ? e.w : 1, this
					}
				}, {
					key: "add",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
							"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(e, t)) : (this.x += e
							.x, this.y += e.y, this.z += e.z, this
							.w += e.w, this)
					}
				}, {
					key: "addScalar",
					value: function(e) {
						return this.x += e, this.y += e, this.z += e,
							this.w += e, this
					}
				}, {
					key: "addVectors",
					value: function(e, t) {
						return this.x = e.x + t.x, this.y = e.y + t.y,
							this.z = e.z + t.z, this.w = e.w + t.w, this
					}
				}, {
					key: "addScaledVector",
					value: function(e, t) {
						return this.x += e.x * t, this.y += e.y * t,
							this.z += e.z * t, this.w += e.w * t, this
					}
				}, {
					key: "sub",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
							"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(e, t)) : (this.x -= e
							.x, this.y -= e.y, this.z -= e.z, this
							.w -= e.w, this)
					}
				}, {
					key: "subScalar",
					value: function(e) {
						return this.x -= e, this.y -= e, this.z -= e,
							this.w -= e, this
					}
				}, {
					key: "subVectors",
					value: function(e, t) {
						return this.x = e.x - t.x, this.y = e.y - t.y,
							this.z = e.z - t.z, this.w = e.w - t.w, this
					}
				}, {
					key: "multiply",
					value: function(e) {
						return this.x *= e.x, this.y *= e.y, this.z *= e
							.z, this.w *= e.w, this
					}
				}, {
					key: "multiplyScalar",
					value: function(e) {
						return this.x *= e, this.y *= e, this.z *= e,
							this.w *= e, this
					}
				}, {
					key: "applyMatrix4",
					value: function(e) {
						var t = this.x,
							n = this.y,
							r = this.z,
							i = this.w,
							a = e.elements;
						return this.x = a[0] * t + a[4] * n + a[8] * r +
							a[12] * i, this.y = a[1] * t + a[5] * n + a[
								9] * r + a[13] * i, this.z = a[2] * t +
							a[6] * n + a[10] * r + a[14] * i, this.w =
							a[3] * t + a[7] * n + a[11] * r + a[15] * i,
							this
					}
				}, {
					key: "divideScalar",
					value: function(e) {
						return this.multiplyScalar(1 / e)
					}
				}, {
					key: "setAxisAngleFromQuaternion",
					value: function(e) {
						this.w = 2 * Math.acos(e.w);
						var t = Math.sqrt(1 - e.w * e.w);
						return t < 1e-4 ? (this.x = 1, this.y = 0, this
							.z = 0) : (this.x = e.x / t, this.y = e
							.y / t, this.z = e.z / t), this
					}
				}, {
					key: "setAxisAngleFromRotationMatrix",
					value: function(e) {
						var t, n, r, i, a = .01,
							o = .1,
							s = e.elements,
							l = s[0],
							u = s[4],
							c = s[8],
							h = s[1],
							d = s[5],
							f = s[9],
							p = s[2],
							v = s[6],
							m = s[10];
						if (Math.abs(u - h) < a && Math.abs(c - p) <
							a && Math.abs(f - v) < a) {
							if (Math.abs(u + h) < o && Math.abs(c + p) <
								o && Math.abs(f + v) < o && Math.abs(l +
									d + m - 3) < o) return this.set(1,
								0, 0, 0), this;
							t = Math.PI;
							var g = (l + 1) / 2,
								y = (d + 1) / 2,
								x = (m + 1) / 2,
								_ = (u + h) / 4,
								b = (c + p) / 4,
								w = (f + v) / 4;
							return g > y && g > x ? g < a ? (n = 0, r =
									.707106781, i = .707106781) : (r =
									_ / (n = Math.sqrt(g)), i = b / n) :
								y > x ? y < a ? (n = .707106781, r = 0,
									i = .707106781) : (n = _ / (r = Math
									.sqrt(y)), i = w / r) : x < a ? (n =
									.707106781, r = .707106781, i = 0) :
								(n = b / (i = Math.sqrt(x)), r = w / i),
								this.set(n, r, i, t), this
						}
						var M = Math.sqrt((v - f) * (v - f) + (c - p) *
							(c - p) + (h - u) * (h - u));
						return Math.abs(M) < .001 && (M = 1), this.x = (
								v - f) / M, this.y = (c - p) / M, this
							.z = (h - u) / M, this.w = Math.acos((l +
								d + m - 1) / 2), this
					}
				}, {
					key: "min",
					value: function(e) {
						return this.x = Math.min(this.x, e.x), this.y =
							Math.min(this.y, e.y), this.z = Math.min(
								this.z, e.z), this.w = Math.min(this.w,
								e.w), this
					}
				}, {
					key: "max",
					value: function(e) {
						return this.x = Math.max(this.x, e.x), this.y =
							Math.max(this.y, e.y), this.z = Math.max(
								this.z, e.z), this.w = Math.max(this.w,
								e.w), this
					}
				}, {
					key: "clamp",
					value: function(e, t) {
						return this.x = Math.max(e.x, Math.min(t.x, this
								.x)), this.y = Math.max(e.y, Math.min(t
								.y, this.y)), this.z = Math.max(e.z,
								Math.min(t.z, this.z)), this.w = Math
							.max(e.w, Math.min(t.w, this.w)), this
					}
				}, {
					key: "clampScalar",
					value: function(e, t) {
						return this.x = Math.max(e, Math.min(t, this
							.x)), this.y = Math.max(e, Math.min(t, this
								.y)), this.z = Math.max(e, Math.min(t,
								this.z)), this.w = Math.max(e, Math.min(
								t, this.w)), this
					}
				}, {
					key: "clampLength",
					value: function(e, t) {
						var n = this.length();
						return this.divideScalar(n || 1).multiplyScalar(
							Math.max(e, Math.min(t, n)))
					}
				}, {
					key: "floor",
					value: function() {
						return this.x = Math.floor(this.x), this.y =
							Math.floor(this.y), this.z = Math.floor(this
								.z), this.w = Math.floor(this.w), this
					}
				}, {
					key: "ceil",
					value: function() {
						return this.x = Math.ceil(this.x), this.y = Math
							.ceil(this.y), this.z = Math.ceil(this.z),
							this.w = Math.ceil(this.w), this
					}
				}, {
					key: "round",
					value: function() {
						return this.x = Math.round(this.x), this.y =
							Math.round(this.y), this.z = Math.round(this
								.z), this.w = Math.round(this.w), this
					}
				}, {
					key: "roundToZero",
					value: function() {
						return this.x = this.x < 0 ? Math.ceil(this.x) :
							Math.floor(this.x), this.y = this.y < 0 ?
							Math.ceil(this.y) : Math.floor(this.y), this
							.z = this.z < 0 ? Math.ceil(this.z) : Math
							.floor(this.z), this.w = this.w < 0 ? Math
							.ceil(this.w) : Math.floor(this.w), this
					}
				}, {
					key: "negate",
					value: function() {
						return this.x = -this.x, this.y = -this.y, this
							.z = -this.z, this.w = -this.w, this
					}
				}, {
					key: "dot",
					value: function(e) {
						return this.x * e.x + this.y * e.y + this.z * e
							.z + this.w * e.w
					}
				}, {
					key: "lengthSq",
					value: function() {
						return this.x * this.x + this.y * this.y + this
							.z * this.z + this.w * this.w
					}
				}, {
					key: "length",
					value: function() {
						return Math.sqrt(this.x * this.x + this.y * this
							.y + this.z * this.z + this.w * this.w)
					}
				}, {
					key: "manhattanLength",
					value: function() {
						return Math.abs(this.x) + Math.abs(this.y) +
							Math.abs(this.z) + Math.abs(this.w)
					}
				}, {
					key: "normalize",
					value: function() {
						return this.divideScalar(this.length() || 1)
					}
				}, {
					key: "setLength",
					value: function(e) {
						return this.normalize().multiplyScalar(e)
					}
				}, {
					key: "lerp",
					value: function(e, t) {
						return this.x += (e.x - this.x) * t, this.y += (
								e.y - this.y) * t, this.z += (e.z - this
								.z) * t, this.w += (e.w - this.w) * t,
							this
					}
				}, {
					key: "lerpVectors",
					value: function(e, t, n) {
						return this.x = e.x + (t.x - e.x) * n, this.y =
							e.y + (t.y - e.y) * n, this.z = e.z + (t.z -
								e.z) * n, this.w = e.w + (t.w - e.w) *
							n, this
					}
				}, {
					key: "equals",
					value: function(e) {
						return e.x === this.x && e.y === this.y && e
							.z === this.z && e.w === this.w
					}
				}, {
					key: "fromArray",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return this.x = e[t], this.y = e[t + 1], this
							.z = e[t + 2], this.w = e[t + 3], this
					}
				}, {
					key: "toArray",
					value: function() {
						var e = arguments.length > 0 && void 0 !==
							arguments[0] ? arguments[0] : [],
							t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return e[t] = this.x, e[t + 1] = this.y, e[t +
							2] = this.z, e[t + 3] = this.w, e
					}
				}, {
					key: "fromBufferAttribute",
					value: function(e, t, n) {
						return void 0 !== n && console.warn(
							"THREE.Vector4: offset has been removed from .fromBufferAttribute()."
							), this.x = e.getX(t), this.y = e.getY(
							t), this.z = e.getZ(t), this.w = e.getW(
							t), this
					}
				}, {
					key: "random",
					value: function() {
						return this.x = Math.random(), this.y = Math
							.random(), this.z = Math.random(), this.w =
							Math.random(), this
					}
				}]), e
			}();
			He.prototype.isVector4 = !0;
			var Ue = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i) {
					var a;
					return (0, g.default)(this, n), (a = t.call(this)).width = e, a
						.height = r, a.depth = 1, a.scissor = new He(0, 0, e, r), a
						.scissorTest = !1, a.viewport = new He(0, 0, e, r), i = i || {},
						a.texture = new ze(void 0, i.mapping, i.wrapS, i.wrapT, i
							.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i
							.encoding), a.texture.image = {}, a.texture.image.width = e,
						a.texture.image.height = r, a.texture.image.depth = 1, a.texture
						.generateMipmaps = void 0 !== i.generateMipmaps && i
						.generateMipmaps, a.texture.minFilter = void 0 !== i.minFilter ?
						i.minFilter : C, a.depthBuffer = void 0 === i.depthBuffer || i
						.depthBuffer, a.stencilBuffer = void 0 !== i.stencilBuffer && i
						.stencilBuffer, a.depthTexture = void 0 !== i.depthTexture ? i
						.depthTexture : null, a
				}
				return (0, y.default)(n, [{
					key: "setTexture",
					value: function(e) {
						e.image = {
							width: this.width,
							height: this.height,
							depth: this.depth
						}, this.texture = e
					}
				}, {
					key: "setSize",
					value: function(e, t) {
						var n = arguments.length > 2 && void 0 !==
							arguments[2] ? arguments[2] : 1;
						this.width === e && this.height === t && this
							.depth === n || (this.width = e, this
								.height = t, this.depth = n, this
								.texture.image.width = e, this.texture
								.image.height = t, this.texture.image
								.depth = n, this.dispose()), this
							.viewport.set(0, 0, e, t), this.scissor.set(
								0, 0, e, t)
					}
				}, {
					key: "clone",
					value: function() {
						return (new this.constructor).copy(this)
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.width = e.width, this.height = e
							.height, this.depth = e.depth, this.viewport
							.copy(e.viewport), this.texture = e.texture
							.clone(), this.texture.image = function(e) {
								for (var t = 1; t < arguments
									.length; t++) {
									var n = null != arguments[t] ?
										arguments[t] : {};
									t % 2 ? w(Object(n), !0).forEach((
											function(t) {
												(0, d.default)(e, t,
													n[t])
											})) : Object
										.getOwnPropertyDescriptors ?
										Object.defineProperties(e,
											Object
											.getOwnPropertyDescriptors(
												n)) : w(Object(n))
										.forEach((function(t) {
											Object
												.defineProperty(
													e, t, Object
													.getOwnPropertyDescriptor(
														n, t))
										}))
								}
								return e
							}({}, this.texture.image), this
							.depthBuffer = e.depthBuffer, this
							.stencilBuffer = e.stencilBuffer, this
							.depthTexture = e.depthTexture, this
					}
				}, {
					key: "dispose",
					value: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				}]), n
			}(xe);
			Ue.prototype.isWebGLRenderTarget = !0;
			var Ge = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i) {
					var a;
					(0, g.default)(this, n);
					var o = (a = t.call(this, e, r)).texture;
					a.texture = [];
					for (var s = 0; s < i; s++) a.texture[s] = o.clone();
					return a
				}
				return (0, y.default)(n, [{
					key: "setSize",
					value: function(e, t) {
						var n = arguments.length > 2 && void 0 !==
							arguments[2] ? arguments[2] : 1;
						if (this.width !== e || this.height !== t ||
							this.depth !== n) {
							this.width = e, this.height = t, this
								.depth = n;
							for (var r = 0, i = this.texture.length; r <
								i; r++) this.texture[r].image.width = e,
								this.texture[r].image.height = t, this
								.texture[r].image.depth = n;
							this.dispose()
						}
						return this.viewport.set(0, 0, e, t), this
							.scissor.set(0, 0, e, t), this
					}
				}, {
					key: "copy",
					value: function(e) {
						this.dispose(), this.width = e.width, this
							.height = e.height, this.depth = e.depth,
							this.viewport.set(0, 0, this.width, this
								.height), this.scissor.set(0, 0, this
								.width, this.height), this.depthBuffer =
							e.depthBuffer, this.stencilBuffer = e
							.stencilBuffer, this.depthTexture = e
							.depthTexture, this.texture.length = 0;
						for (var t = 0, n = e.texture.length; t <
							n; t++) this.texture[t] = e.texture[t]
							.clone();
						return this
					}
				}]), n
			}(Ue);
			Ge.prototype.isWebGLMultipleRenderTargets = !0;
			var Ve = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i) {
					var a;
					return (0, g.default)(this, n), (a = t.call(this, e, r, i))
						.samples = 4, a
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.samples = e.samples, this
					}
				}]), n
			}(Ue);
			Ve.prototype.isWebGLMultisampleRenderTarget = !0;
			var We = function() {
				function e() {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
							0] : 0,
						n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 0,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 0,
						i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1;
					(0, g.default)(this, e), this._x = t, this._y = n, this._z = r, this
						._w = i
				}
				return (0, y.default)(e, [{
					key: "x",
					get: function() {
						return this._x
					},
					set: function(e) {
						this._x = e, this._onChangeCallback()
					}
				}, {
					key: "y",
					get: function() {
						return this._y
					},
					set: function(e) {
						this._y = e, this._onChangeCallback()
					}
				}, {
					key: "z",
					get: function() {
						return this._z
					},
					set: function(e) {
						this._z = e, this._onChangeCallback()
					}
				}, {
					key: "w",
					get: function() {
						return this._w
					},
					set: function(e) {
						this._w = e, this._onChangeCallback()
					}
				}, {
					key: "set",
					value: function(e, t, n, r) {
						return this._x = e, this._y = t, this._z = n,
							this._w = r, this._onChangeCallback(), this
					}
				}, {
					key: "clone",
					value: function() {
						return new this.constructor(this._x, this._y,
							this._z, this._w)
					}
				}, {
					key: "copy",
					value: function(e) {
						return this._x = e.x, this._y = e.y, this._z = e
							.z, this._w = e.w, this._onChangeCallback(),
							this
					}
				}, {
					key: "setFromEuler",
					value: function(e, t) {
						if (!e || !e.isEuler) throw new Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
							);
						var n = e._x,
							r = e._y,
							i = e._z,
							a = e._order,
							o = Math.cos,
							s = Math.sin,
							l = o(n / 2),
							u = o(r / 2),
							c = o(i / 2),
							h = s(n / 2),
							d = s(r / 2),
							f = s(i / 2);
						switch (a) {
							case "XYZ":
								this._x = h * u * c + l * d * f, this
									._y = l * d * c - h * u * f, this
									._z = l * u * f + h * d * c, this
									._w = l * u * c - h * d * f;
								break;
							case "YXZ":
								this._x = h * u * c + l * d * f, this
									._y = l * d * c - h * u * f, this
									._z = l * u * f - h * d * c, this
									._w = l * u * c + h * d * f;
								break;
							case "ZXY":
								this._x = h * u * c - l * d * f, this
									._y = l * d * c + h * u * f, this
									._z = l * u * f + h * d * c, this
									._w = l * u * c - h * d * f;
								break;
							case "ZYX":
								this._x = h * u * c - l * d * f, this
									._y = l * d * c + h * u * f, this
									._z = l * u * f - h * d * c, this
									._w = l * u * c + h * d * f;
								break;
							case "YZX":
								this._x = h * u * c + l * d * f, this
									._y = l * d * c + h * u * f, this
									._z = l * u * f - h * d * c, this
									._w = l * u * c - h * d * f;
								break;
							case "XZY":
								this._x = h * u * c - l * d * f, this
									._y = l * d * c - h * u * f, this
									._z = l * u * f + h * d * c, this
									._w = l * u * c + h * d * f;
								break;
							default:
								console.warn(
									"THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
									a)
						}
						return !1 !== t && this._onChangeCallback(),
							this
					}
				}, {
					key: "setFromAxisAngle",
					value: function(e, t) {
						var n = t / 2,
							r = Math.sin(n);
						return this._x = e.x * r, this._y = e.y * r,
							this._z = e.z * r, this._w = Math.cos(n),
							this._onChangeCallback(), this
					}
				}, {
					key: "setFromRotationMatrix",
					value: function(e) {
						var t = e.elements,
							n = t[0],
							r = t[4],
							i = t[8],
							a = t[1],
							o = t[5],
							s = t[9],
							l = t[2],
							u = t[6],
							c = t[10],
							h = n + o + c;
						if (h > 0) {
							var d = .5 / Math.sqrt(h + 1);
							this._w = .25 / d, this._x = (u - s) * d,
								this._y = (i - l) * d, this._z = (a -
								r) * d
						} else if (n > o && n > c) {
							var f = 2 * Math.sqrt(1 + n - o - c);
							this._w = (u - s) / f, this._x = .25 * f,
								this._y = (r + a) / f, this._z = (i +
								l) / f
						} else if (o > c) {
							var p = 2 * Math.sqrt(1 + o - n - c);
							this._w = (i - l) / p, this._x = (r + a) /
								p, this._y = .25 * p, this._z = (s +
								u) / p
						} else {
							var v = 2 * Math.sqrt(1 + c - n - o);
							this._w = (a - r) / v, this._x = (i + l) /
								v, this._y = (s + u) / v, this._z =
								.25 * v
						}
						return this._onChangeCallback(), this
					}
				}, {
					key: "setFromUnitVectors",
					value: function(e, t) {
						var n = e.dot(t) + 1;
						return n < Number.EPSILON ? (n = 0, Math.abs(e
								.x) > Math.abs(e.z) ? (this._x = -e
								.y, this._y = e.x, this._z = 0, this
								._w = n) : (this._x = 0, this._y = -
								e.z, this._z = e.y, this._w = n)) : (
								this._x = e.y * t.z - e.z * t.y, this
								._y = e.z * t.x - e.x * t.z, this._z = e
								.x * t.y - e.y * t.x, this._w = n), this
							.normalize()
					}
				}, {
					key: "angleTo",
					value: function(e) {
						return 2 * Math.acos(Math.abs(Ee(this.dot(e), -
							1, 1)))
					}
				}, {
					key: "rotateTowards",
					value: function(e, t) {
						var n = this.angleTo(e);
						if (0 === n) return this;
						var r = Math.min(1, t / n);
						return this.slerp(e, r), this
					}
				}, {
					key: "identity",
					value: function() {
						return this.set(0, 0, 0, 1)
					}
				}, {
					key: "invert",
					value: function() {
						return this.conjugate()
					}
				}, {
					key: "conjugate",
					value: function() {
						return this._x *= -1, this._y *= -1, this._z *=
							-1, this._onChangeCallback(), this
					}
				}, {
					key: "dot",
					value: function(e) {
						return this._x * e._x + this._y * e._y + this
							._z * e._z + this._w * e._w
					}
				}, {
					key: "lengthSq",
					value: function() {
						return this._x * this._x + this._y * this._y +
							this._z * this._z + this._w * this._w
					}
				}, {
					key: "length",
					value: function() {
						return Math.sqrt(this._x * this._x + this._y *
							this._y + this._z * this._z + this._w *
							this._w)
					}
				}, {
					key: "normalize",
					value: function() {
						var e = this.length();
						return 0 === e ? (this._x = 0, this._y = 0, this
							._z = 0, this._w = 1) : (e = 1 / e, this
							._x = this._x * e, this._y = this._y *
							e, this._z = this._z * e, this._w = this
							._w * e), this._onChangeCallback(), this
					}
				}, {
					key: "multiply",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
								"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
								), this.multiplyQuaternions(e, t)) :
							this.multiplyQuaternions(this, e)
					}
				}, {
					key: "premultiply",
					value: function(e) {
						return this.multiplyQuaternions(e, this)
					}
				}, {
					key: "multiplyQuaternions",
					value: function(e, t) {
						var n = e._x,
							r = e._y,
							i = e._z,
							a = e._w,
							o = t._x,
							s = t._y,
							l = t._z,
							u = t._w;
						return this._x = n * u + a * o + r * l - i * s,
							this._y = r * u + a * s + i * o - n * l,
							this._z = i * u + a * l + n * s - r * o,
							this._w = a * u - n * o - r * s - i * l,
							this._onChangeCallback(), this
					}
				}, {
					key: "slerp",
					value: function(e, t) {
						if (0 === t) return this;
						if (1 === t) return this.copy(e);
						var n = this._x,
							r = this._y,
							i = this._z,
							a = this._w,
							o = a * e._w + n * e._x + r * e._y + i * e
							._z;
						if (o < 0 ? (this._w = -e._w, this._x = -e._x,
								this._y = -e._y, this._z = -e._z, o = -o
								) : this.copy(e), o >= 1) return this
							._w = a, this._x = n, this._y = r, this
							._z = i, this;
						var s = 1 - o * o;
						if (s <= Number.EPSILON) {
							var l = 1 - t;
							return this._w = l * a + t * this._w, this
								._x = l * n + t * this._x, this._y = l *
								r + t * this._y, this._z = l * i + t *
								this._z, this.normalize(), this
								._onChangeCallback(), this
						}
						var u = Math.sqrt(s),
							c = Math.atan2(u, o),
							h = Math.sin((1 - t) * c) / u,
							d = Math.sin(t * c) / u;
						return this._w = a * h + this._w * d, this._x =
							n * h + this._x * d, this._y = r * h + this
							._y * d, this._z = i * h + this._z * d, this
							._onChangeCallback(), this
					}
				}, {
					key: "slerpQuaternions",
					value: function(e, t, n) {
						this.copy(e).slerp(t, n)
					}
				}, {
					key: "equals",
					value: function(e) {
						return e._x === this._x && e._y === this._y && e
							._z === this._z && e._w === this._w
					}
				}, {
					key: "fromArray",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return this._x = e[t], this._y = e[t + 1], this
							._z = e[t + 2], this._w = e[t + 3], this
							._onChangeCallback(), this
					}
				}, {
					key: "toArray",
					value: function() {
						var e = arguments.length > 0 && void 0 !==
							arguments[0] ? arguments[0] : [],
							t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return e[t] = this._x, e[t + 1] = this._y, e[t +
							2] = this._z, e[t + 3] = this._w, e
					}
				}, {
					key: "fromBufferAttribute",
					value: function(e, t) {
						return this._x = e.getX(t), this._y = e.getY(t),
							this._z = e.getZ(t), this._w = e.getW(t),
							this
					}
				}, {
					key: "_onChange",
					value: function(e) {
						return this._onChangeCallback = e, this
					}
				}, {
					key: "_onChangeCallback",
					value: function() {}
				}], [{
					key: "slerp",
					value: function(e, t, n, r) {
						return console.warn(
							"THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
							), n.slerpQuaternions(e, t, r)
					}
				}, {
					key: "slerpFlat",
					value: function(e, t, n, r, i, a, o) {
						var s = n[r + 0],
							l = n[r + 1],
							u = n[r + 2],
							c = n[r + 3],
							h = i[a + 0],
							d = i[a + 1],
							f = i[a + 2],
							p = i[a + 3];
						if (0 === o) return e[t + 0] = s, e[t + 1] = l,
							e[t + 2] = u, void(e[t + 3] = c);
						if (1 === o) return e[t + 0] = h, e[t + 1] = d,
							e[t + 2] = f, void(e[t + 3] = p);
						if (c !== p || s !== h || l !== d || u !== f) {
							var v = 1 - o,
								m = s * h + l * d + u * f + c * p,
								g = m >= 0 ? 1 : -1,
								y = 1 - m * m;
							if (y > Number.EPSILON) {
								var x = Math.sqrt(y),
									_ = Math.atan2(x, m * g);
								v = Math.sin(v * _) / x, o = Math.sin(
									o * _) / x
							}
							var b = o * g;
							if (s = s * v + h * b, l = l * v + d * b,
								u = u * v + f * b, c = c * v + p * b,
								v === 1 - o) {
								var w = 1 / Math.sqrt(s * s + l * l +
									u * u + c * c);
								s *= w, l *= w, u *= w, c *= w
							}
						}
						e[t] = s, e[t + 1] = l, e[t + 2] = u, e[t + 3] =
							c
					}
				}, {
					key: "multiplyQuaternionsFlat",
					value: function(e, t, n, r, i, a) {
						var o = n[r],
							s = n[r + 1],
							l = n[r + 2],
							u = n[r + 3],
							c = i[a],
							h = i[a + 1],
							d = i[a + 2],
							f = i[a + 3];
						return e[t] = o * f + u * c + s * d - l * h, e[
								t + 1] = s * f + u * h + l * c - o * d,
							e[t + 2] = l * f + u * d + o * h - s * c, e[
								t + 3] = u * f - o * c - s * h - l * d,
							e
					}
				}]), e
			}();
			We.prototype.isQuaternion = !0;
			var je = function() {
				function e() {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
							0] : 0,
						n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 0,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 0;
					(0, g.default)(this, e), this.x = t, this.y = n, this.z = r
				}
				return (0, y.default)(e, [{
					key: "set",
					value: function(e, t, n) {
						return void 0 === n && (n = this.z), this.x = e,
							this.y = t, this.z = n, this
					}
				}, {
					key: "setScalar",
					value: function(e) {
						return this.x = e, this.y = e, this.z = e, this
					}
				}, {
					key: "setX",
					value: function(e) {
						return this.x = e, this
					}
				}, {
					key: "setY",
					value: function(e) {
						return this.y = e, this
					}
				}, {
					key: "setZ",
					value: function(e) {
						return this.z = e, this
					}
				}, {
					key: "setComponent",
					value: function(e, t) {
						switch (e) {
							case 0:
								this.x = t;
								break;
							case 1:
								this.y = t;
								break;
							case 2:
								this.z = t;
								break;
							default:
								throw new Error(
									"index is out of range: " + e)
						}
						return this
					}
				}, {
					key: "getComponent",
					value: function(e) {
						switch (e) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error(
									"index is out of range: " + e)
						}
					}
				}, {
					key: "clone",
					value: function() {
						return new this.constructor(this.x, this.y, this
							.z)
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.x = e.x, this.y = e.y, this.z = e.z,
							this
					}
				}, {
					key: "add",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
							"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(e, t)) : (this.x += e
							.x, this.y += e.y, this.z += e.z, this)
					}
				}, {
					key: "addScalar",
					value: function(e) {
						return this.x += e, this.y += e, this.z += e,
							this
					}
				}, {
					key: "addVectors",
					value: function(e, t) {
						return this.x = e.x + t.x, this.y = e.y + t.y,
							this.z = e.z + t.z, this
					}
				}, {
					key: "addScaledVector",
					value: function(e, t) {
						return this.x += e.x * t, this.y += e.y * t,
							this.z += e.z * t, this
					}
				}, {
					key: "sub",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(e, t)) : (this.x -= e
							.x, this.y -= e.y, this.z -= e.z, this)
					}
				}, {
					key: "subScalar",
					value: function(e) {
						return this.x -= e, this.y -= e, this.z -= e,
							this
					}
				}, {
					key: "subVectors",
					value: function(e, t) {
						return this.x = e.x - t.x, this.y = e.y - t.y,
							this.z = e.z - t.z, this
					}
				}, {
					key: "multiply",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
							"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
							), this.multiplyVectors(e, t)) : (this
							.x *= e.x, this.y *= e.y, this.z *= e.z,
							this)
					}
				}, {
					key: "multiplyScalar",
					value: function(e) {
						return this.x *= e, this.y *= e, this.z *= e,
							this
					}
				}, {
					key: "multiplyVectors",
					value: function(e, t) {
						return this.x = e.x * t.x, this.y = e.y * t.y,
							this.z = e.z * t.z, this
					}
				}, {
					key: "applyEuler",
					value: function(e) {
						return e && e.isEuler || console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
							), this.applyQuaternion(Xe.setFromEuler(
							e))
					}
				}, {
					key: "applyAxisAngle",
					value: function(e, t) {
						return this.applyQuaternion(Xe.setFromAxisAngle(
							e, t))
					}
				}, {
					key: "applyMatrix3",
					value: function(e) {
						var t = this.x,
							n = this.y,
							r = this.z,
							i = e.elements;
						return this.x = i[0] * t + i[3] * n + i[6] * r,
							this.y = i[1] * t + i[4] * n + i[7] * r,
							this.z = i[2] * t + i[5] * n + i[8] * r,
							this
					}
				}, {
					key: "applyNormalMatrix",
					value: function(e) {
						return this.applyMatrix3(e).normalize()
					}
				}, {
					key: "applyMatrix4",
					value: function(e) {
						var t = this.x,
							n = this.y,
							r = this.z,
							i = e.elements,
							a = 1 / (i[3] * t + i[7] * n + i[11] * r +
								i[15]);
						return this.x = (i[0] * t + i[4] * n + i[8] *
								r + i[12]) * a, this.y = (i[1] * t + i[
								5] * n + i[9] * r + i[13]) * a, this.z =
							(i[2] * t + i[6] * n + i[10] * r + i[14]) *
							a, this
					}
				}, {
					key: "applyQuaternion",
					value: function(e) {
						var t = this.x,
							n = this.y,
							r = this.z,
							i = e.x,
							a = e.y,
							o = e.z,
							s = e.w,
							l = s * t + a * r - o * n,
							u = s * n + o * t - i * r,
							c = s * r + i * n - a * t,
							h = -i * t - a * n - o * r;
						return this.x = l * s + h * -i + u * -o - c * -
							a, this.y = u * s + h * -a + c * -i - l * -
							o, this.z = c * s + h * -o + l * -a - u * -
							i, this
					}
				}, {
					key: "project",
					value: function(e) {
						return this.applyMatrix4(e.matrixWorldInverse)
							.applyMatrix4(e.projectionMatrix)
					}
				}, {
					key: "unproject",
					value: function(e) {
						return this.applyMatrix4(e
							.projectionMatrixInverse).applyMatrix4(e
							.matrixWorld)
					}
				}, {
					key: "transformDirection",
					value: function(e) {
						var t = this.x,
							n = this.y,
							r = this.z,
							i = e.elements;
						return this.x = i[0] * t + i[4] * n + i[8] * r,
							this.y = i[1] * t + i[5] * n + i[9] * r,
							this.z = i[2] * t + i[6] * n + i[10] * r,
							this.normalize()
					}
				}, {
					key: "divide",
					value: function(e) {
						return this.x /= e.x, this.y /= e.y, this.z /= e
							.z, this
					}
				}, {
					key: "divideScalar",
					value: function(e) {
						return this.multiplyScalar(1 / e)
					}
				}, {
					key: "min",
					value: function(e) {
						return this.x = Math.min(this.x, e.x), this.y =
							Math.min(this.y, e.y), this.z = Math.min(
								this.z, e.z), this
					}
				}, {
					key: "max",
					value: function(e) {
						return this.x = Math.max(this.x, e.x), this.y =
							Math.max(this.y, e.y), this.z = Math.max(
								this.z, e.z), this
					}
				}, {
					key: "clamp",
					value: function(e, t) {
						return this.x = Math.max(e.x, Math.min(t.x, this
							.x)), this.y = Math.max(e.y, Math.min(t
							.y, this.y)), this.z = Math.max(e.z,
							Math.min(t.z, this.z)), this
					}
				}, {
					key: "clampScalar",
					value: function(e, t) {
						return this.x = Math.max(e, Math.min(t, this
							.x)), this.y = Math.max(e, Math.min(t, this
								.y)), this.z = Math.max(e, Math.min(t,
								this.z)), this
					}
				}, {
					key: "clampLength",
					value: function(e, t) {
						var n = this.length();
						return this.divideScalar(n || 1).multiplyScalar(
							Math.max(e, Math.min(t, n)))
					}
				}, {
					key: "floor",
					value: function() {
						return this.x = Math.floor(this.x), this.y =
							Math.floor(this.y), this.z = Math.floor(this
								.z), this
					}
				}, {
					key: "ceil",
					value: function() {
						return this.x = Math.ceil(this.x), this.y = Math
							.ceil(this.y), this.z = Math.ceil(this.z),
							this
					}
				}, {
					key: "round",
					value: function() {
						return this.x = Math.round(this.x), this.y =
							Math.round(this.y), this.z = Math.round(this
								.z), this
					}
				}, {
					key: "roundToZero",
					value: function() {
						return this.x = this.x < 0 ? Math.ceil(this.x) :
							Math.floor(this.x), this.y = this.y < 0 ?
							Math.ceil(this.y) : Math.floor(this.y), this
							.z = this.z < 0 ? Math.ceil(this.z) : Math
							.floor(this.z), this
					}
				}, {
					key: "negate",
					value: function() {
						return this.x = -this.x, this.y = -this.y, this
							.z = -this.z, this
					}
				}, {
					key: "dot",
					value: function(e) {
						return this.x * e.x + this.y * e.y + this.z * e
							.z
					}
				}, {
					key: "lengthSq",
					value: function() {
						return this.x * this.x + this.y * this.y + this
							.z * this.z
					}
				}, {
					key: "length",
					value: function() {
						return Math.sqrt(this.x * this.x + this.y * this
							.y + this.z * this.z)
					}
				}, {
					key: "manhattanLength",
					value: function() {
						return Math.abs(this.x) + Math.abs(this.y) +
							Math.abs(this.z)
					}
				}, {
					key: "normalize",
					value: function() {
						return this.divideScalar(this.length() || 1)
					}
				}, {
					key: "setLength",
					value: function(e) {
						return this.normalize().multiplyScalar(e)
					}
				}, {
					key: "lerp",
					value: function(e, t) {
						return this.x += (e.x - this.x) * t, this.y += (
							e.y - this.y) * t, this.z += (e.z - this
							.z) * t, this
					}
				}, {
					key: "lerpVectors",
					value: function(e, t, n) {
						return this.x = e.x + (t.x - e.x) * n, this.y =
							e.y + (t.y - e.y) * n, this.z = e.z + (t.z -
								e.z) * n, this
					}
				}, {
					key: "cross",
					value: function(e, t) {
						return void 0 !== t ? (console.warn(
								"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
								), this.crossVectors(e, t)) : this
							.crossVectors(this, e)
					}
				}, {
					key: "crossVectors",
					value: function(e, t) {
						var n = e.x,
							r = e.y,
							i = e.z,
							a = t.x,
							o = t.y,
							s = t.z;
						return this.x = r * s - i * o, this.y = i * a -
							n * s, this.z = n * o - r * a, this
					}
				}, {
					key: "projectOnVector",
					value: function(e) {
						var t = e.lengthSq();
						if (0 === t) return this.set(0, 0, 0);
						var n = e.dot(this) / t;
						return this.copy(e).multiplyScalar(n)
					}
				}, {
					key: "projectOnPlane",
					value: function(e) {
						return qe.copy(this).projectOnVector(e), this
							.sub(qe)
					}
				}, {
					key: "reflect",
					value: function(e) {
						return this.sub(qe.copy(e).multiplyScalar(2 *
							this.dot(e)))
					}
				}, {
					key: "angleTo",
					value: function(e) {
						var t = Math.sqrt(this.lengthSq() * e
						.lengthSq());
						if (0 === t) return Math.PI / 2;
						var n = this.dot(e) / t;
						return Math.acos(Ee(n, -1, 1))
					}
				}, {
					key: "distanceTo",
					value: function(e) {
						return Math.sqrt(this.distanceToSquared(e))
					}
				}, {
					key: "distanceToSquared",
					value: function(e) {
						var t = this.x - e.x,
							n = this.y - e.y,
							r = this.z - e.z;
						return t * t + n * n + r * r
					}
				}, {
					key: "manhattanDistanceTo",
					value: function(e) {
						return Math.abs(this.x - e.x) + Math.abs(this
							.y - e.y) + Math.abs(this.z - e.z)
					}
				}, {
					key: "setFromSpherical",
					value: function(e) {
						return this.setFromSphericalCoords(e.radius, e
							.phi, e.theta)
					}
				}, {
					key: "setFromSphericalCoords",
					value: function(e, t, n) {
						var r = Math.sin(t) * e;
						return this.x = r * Math.sin(n), this.y = Math
							.cos(t) * e, this.z = r * Math.cos(n), this
					}
				}, {
					key: "setFromCylindrical",
					value: function(e) {
						return this.setFromCylindricalCoords(e.radius, e
							.theta, e.y)
					}
				}, {
					key: "setFromCylindricalCoords",
					value: function(e, t, n) {
						return this.x = e * Math.sin(t), this.y = n,
							this.z = e * Math.cos(t), this
					}
				}, {
					key: "setFromMatrixPosition",
					value: function(e) {
						var t = e.elements;
						return this.x = t[12], this.y = t[13], this.z =
							t[14], this
					}
				}, {
					key: "setFromMatrixScale",
					value: function(e) {
						var t = this.setFromMatrixColumn(e, 0).length(),
							n = this.setFromMatrixColumn(e, 1).length(),
							r = this.setFromMatrixColumn(e, 2).length();
						return this.x = t, this.y = n, this.z = r, this
					}
				}, {
					key: "setFromMatrixColumn",
					value: function(e, t) {
						return this.fromArray(e.elements, 4 * t)
					}
				}, {
					key: "setFromMatrix3Column",
					value: function(e, t) {
						return this.fromArray(e.elements, 3 * t)
					}
				}, {
					key: "equals",
					value: function(e) {
						return e.x === this.x && e.y === this.y && e
							.z === this.z
					}
				}, {
					key: "fromArray",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return this.x = e[t], this.y = e[t + 1], this
							.z = e[t + 2], this
					}
				}, {
					key: "toArray",
					value: function() {
						var e = arguments.length > 0 && void 0 !==
							arguments[0] ? arguments[0] : [],
							t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return e[t] = this.x, e[t + 1] = this.y, e[t +
							2] = this.z, e
					}
				}, {
					key: "fromBufferAttribute",
					value: function(e, t, n) {
						return void 0 !== n && console.warn(
							"THREE.Vector3: offset has been removed from .fromBufferAttribute()."
							), this.x = e.getX(t), this.y = e.getY(
							t), this.z = e.getZ(t), this
					}
				}, {
					key: "random",
					value: function() {
						return this.x = Math.random(), this.y = Math
							.random(), this.z = Math.random(), this
					}
				}]), e
			}();
			je.prototype.isVector3 = !0;
			var qe = new je,
				Xe = new We,
				Ye = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je(1 / 0, 1 / 0, 1 / 0),
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je(-1 / 0, -1 / 0, -1 / 0);
						(0, g.default)(this, e), this.min = t, this.max = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.min.copy(e), this.max.copy(t), this
						}
					}, {
						key: "setFromArray",
						value: function(e) {
							for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -
									1 / 0, a = -1 / 0, o = -1 / 0, s = 0,
									l = e.length; s < l; s += 3) {
								var u = e[s],
									c = e[s + 1],
									h = e[s + 2];
								u < t && (t = u), c < n && (n = c), h < r &&
									(r = h), u > i && (i = u), c > a && (a =
										c), h > o && (o = h)
							}
							return this.min.set(t, n, r), this.max.set(i, a,
								o), this
						}
					}, {
						key: "setFromBufferAttribute",
						value: function(e) {
							for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -
									1 / 0, a = -1 / 0, o = -1 / 0, s = 0,
									l = e.count; s < l; s++) {
								var u = e.getX(s),
									c = e.getY(s),
									h = e.getZ(s);
								u < t && (t = u), c < n && (n = c), h < r &&
									(r = h), u > i && (i = u), c > a && (a =
										c), h > o && (o = h)
							}
							return this.min.set(t, n, r), this.max.set(i, a,
								o), this
						}
					}, {
						key: "setFromPoints",
						value: function(e) {
							this.makeEmpty();
							for (var t = 0, n = e.length; t < n; t++) this
								.expandByPoint(e[t]);
							return this
						}
					}, {
						key: "setFromCenterAndSize",
						value: function(e, t) {
							var n = Ze.copy(t).multiplyScalar(.5);
							return this.min.copy(e).sub(n), this.max.copy(e)
								.add(n), this
						}
					}, {
						key: "setFromObject",
						value: function(e) {
							return this.makeEmpty(), this.expandByObject(e)
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.min.copy(e.min), this.max.copy(e
								.max), this
						}
					}, {
						key: "makeEmpty",
						value: function() {
							return this.min.x = this.min.y = this.min.z =
								1 / 0, this.max.x = this.max.y = this.max
								.z = -1 / 0, this
						}
					}, {
						key: "isEmpty",
						value: function() {
							return this.max.x < this.min.x || this.max.y <
								this.min.y || this.max.z < this.min.z
						}
					}, {
						key: "getCenter",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Box3: .getCenter() target is now required"
								), e = new je), this.isEmpty() ? e.set(
								0, 0, 0) : e.addVectors(this.min, this
								.max).multiplyScalar(.5)
						}
					}, {
						key: "getSize",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Box3: .getSize() target is now required"
								), e = new je), this.isEmpty() ? e.set(
								0, 0, 0) : e.subVectors(this.max, this
								.min)
						}
					}, {
						key: "expandByPoint",
						value: function(e) {
							return this.min.min(e), this.max.max(e), this
						}
					}, {
						key: "expandByVector",
						value: function(e) {
							return this.min.sub(e), this.max.add(e), this
						}
					}, {
						key: "expandByScalar",
						value: function(e) {
							return this.min.addScalar(-e), this.max
								.addScalar(e), this
						}
					}, {
						key: "expandByObject",
						value: function(e) {
							e.updateWorldMatrix(!1, !1);
							var t = e.geometry;
							void 0 !== t && (null === t.boundingBox && t
								.computeBoundingBox(), Je.copy(t
									.boundingBox), Je.applyMatrix4(e
									.matrixWorld), this.union(Je));
							for (var n = e.children, r = 0, i = n
								.length; r < i; r++) this.expandByObject(n[
								r]);
							return this
						}
					}, {
						key: "containsPoint",
						value: function(e) {
							return !(e.x < this.min.x || e.x > this.max.x ||
								e.y < this.min.y || e.y > this.max.y ||
								e.z < this.min.z || e.z > this.max.z)
						}
					}, {
						key: "containsBox",
						value: function(e) {
							return this.min.x <= e.min.x && e.max.x <= this
								.max.x && this.min.y <= e.min.y && e.max
								.y <= this.max.y && this.min.z <= e.min.z &&
								e.max.z <= this.max.z
						}
					}, {
						key: "getParameter",
						value: function(e, t) {
							return void 0 === t && (console.warn(
								"THREE.Box3: .getParameter() target is now required"
								), t = new je), t.set((e.x - this.min
								.x) / (this.max.x - this.min.x), (e.y -
									this.min.y) / (this.max.y - this.min
									.y), (e.z - this.min.z) / (this.max
									.z - this.min.z))
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return !(e.max.x < this.min.x || e.min.x > this
								.max.x || e.max.y < this.min.y || e.min
								.y > this.max.y || e.max.z < this.min
								.z || e.min.z > this.max.z)
						}
					}, {
						key: "intersectsSphere",
						value: function(e) {
							return this.clampPoint(e.center, Ze), Ze
								.distanceToSquared(e.center) <= e.radius * e
								.radius
						}
					}, {
						key: "intersectsPlane",
						value: function(e) {
							var t, n;
							return e.normal.x > 0 ? (t = e.normal.x * this
									.min.x, n = e.normal.x * this.max.x) : (
									t = e.normal.x * this.max.x, n = e
									.normal.x * this.min.x), e.normal.y >
								0 ? (t += e.normal.y * this.min.y, n += e
									.normal.y * this.max.y) : (t += e.normal
									.y * this.max.y, n += e.normal.y * this
									.min.y), e.normal.z > 0 ? (t += e.normal
									.z * this.min.z, n += e.normal.z * this
									.max.z) : (t += e.normal.z * this.max.z,
									n += e.normal.z * this.min.z), t <= -e
								.constant && n >= -e.constant
						}
					}, {
						key: "intersectsTriangle",
						value: function(e) {
							if (this.isEmpty()) return !1;
							this.getCenter(it), at.subVectors(this.max, it),
								Qe.subVectors(e.a, it), Ke.subVectors(e.b,
									it), et.subVectors(e.c, it), tt
								.subVectors(Ke, Qe), nt.subVectors(et, Ke),
								rt.subVectors(Qe, et);
							var t = [0, -tt.z, tt.y, 0, -nt.z, nt.y, 0, -rt
								.z, rt.y, tt.z, 0, -tt.x, nt.z, 0, -nt
								.x, rt.z, 0, -rt.x, -tt.y, tt.x, 0, -nt
								.y, nt.x, 0, -rt.y, rt.x, 0
							];
							return !!lt(t, Qe, Ke, et, at) && !!lt(t = [1,
								0, 0, 0, 1, 0, 0, 0, 1
							], Qe, Ke, et, at) && (ot.crossVectors(tt,
								nt), lt(t = [ot.x, ot.y, ot.z], Qe,
								Ke, et, at))
						}
					}, {
						key: "clampPoint",
						value: function(e, t) {
							return void 0 === t && (console.warn(
								"THREE.Box3: .clampPoint() target is now required"
								), t = new je), t.copy(e).clamp(this
								.min, this.max)
						}
					}, {
						key: "distanceToPoint",
						value: function(e) {
							return Ze.copy(e).clamp(this.min, this.max).sub(
								e).length()
						}
					}, {
						key: "getBoundingSphere",
						value: function(e) {
							return void 0 === e && console.error(
									"THREE.Box3: .getBoundingSphere() target is now required"
									), this.getCenter(e.center), e.radius =
								.5 * this.getSize(Ze).length(), e
						}
					}, {
						key: "intersect",
						value: function(e) {
							return this.min.max(e.min), this.max.min(e.max),
								this.isEmpty() && this.makeEmpty(), this
						}
					}, {
						key: "union",
						value: function(e) {
							return this.min.min(e.min), this.max.max(e.max),
								this
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							return this.isEmpty() || ($e[0].set(this.min.x,
									this.min.y, this.min.z)
								.applyMatrix4(e), $e[1].set(this.min.x,
									this.min.y, this.max.z)
								.applyMatrix4(e), $e[2].set(this.min.x,
									this.max.y, this.min.z)
								.applyMatrix4(e), $e[3].set(this.min.x,
									this.max.y, this.max.z)
								.applyMatrix4(e), $e[4].set(this.max.x,
									this.min.y, this.min.z)
								.applyMatrix4(e), $e[5].set(this.max.x,
									this.min.y, this.max.z)
								.applyMatrix4(e), $e[6].set(this.max.x,
									this.max.y, this.min.z)
								.applyMatrix4(e), $e[7].set(this.max.x,
									this.max.y, this.max.z)
								.applyMatrix4(e), this.setFromPoints($e)
								), this
						}
					}, {
						key: "translate",
						value: function(e) {
							return this.min.add(e), this.max.add(e), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.min.equals(this.min) && e.max.equals(
								this.max)
						}
					}]), e
				}();
			Ye.prototype.isBox3 = !0;
			var $e = [new je, new je, new je, new je, new je, new je, new je, new je],
				Ze = new je,
				Je = new Ye,
				Qe = new je,
				Ke = new je,
				et = new je,
				tt = new je,
				nt = new je,
				rt = new je,
				it = new je,
				at = new je,
				ot = new je,
				st = new je;

			function lt(e, t, n, r, i) {
				for (var a = 0, o = e.length - 3; a <= o; a += 3) {
					st.fromArray(e, a);
					var s = i.x * Math.abs(st.x) + i.y * Math.abs(st.y) + i.z * Math.abs(st
							.z),
						l = t.dot(st),
						u = n.dot(st),
						c = r.dot(st);
					if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s) return !1
				}
				return !0
			}
			var ut = new Ye,
				ct = new je,
				ht = new je,
				dt = new je,
				ft = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : -1;
						(0, g.default)(this, e), this.center = t, this.radius = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.center.copy(e), this.radius = t,
								this
						}
					}, {
						key: "setFromPoints",
						value: function(e, t) {
							var n = this.center;
							void 0 !== t ? n.copy(t) : ut.setFromPoints(e)
								.getCenter(n);
							for (var r = 0, i = 0, a = e.length; i < a; i++)
								r = Math.max(r, n.distanceToSquared(e[i]));
							return this.radius = Math.sqrt(r), this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.center.copy(e.center), this.radius =
								e.radius, this
						}
					}, {
						key: "isEmpty",
						value: function() {
							return this.radius < 0
						}
					}, {
						key: "makeEmpty",
						value: function() {
							return this.center.set(0, 0, 0), this.radius = -
								1, this
						}
					}, {
						key: "containsPoint",
						value: function(e) {
							return e.distanceToSquared(this.center) <= this
								.radius * this.radius
						}
					}, {
						key: "distanceToPoint",
						value: function(e) {
							return e.distanceTo(this.center) - this.radius
						}
					}, {
						key: "intersectsSphere",
						value: function(e) {
							var t = this.radius + e.radius;
							return e.center.distanceToSquared(this
								.center) <= t * t
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return e.intersectsSphere(this)
						}
					}, {
						key: "intersectsPlane",
						value: function(e) {
							return Math.abs(e.distanceToPoint(this
								.center)) <= this.radius
						}
					}, {
						key: "clampPoint",
						value: function(e, t) {
							var n = this.center.distanceToSquared(e);
							return void 0 === t && (console.warn(
									"THREE.Sphere: .clampPoint() target is now required"
									), t = new je), t.copy(e), n > this
								.radius * this.radius && (t.sub(this.center)
									.normalize(), t.multiplyScalar(this
										.radius).add(this.center)), t
						}
					}, {
						key: "getBoundingBox",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Sphere: .getBoundingBox() target is now required"
								), e = new Ye), this.isEmpty() ? (e
								.makeEmpty(), e) : (e.set(this.center,
								this.center), e.expandByScalar(this
								.radius), e)
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							return this.center.applyMatrix4(e), this
								.radius = this.radius * e
								.getMaxScaleOnAxis(), this
						}
					}, {
						key: "translate",
						value: function(e) {
							return this.center.add(e), this
						}
					}, {
						key: "expandByPoint",
						value: function(e) {
							dt.subVectors(e, this.center);
							var t = dt.lengthSq();
							if (t > this.radius * this.radius) {
								var n = Math.sqrt(t),
									r = .5 * (n - this.radius);
								this.center.add(dt.multiplyScalar(r / n)),
									this.radius += r
							}
							return this
						}
					}, {
						key: "union",
						value: function(e) {
							return ht.subVectors(e.center, this.center)
								.normalize().multiplyScalar(e.radius), this
								.expandByPoint(ct.copy(e.center).add(ht)),
								this.expandByPoint(ct.copy(e.center).sub(
									ht)), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.center.equals(this.center) && e
								.radius === this.radius
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}(),
				pt = new je,
				vt = new je,
				mt = new je,
				gt = new je,
				yt = new je,
				xt = new je,
				_t = new je,
				bt = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je(0, 0, -1);
						(0, g.default)(this, e), this.origin = t, this.direction = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.origin.copy(e), this.direction.copy(
								t), this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.origin.copy(e.origin), this
								.direction.copy(e.direction), this
						}
					}, {
						key: "at",
						value: function(e, t) {
							return void 0 === t && (console.warn(
									"THREE.Ray: .at() target is now required"
									), t = new je), t.copy(this.direction)
								.multiplyScalar(e).add(this.origin)
						}
					}, {
						key: "lookAt",
						value: function(e) {
							return this.direction.copy(e).sub(this.origin)
								.normalize(), this
						}
					}, {
						key: "recast",
						value: function(e) {
							return this.origin.copy(this.at(e, pt)), this
						}
					}, {
						key: "closestPointToPoint",
						value: function(e, t) {
							void 0 === t && (console.warn(
								"THREE.Ray: .closestPointToPoint() target is now required"
								), t = new je), t.subVectors(e, this
								.origin);
							var n = t.dot(this.direction);
							return n < 0 ? t.copy(this.origin) : t.copy(this
								.direction).multiplyScalar(n).add(this
								.origin)
						}
					}, {
						key: "distanceToPoint",
						value: function(e) {
							return Math.sqrt(this.distanceSqToPoint(e))
						}
					}, {
						key: "distanceSqToPoint",
						value: function(e) {
							var t = pt.subVectors(e, this.origin).dot(this
								.direction);
							return t < 0 ? this.origin.distanceToSquared(
								e) : (pt.copy(this.direction)
									.multiplyScalar(t).add(this.origin), pt
									.distanceToSquared(e))
						}
					}, {
						key: "distanceSqToSegment",
						value: function(e, t, n, r) {
							vt.copy(e).add(t).multiplyScalar(.5), mt.copy(t)
								.sub(e).normalize(), gt.copy(this.origin)
								.sub(vt);
							var i, a, o, s, l = .5 * e.distanceTo(t),
								u = -this.direction.dot(mt),
								c = gt.dot(this.direction),
								h = -gt.dot(mt),
								d = gt.lengthSq(),
								f = Math.abs(1 - u * u);
							if (f > 0)
								if (a = u * c - h, s = l * f, (i = u * h -
										c) >= 0)
									if (a >= -s)
										if (a <= s) {
											var p = 1 / f;
											o = (i *= p) * (i + u * (a *=
												p) + 2 * c) + a * (u *
												i + a + 2 * h) + d
										} else a = l, o = -(i = Math.max(0,
											-(u * a + c))) * i + a * (
											a + 2 * h) + d;
							else a = -l, o = -(i = Math.max(0, -(u * a +
								c))) * i + a * (a + 2 * h) + d;
							else a <= -s ? o = -(i = Math.max(0, -(-u * l +
									c))) * i + (a = i > 0 ? -l : Math.min(
									Math.max(-l, -h), l)) * (a + 2 * h) +
								d : a <= s ? (i = 0, o = (a = Math.min(Math
									.max(-l, -h), l)) * (a + 2 * h) + d) :
								o = -(i = Math.max(0, -(u * l + c))) * i + (
									a = i > 0 ? l : Math.min(Math.max(-l, -
										h), l)) * (a + 2 * h) + d;
							else a = u > 0 ? -l : l, o = -(i = Math.max(0, -
								(u * a + c))) * i + a * (a + 2 * h) + d;
							return n && n.copy(this.direction)
								.multiplyScalar(i).add(this.origin), r && r
								.copy(mt).multiplyScalar(a).add(vt), o
						}
					}, {
						key: "intersectSphere",
						value: function(e, t) {
							pt.subVectors(e.center, this.origin);
							var n = pt.dot(this.direction),
								r = pt.dot(pt) - n * n,
								i = e.radius * e.radius;
							if (r > i) return null;
							var a = Math.sqrt(i - r),
								o = n - a,
								s = n + a;
							return o < 0 && s < 0 ? null : o < 0 ? this.at(
								s, t) : this.at(o, t)
						}
					}, {
						key: "intersectsSphere",
						value: function(e) {
							return this.distanceSqToPoint(e.center) <= e
								.radius * e.radius
						}
					}, {
						key: "distanceToPlane",
						value: function(e) {
							var t = e.normal.dot(this.direction);
							if (0 === t) return 0 === e.distanceToPoint(this
								.origin) ? 0 : null;
							var n = -(this.origin.dot(e.normal) + e
								.constant) / t;
							return n >= 0 ? n : null
						}
					}, {
						key: "intersectPlane",
						value: function(e, t) {
							var n = this.distanceToPlane(e);
							return null === n ? null : this.at(n, t)
						}
					}, {
						key: "intersectsPlane",
						value: function(e) {
							var t = e.distanceToPoint(this.origin);
							return 0 === t || e.normal.dot(this.direction) *
								t < 0
						}
					}, {
						key: "intersectBox",
						value: function(e, t) {
							var n, r, i, a, o, s, l = 1 / this.direction.x,
								u = 1 / this.direction.y,
								c = 1 / this.direction.z,
								h = this.origin;
							return l >= 0 ? (n = (e.min.x - h.x) * l, r = (e
									.max.x - h.x) * l) : (n = (e.max.x - h
									.x) * l, r = (e.min.x - h.x) * l), u >=
								0 ? (i = (e.min.y - h.y) * u, a = (e.max.y -
									h.y) * u) : (i = (e.max.y - h.y) * u,
									a = (e.min.y - h.y) * u), n > a || i >
								r ? null : ((i > n || n != n) && (n = i), (
										a < r || r != r) && (r = a), c >=
									0 ? (o = (e.min.z - h.z) * c, s = (e.max
										.z - h.z) * c) : (o = (e.max.z - h
											.z) * c, s = (e.min.z - h.z) *
										c), n > s || o > r ? null : ((o >
											n || n != n) && (n = o), (s <
											r || r != r) && (r = s), r < 0 ?
										null : this.at(n >= 0 ? n : r, t)))
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return null !== this.intersectBox(e, pt)
						}
					}, {
						key: "intersectTriangle",
						value: function(e, t, n, r, i) {
							yt.subVectors(t, e), xt.subVectors(n, e), _t
								.crossVectors(yt, xt);
							var a, o = this.direction.dot(_t);
							if (o > 0) {
								if (r) return null;
								a = 1
							} else {
								if (!(o < 0)) return null;
								a = -1, o = -o
							}
							gt.subVectors(this.origin, e);
							var s = a * this.direction.dot(xt.crossVectors(
								gt, xt));
							if (s < 0) return null;
							var l = a * this.direction.dot(yt.cross(gt));
							if (l < 0) return null;
							if (s + l > o) return null;
							var u = -a * gt.dot(_t);
							return u < 0 ? null : this.at(u / o, i)
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							return this.origin.applyMatrix4(e), this
								.direction.transformDirection(e), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.origin.equals(this.origin) && e
								.direction.equals(this.direction)
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}(),
				wt = function() {
					function e() {
						(0, g.default)(this, e), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0,
							0, 1, 0, 0, 0, 0, 1
						], arguments.length > 0 && console.error(
							"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
							)
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t, n, r, i, a, o, s, l, u, c, h, d,
							f, p, v) {
							var m = this.elements;
							return m[0] = e, m[4] = t, m[8] = n, m[12] = r,
								m[1] = i, m[5] = a, m[9] = o, m[13] = s, m[
									2] = l, m[6] = u, m[10] = c, m[14] = h,
								m[3] = d, m[7] = f, m[11] = p, m[15] = v,
								this
						}
					}, {
						key: "identity",
						value: function() {
							return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
								0, 0, 0, 0, 1), this
						}
					}, {
						key: "clone",
						value: function() {
							return (new e).fromArray(this.elements)
						}
					}, {
						key: "copy",
						value: function(e) {
							var t = this.elements,
								n = e.elements;
							return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[
									3] = n[3], t[4] = n[4], t[5] = n[5], t[
									6] = n[6], t[7] = n[7], t[8] = n[8], t[
									9] = n[9], t[10] = n[10], t[11] = n[11],
								t[12] = n[12], t[13] = n[13], t[14] = n[14],
								t[15] = n[15], this
						}
					}, {
						key: "copyPosition",
						value: function(e) {
							var t = this.elements,
								n = e.elements;
							return t[12] = n[12], t[13] = n[13], t[14] = n[
								14], this
						}
					}, {
						key: "setFromMatrix3",
						value: function(e) {
							var t = e.elements;
							return this.set(t[0], t[3], t[6], 0, t[1], t[4],
								t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1
								), this
						}
					}, {
						key: "extractBasis",
						value: function(e, t, n) {
							return e.setFromMatrixColumn(this, 0), t
								.setFromMatrixColumn(this, 1), n
								.setFromMatrixColumn(this, 2), this
						}
					}, {
						key: "makeBasis",
						value: function(e, t, n) {
							return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y,
								0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
						}
					}, {
						key: "extractRotation",
						value: function(e) {
							var t = this.elements,
								n = e.elements,
								r = 1 / Mt.setFromMatrixColumn(e, 0)
								.length(),
								i = 1 / Mt.setFromMatrixColumn(e, 1)
								.length(),
								a = 1 / Mt.setFromMatrixColumn(e, 2)
								.length();
							return t[0] = n[0] * r, t[1] = n[1] * r, t[2] =
								n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] =
								n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] =
								n[8] * a, t[9] = n[9] * a, t[10] = n[10] *
								a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] =
								0, t[15] = 1, this
						}
					}, {
						key: "makeRotationFromEuler",
						value: function(e) {
							e && e.isEuler || console.error(
								"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
								);
							var t = this.elements,
								n = e.x,
								r = e.y,
								i = e.z,
								a = Math.cos(n),
								o = Math.sin(n),
								s = Math.cos(r),
								l = Math.sin(r),
								u = Math.cos(i),
								c = Math.sin(i);
							if ("XYZ" === e.order) {
								var h = a * u,
									d = a * c,
									f = o * u,
									p = o * c;
								t[0] = s * u, t[4] = -s * c, t[8] = l, t[
									1] = d + f * l, t[5] = h - p * l, t[
									9] = -o * s, t[2] = p - h * l, t[6] =
									f + d * l, t[10] = a * s
							} else if ("YXZ" === e.order) {
								var v = s * u,
									m = s * c,
									g = l * u,
									y = l * c;
								t[0] = v + y * o, t[4] = g * o - m, t[8] =
									a * l, t[1] = a * c, t[5] = a * u, t[
									9] = -o, t[2] = m * o - g, t[6] = y +
									v * o, t[10] = a * s
							} else if ("ZXY" === e.order) {
								var x = s * u,
									_ = s * c,
									b = l * u,
									w = l * c;
								t[0] = x - w * o, t[4] = -a * c, t[8] = b +
									_ * o, t[1] = _ + b * o, t[5] = a * u,
									t[9] = w - x * o, t[2] = -a * l, t[6] =
									o, t[10] = a * s
							} else if ("ZYX" === e.order) {
								var M = a * u,
									S = a * c,
									T = o * u,
									E = o * c;
								t[0] = s * u, t[4] = T * l - S, t[8] = M *
									l + E, t[1] = s * c, t[5] = E * l + M,
									t[9] = S * l - T, t[2] = -l, t[6] = o *
									s, t[10] = a * s
							} else if ("YZX" === e.order) {
								var A = a * s,
									L = a * l,
									k = o * s,
									R = o * l;
								t[0] = s * u, t[4] = R - A * c, t[8] = k *
									c + L, t[1] = c, t[5] = a * u, t[9] = -
									o * u, t[2] = -l * u, t[6] = L * c + k,
									t[10] = A - R * c
							} else if ("XZY" === e.order) {
								var C = a * s,
									P = a * l,
									I = o * s,
									D = o * l;
								t[0] = s * u, t[4] = -c, t[8] = l * u, t[
									1] = C * c + D, t[5] = a * u, t[9] = P *
									c - I, t[2] = I * c - P, t[6] = o * u,
									t[10] = D * c + C
							}
							return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0,
								t[13] = 0, t[14] = 0, t[15] = 1, this
						}
					}, {
						key: "makeRotationFromQuaternion",
						value: function(e) {
							return this.compose(Tt, e, Et)
						}
					}, {
						key: "lookAt",
						value: function(e, t, n) {
							var r = this.elements;
							return kt.subVectors(e, t), 0 === kt
							.lengthSq() && (kt.z = 1), kt.normalize(), At
								.crossVectors(n, kt), 0 === At.lengthSq() &&
								(1 === Math.abs(n.z) ? kt.x += 1e-4 : kt
									.z += 1e-4, kt.normalize(), At
									.crossVectors(n, kt)), At.normalize(),
								Lt.crossVectors(kt, At), r[0] = At.x, r[4] =
								Lt.x, r[8] = kt.x, r[1] = At.y, r[5] = Lt.y,
								r[9] = kt.y, r[2] = At.z, r[6] = Lt.z, r[
								10] = kt.z, this
						}
					}, {
						key: "multiply",
						value: function(e, t) {
							return void 0 !== t ? (console.warn(
									"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
									), this.multiplyMatrices(e, t)) : this
								.multiplyMatrices(this, e)
						}
					}, {
						key: "premultiply",
						value: function(e) {
							return this.multiplyMatrices(e, this)
						}
					}, {
						key: "multiplyMatrices",
						value: function(e, t) {
							var n = e.elements,
								r = t.elements,
								i = this.elements,
								a = n[0],
								o = n[4],
								s = n[8],
								l = n[12],
								u = n[1],
								c = n[5],
								h = n[9],
								d = n[13],
								f = n[2],
								p = n[6],
								v = n[10],
								m = n[14],
								g = n[3],
								y = n[7],
								x = n[11],
								_ = n[15],
								b = r[0],
								w = r[4],
								M = r[8],
								S = r[12],
								T = r[1],
								E = r[5],
								A = r[9],
								L = r[13],
								k = r[2],
								R = r[6],
								C = r[10],
								P = r[14],
								I = r[3],
								D = r[7],
								N = r[11],
								O = r[15];
							return i[0] = a * b + o * T + s * k + l * I, i[
									4] = a * w + o * E + s * R + l * D, i[
								8] = a * M + o * A + s * C + l * N, i[12] =
								a * S + o * L + s * P + l * O, i[1] = u *
								b + c * T + h * k + d * I, i[5] = u * w +
								c * E + h * R + d * D, i[9] = u * M + c *
								A + h * C + d * N, i[13] = u * S + c * L +
								h * P + d * O, i[2] = f * b + p * T + v *
								k + m * I, i[6] = f * w + p * E + v * R +
								m * D, i[10] = f * M + p * A + v * C + m *
								N, i[14] = f * S + p * L + v * P + m * O, i[
									3] = g * b + y * T + x * k + _ * I, i[
								7] = g * w + y * E + x * R + _ * D, i[11] =
								g * M + y * A + x * C + _ * N, i[15] = g *
								S + y * L + x * P + _ * O, this
						}
					}, {
						key: "multiplyScalar",
						value: function(e) {
							var t = this.elements;
							return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *=
								e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *=
								e, t[2] *= e, t[6] *= e, t[10] *= e, t[
								14] *= e, t[3] *= e, t[7] *= e, t[11] *= e,
								t[15] *= e, this
						}
					}, {
						key: "determinant",
						value: function() {
							var e = this.elements,
								t = e[0],
								n = e[4],
								r = e[8],
								i = e[12],
								a = e[1],
								o = e[5],
								s = e[9],
								l = e[13],
								u = e[2],
								c = e[6],
								h = e[10],
								d = e[14];
							return e[3] * (+i * s * c - r * l * c - i * o *
									h + n * l * h + r * o * d - n * s * d) +
								e[7] * (+t * s * d - t * l * h + i * a * h -
									r * a * d + r * l * u - i * s * u) + e[
									11] * (+t * l * c - t * o * d - i * a *
									c + n * a * d + i * o * u - n * l * u) +
								e[15] * (-r * o * u - t * s * c + t * o *
									h + r * a * c - n * a * h + n * s * u)
						}
					}, {
						key: "transpose",
						value: function() {
							var e, t = this.elements;
							return e = t[1], t[1] = t[4], t[4] = e, e = t[
								2], t[2] = t[8], t[8] = e, e = t[6], t[6] =
								t[9], t[9] = e, e = t[3], t[3] = t[12], t[
									12] = e, e = t[7], t[7] = t[13], t[13] =
								e, e = t[11], t[11] = t[14], t[14] = e, this
						}
					}, {
						key: "setPosition",
						value: function(e, t, n) {
							var r = this.elements;
							return e.isVector3 ? (r[12] = e.x, r[13] = e.y,
								r[14] = e.z) : (r[12] = e, r[13] = t, r[
								14] = n), this
						}
					}, {
						key: "invert",
						value: function() {
							var e = this.elements,
								t = e[0],
								n = e[1],
								r = e[2],
								i = e[3],
								a = e[4],
								o = e[5],
								s = e[6],
								l = e[7],
								u = e[8],
								c = e[9],
								h = e[10],
								d = e[11],
								f = e[12],
								p = e[13],
								v = e[14],
								m = e[15],
								g = c * v * l - p * h * l + p * s * d - o *
								v * d - c * s * m + o * h * m,
								y = f * h * l - u * v * l - f * s * d + a *
								v * d + u * s * m - a * h * m,
								x = u * p * l - f * c * l + f * o * d - a *
								p * d - u * o * m + a * c * m,
								_ = f * c * s - u * p * s - f * o * h + a *
								p * h + u * o * v - a * c * v,
								b = t * g + n * y + r * x + i * _;
							if (0 === b) return this.set(0, 0, 0, 0, 0, 0,
								0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
							var w = 1 / b;
							return e[0] = g * w, e[1] = (p * h * i - c * v *
									i - p * r * d + n * v * d + c * r * m -
									n * h * m) * w, e[2] = (o * v * i - p *
									s * i + p * r * l - n * v * l - o * r *
									m + n * s * m) * w, e[3] = (c * s * i -
									o * h * i - c * r * l + n * h * l + o *
									r * d - n * s * d) * w, e[4] = y * w, e[
									5] = (u * v * i - f * h * i + f * r *
									d - t * v * d - u * r * m + t * h * m) *
								w, e[6] = (f * s * i - a * v * i - f * r *
									l + t * v * l + a * r * m - t * s * m) *
								w, e[7] = (a * h * i - u * s * i + u * r *
									l - t * h * l - a * r * d + t * s * d) *
								w, e[8] = x * w, e[9] = (f * c * i - u * p *
									i - f * n * d + t * p * d + u * n * m -
									t * c * m) * w, e[10] = (a * p * i - f *
									o * i + f * n * l - t * p * l - a * n *
									m + t * o * m) * w, e[11] = (u * o * i -
									a * c * i - u * n * l + t * c * l + a *
									n * d - t * o * d) * w, e[12] = _ * w,
								e[13] = (u * p * r - f * c * r + f * n * h -
									t * p * h - u * n * v + t * c * v) * w,
								e[14] = (f * o * r - a * p * r - f * n * s +
									t * p * s + a * n * v - t * o * v) * w,
								e[15] = (a * c * r - u * o * r + u * n * s -
									t * c * s - a * n * h + t * o * h) * w,
								this
						}
					}, {
						key: "scale",
						value: function(e) {
							var t = this.elements,
								n = e.x,
								r = e.y,
								i = e.z;
							return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *=
								n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *=
								r, t[10] *= i, t[3] *= n, t[7] *= r, t[
								11] *= i, this
						}
					}, {
						key: "getMaxScaleOnAxis",
						value: function() {
							var e = this.elements,
								t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
								n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
								r = e[8] * e[8] + e[9] * e[9] + e[10] * e[
									10];
							return Math.sqrt(Math.max(t, n, r))
						}
					}, {
						key: "makeTranslation",
						value: function(e, t, n) {
							return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1,
								n, 0, 0, 0, 1), this
						}
					}, {
						key: "makeRotationX",
						value: function(e) {
							var t = Math.cos(e),
								n = Math.sin(e);
							return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n,
								t, 0, 0, 0, 0, 1), this
						}
					}, {
						key: "makeRotationY",
						value: function(e) {
							var t = Math.cos(e),
								n = Math.sin(e);
							return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0,
								t, 0, 0, 0, 0, 1), this
						}
					}, {
						key: "makeRotationZ",
						value: function(e) {
							var t = Math.cos(e),
								n = Math.sin(e);
							return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0,
								1, 0, 0, 0, 0, 1), this
						}
					}, {
						key: "makeRotationAxis",
						value: function(e, t) {
							var n = Math.cos(t),
								r = Math.sin(t),
								i = 1 - n,
								a = e.x,
								o = e.y,
								s = e.z,
								l = i * a,
								u = i * o;
							return this.set(l * a + n, l * o - r * s, l *
									s + r * o, 0, l * o + r * s, u * o + n,
									u * s - r * a, 0, l * s - r * o, u * s +
									r * a, i * s * s + n, 0, 0, 0, 0, 1),
								this
						}
					}, {
						key: "makeScale",
						value: function(e, t, n) {
							return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n,
								0, 0, 0, 0, 1), this
						}
					}, {
						key: "makeShear",
						value: function(e, t, n, r, i, a) {
							return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1,
								0, 0, 0, 0, 1), this
						}
					}, {
						key: "compose",
						value: function(e, t, n) {
							var r = this.elements,
								i = t._x,
								a = t._y,
								o = t._z,
								s = t._w,
								l = i + i,
								u = a + a,
								c = o + o,
								h = i * l,
								d = i * u,
								f = i * c,
								p = a * u,
								v = a * c,
								m = o * c,
								g = s * l,
								y = s * u,
								x = s * c,
								_ = n.x,
								b = n.y,
								w = n.z;
							return r[0] = (1 - (p + m)) * _, r[1] = (d +
								x) * _, r[2] = (f - y) * _, r[3] = 0, r[4] =
								(d - x) * b, r[5] = (1 - (h + m)) * b, r[
								6] = (v + g) * b, r[7] = 0, r[8] = (f + y) *
								w, r[9] = (v - g) * w, r[10] = (1 - (h +
								p)) * w, r[11] = 0, r[12] = e.x, r[13] = e
								.y, r[14] = e.z, r[15] = 1, this
						}
					}, {
						key: "decompose",
						value: function(e, t, n) {
							var r = this.elements,
								i = Mt.set(r[0], r[1], r[2]).length(),
								a = Mt.set(r[4], r[5], r[6]).length(),
								o = Mt.set(r[8], r[9], r[10]).length();
							this.determinant() < 0 && (i = -i), e.x = r[12],
								e.y = r[13], e.z = r[14], St.copy(this);
							var s = 1 / i,
								l = 1 / a,
								u = 1 / o;
							return St.elements[0] *= s, St.elements[1] *= s,
								St.elements[2] *= s, St.elements[4] *= l, St
								.elements[5] *= l, St.elements[6] *= l, St
								.elements[8] *= u, St.elements[9] *= u, St
								.elements[10] *= u, t.setFromRotationMatrix(
									St), n.x = i, n.y = a, n.z = o, this
						}
					}, {
						key: "makePerspective",
						value: function(e, t, n, r, i, a) {
							void 0 === a && console.warn(
								"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
								);
							var o = this.elements,
								s = 2 * i / (t - e),
								l = 2 * i / (n - r),
								u = (t + e) / (t - e),
								c = (n + r) / (n - r),
								h = -(a + i) / (a - i),
								d = -2 * a * i / (a - i);
							return o[0] = s, o[4] = 0, o[8] = u, o[12] = 0,
								o[1] = 0, o[5] = l, o[9] = c, o[13] = 0, o[
									2] = 0, o[6] = 0, o[10] = h, o[14] = d,
								o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0,
								this
						}
					}, {
						key: "makeOrthographic",
						value: function(e, t, n, r, i, a) {
							var o = this.elements,
								s = 1 / (t - e),
								l = 1 / (n - r),
								u = 1 / (a - i),
								c = (t + e) * s,
								h = (n + r) * l,
								d = (a + i) * u;
							return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[
								12] = -c, o[1] = 0, o[5] = 2 * l, o[9] = 0,
								o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 *
								u, o[14] = -d, o[3] = 0, o[7] = 0, o[11] =
								0, o[15] = 1, this
						}
					}, {
						key: "equals",
						value: function(e) {
							for (var t = this.elements, n = e.elements, r =
									0; r < 16; r++)
								if (t[r] !== n[r]) return !1;
							return !0
						}
					}, {
						key: "fromArray",
						value: function(e) {
							for (var t = arguments.length > 1 && void 0 !==
									arguments[1] ? arguments[1] : 0, n =
									0; n < 16; n++) this.elements[n] = e[n +
								t];
							return this
						}
					}, {
						key: "toArray",
						value: function() {
							var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : [],
								t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0,
								n = this.elements;
							return e[t] = n[0], e[t + 1] = n[1], e[t + 2] =
								n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[
									t + 5] = n[5], e[t + 6] = n[6], e[t +
								7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9],
								e[t + 10] = n[10], e[t + 11] = n[11], e[t +
									12] = n[12], e[t + 13] = n[13], e[t +
									14] = n[14], e[t + 15] = n[15], e
						}
					}]), e
				}();
			wt.prototype.isMatrix4 = !0;
			var Mt = new je,
				St = new wt,
				Tt = new je(0, 0, 0),
				Et = new je(1, 1, 1),
				At = new je,
				Lt = new je,
				kt = new je,
				Rt = new wt,
				Ct = new We,
				Pt = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : 0,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0,
							i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : e.DefaultOrder;
						(0, g.default)(this, e), this._x = t, this._y = n, this._z = r, this
							._order = i
					}
					return (0, y.default)(e, [{
						key: "x",
						get: function() {
							return this._x
						},
						set: function(e) {
							this._x = e, this._onChangeCallback()
						}
					}, {
						key: "y",
						get: function() {
							return this._y
						},
						set: function(e) {
							this._y = e, this._onChangeCallback()
						}
					}, {
						key: "z",
						get: function() {
							return this._z
						},
						set: function(e) {
							this._z = e, this._onChangeCallback()
						}
					}, {
						key: "order",
						get: function() {
							return this._order
						},
						set: function(e) {
							this._order = e, this._onChangeCallback()
						}
					}, {
						key: "set",
						value: function(e, t, n, r) {
							return this._x = e, this._y = t, this._z = n,
								this._order = r || this._order, this
								._onChangeCallback(), this
						}
					}, {
						key: "clone",
						value: function() {
							return new this.constructor(this._x, this._y,
								this._z, this._order)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this._x = e._x, this._y = e._y, this._z =
								e._z, this._order = e._order, this
								._onChangeCallback(), this
						}
					}, {
						key: "setFromRotationMatrix",
						value: function(e, t, n) {
							var r = e.elements,
								i = r[0],
								a = r[4],
								o = r[8],
								s = r[1],
								l = r[5],
								u = r[9],
								c = r[2],
								h = r[6],
								d = r[10];
							switch (t = t || this._order) {
								case "XYZ":
									this._y = Math.asin(Ee(o, -1, 1)), Math
										.abs(o) < .9999999 ? (this._x = Math
											.atan2(-u, d), this._z = Math
											.atan2(-a, i)) : (this._x = Math
											.atan2(h, l), this._z = 0);
									break;
								case "YXZ":
									this._x = Math.asin(-Ee(u, -1, 1)), Math
										.abs(u) < .9999999 ? (this._y = Math
											.atan2(o, d), this._z = Math
											.atan2(s, l)) : (this._y = Math
											.atan2(-c, i), this._z = 0);
									break;
								case "ZXY":
									this._x = Math.asin(Ee(h, -1, 1)), Math
										.abs(h) < .9999999 ? (this._y = Math
											.atan2(-c, d), this._z = Math
											.atan2(-a, l)) : (this._y = 0,
											this._z = Math.atan2(s, i));
									break;
								case "ZYX":
									this._y = Math.asin(-Ee(c, -1, 1)), Math
										.abs(c) < .9999999 ? (this._x = Math
											.atan2(h, d), this._z = Math
											.atan2(s, i)) : (this._x = 0,
											this._z = Math.atan2(-a, l));
									break;
								case "YZX":
									this._z = Math.asin(Ee(s, -1, 1)), Math
										.abs(s) < .9999999 ? (this._x = Math
											.atan2(-u, l), this._y = Math
											.atan2(-c, i)) : (this._x = 0,
											this._y = Math.atan2(o, d));
									break;
								case "XZY":
									this._z = Math.asin(-Ee(a, -1, 1)), Math
										.abs(a) < .9999999 ? (this._x = Math
											.atan2(h, l), this._y = Math
											.atan2(o, i)) : (this._x = Math
											.atan2(-u, d), this._y = 0);
									break;
								default:
									console.warn(
										"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
										t)
							}
							return this._order = t, !1 !== n && this
								._onChangeCallback(), this
						}
					}, {
						key: "setFromQuaternion",
						value: function(e, t, n) {
							return Rt.makeRotationFromQuaternion(e), this
								.setFromRotationMatrix(Rt, t, n)
						}
					}, {
						key: "setFromVector3",
						value: function(e, t) {
							return this.set(e.x, e.y, e.z, t || this._order)
						}
					}, {
						key: "reorder",
						value: function(e) {
							return Ct.setFromEuler(this), this
								.setFromQuaternion(Ct, e)
						}
					}, {
						key: "equals",
						value: function(e) {
							return e._x === this._x && e._y === this._y && e
								._z === this._z && e._order === this._order
						}
					}, {
						key: "fromArray",
						value: function(e) {
							return this._x = e[0], this._y = e[1], this._z =
								e[2], void 0 !== e[3] && (this._order = e[
									3]), this._onChangeCallback(), this
						}
					}, {
						key: "toArray",
						value: function() {
							var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : [],
								t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0;
							return e[t] = this._x, e[t + 1] = this._y, e[t +
								2] = this._z, e[t + 3] = this._order, e
						}
					}, {
						key: "toVector3",
						value: function(e) {
							return e ? e.set(this._x, this._y, this._z) :
								new je(this._x, this._y, this._z)
						}
					}, {
						key: "_onChange",
						value: function(e) {
							return this._onChangeCallback = e, this
						}
					}, {
						key: "_onChangeCallback",
						value: function() {}
					}]), e
				}();
			Pt.prototype.isEuler = !0, Pt.DefaultOrder = "XYZ", Pt.RotationOrders = ["XYZ",
				"YZX", "ZXY", "XZY", "YXZ", "ZYX"
			];
			var It = function() {
					function e() {
						(0, g.default)(this, e), this.mask = 1
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e) {
							this.mask = 1 << e | 0
						}
					}, {
						key: "enable",
						value: function(e) {
							this.mask |= 1 << e | 0
						}
					}, {
						key: "enableAll",
						value: function() {
							this.mask = -1
						}
					}, {
						key: "toggle",
						value: function(e) {
							this.mask ^= 1 << e | 0
						}
					}, {
						key: "disable",
						value: function(e) {
							this.mask &= ~(1 << e | 0)
						}
					}, {
						key: "disableAll",
						value: function() {
							this.mask = 0
						}
					}, {
						key: "test",
						value: function(e) {
							return 0 != (this.mask & e.mask)
						}
					}]), e
				}(),
				Dt = 0,
				Nt = new je,
				Ot = new We,
				Bt = new wt,
				zt = new je,
				Ft = new je,
				Ht = new je,
				Ut = new We,
				Gt = new je(1, 0, 0),
				Vt = new je(0, 1, 0),
				Wt = new je(0, 0, 1),
				jt = {
					type: "added"
				},
				qt = {
					type: "removed"
				},
				Xt = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						(0, g.default)(this, n), e = t.call(this), Object.defineProperty((0,
								f.default)(e), "id", {
								value: Dt++
							}), e.uuid = Te(), e.name = "", e.type = "Object3D", e.parent =
							null, e.children = [], e.up = n.DefaultUp.clone();
						var r = new je,
							i = new Pt,
							a = new We,
							o = new je(1, 1, 1);
						return i._onChange((function() {
								a.setFromEuler(i, !1)
							})), a._onChange((function() {
								i.setFromQuaternion(a, void 0, !1)
							})), Object.defineProperties((0, f.default)(e), {
								position: {
									configurable: !0,
									enumerable: !0,
									value: r
								},
								rotation: {
									configurable: !0,
									enumerable: !0,
									value: i
								},
								quaternion: {
									configurable: !0,
									enumerable: !0,
									value: a
								},
								scale: {
									configurable: !0,
									enumerable: !0,
									value: o
								},
								modelViewMatrix: {
									value: new wt
								},
								normalMatrix: {
									value: new Ne
								}
							}), e.matrix = new wt, e.matrixWorld = new wt, e
							.matrixAutoUpdate = n.DefaultMatrixAutoUpdate, e
							.matrixWorldNeedsUpdate = !1, e.layers = new It, e.visible = !0,
							e.castShadow = !1, e.receiveShadow = !1, e.frustumCulled = !0, e
							.renderOrder = 0, e.animations = [], e.userData = {}, e
					}
					return (0, y.default)(n, [{
						key: "onBeforeRender",
						value: function() {}
					}, {
						key: "onAfterRender",
						value: function() {}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							this.matrixAutoUpdate && this.updateMatrix(),
								this.matrix.premultiply(e), this.matrix
								.decompose(this.position, this.quaternion,
									this.scale)
						}
					}, {
						key: "applyQuaternion",
						value: function(e) {
							return this.quaternion.premultiply(e), this
						}
					}, {
						key: "setRotationFromAxisAngle",
						value: function(e, t) {
							this.quaternion.setFromAxisAngle(e, t)
						}
					}, {
						key: "setRotationFromEuler",
						value: function(e) {
							this.quaternion.setFromEuler(e, !0)
						}
					}, {
						key: "setRotationFromMatrix",
						value: function(e) {
							this.quaternion.setFromRotationMatrix(e)
						}
					}, {
						key: "setRotationFromQuaternion",
						value: function(e) {
							this.quaternion.copy(e)
						}
					}, {
						key: "rotateOnAxis",
						value: function(e, t) {
							return Ot.setFromAxisAngle(e, t), this
								.quaternion.multiply(Ot), this
						}
					}, {
						key: "rotateOnWorldAxis",
						value: function(e, t) {
							return Ot.setFromAxisAngle(e, t), this
								.quaternion.premultiply(Ot), this
						}
					}, {
						key: "rotateX",
						value: function(e) {
							return this.rotateOnAxis(Gt, e)
						}
					}, {
						key: "rotateY",
						value: function(e) {
							return this.rotateOnAxis(Vt, e)
						}
					}, {
						key: "rotateZ",
						value: function(e) {
							return this.rotateOnAxis(Wt, e)
						}
					}, {
						key: "translateOnAxis",
						value: function(e, t) {
							return Nt.copy(e).applyQuaternion(this
								.quaternion), this.position.add(Nt
								.multiplyScalar(t)), this
						}
					}, {
						key: "translateX",
						value: function(e) {
							return this.translateOnAxis(Gt, e)
						}
					}, {
						key: "translateY",
						value: function(e) {
							return this.translateOnAxis(Vt, e)
						}
					}, {
						key: "translateZ",
						value: function(e) {
							return this.translateOnAxis(Wt, e)
						}
					}, {
						key: "localToWorld",
						value: function(e) {
							return e.applyMatrix4(this.matrixWorld)
						}
					}, {
						key: "worldToLocal",
						value: function(e) {
							return e.applyMatrix4(Bt.copy(this.matrixWorld)
								.invert())
						}
					}, {
						key: "lookAt",
						value: function(e, t, n) {
							e.isVector3 ? zt.copy(e) : zt.set(e, t, n);
							var r = this.parent;
							this.updateWorldMatrix(!0, !1), Ft
								.setFromMatrixPosition(this.matrixWorld),
								this.isCamera || this.isLight ? Bt.lookAt(
									Ft, zt, this.up) : Bt.lookAt(zt, Ft,
									this.up), this.quaternion
								.setFromRotationMatrix(Bt), r && (Bt
									.extractRotation(r.matrixWorld), Ot
									.setFromRotationMatrix(Bt), this
									.quaternion.premultiply(Ot.invert()))
						}
					}, {
						key: "add",
						value: function(e) {
							if (arguments.length > 1) {
								for (var t = 0; t < arguments.length; t++)
									this.add(arguments[t]);
								return this
							}
							return e === this ? (console.error(
								"THREE.Object3D.add: object can't be added as a child of itself.",
								e), this) : (e && e.isObject3D ? (
								null !== e.parent && e.parent
								.remove(e), e.parent = this, this
								.children.push(e), e.dispatchEvent(
									jt)) : console.error(
								"THREE.Object3D.add: object not an instance of THREE.Object3D.",
								e), this)
						}
					}, {
						key: "remove",
						value: function(e) {
							if (arguments.length > 1) {
								for (var t = 0; t < arguments.length; t++)
									this.remove(arguments[t]);
								return this
							}
							var n = this.children.indexOf(e);
							return -1 !== n && (e.parent = null, this
								.children.splice(n, 1), e.dispatchEvent(
									qt)), this
						}
					}, {
						key: "removeFromParent",
						value: function() {
							var e = this.parent;
							return null !== e && e.remove(this), this
						}
					}, {
						key: "clear",
						value: function() {
							for (var e = 0; e < this.children.length; e++) {
								var t = this.children[e];
								t.parent = null, t.dispatchEvent(qt)
							}
							return this.children.length = 0, this
						}
					}, {
						key: "attach",
						value: function(e) {
							return this.updateWorldMatrix(!0, !1), Bt.copy(
									this.matrixWorld).invert(), null !== e
								.parent && (e.parent.updateWorldMatrix(!0, !
									1), Bt.multiply(e.parent
									.matrixWorld)), e.applyMatrix4(Bt), this
								.add(e), e.updateWorldMatrix(!1, !0), this
						}
					}, {
						key: "getObjectById",
						value: function(e) {
							return this.getObjectByProperty("id", e)
						}
					}, {
						key: "getObjectByName",
						value: function(e) {
							return this.getObjectByProperty("name", e)
						}
					}, {
						key: "getObjectByProperty",
						value: function(e, t) {
							if (this[e] === t) return this;
							for (var n = 0, r = this.children.length; n <
								r; n++) {
								var i = this.children[n]
									.getObjectByProperty(e, t);
								if (void 0 !== i) return i
							}
						}
					}, {
						key: "getWorldPosition",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Object3D: .getWorldPosition() target is now required"
								), e = new je), this.updateWorldMatrix(!
								0, !1), e.setFromMatrixPosition(this
								.matrixWorld)
						}
					}, {
						key: "getWorldQuaternion",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Object3D: .getWorldQuaternion() target is now required"
								), e = new We), this.updateWorldMatrix(!
								0, !1), this.matrixWorld.decompose(Ft,
								e, Ht), e
						}
					}, {
						key: "getWorldScale",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Object3D: .getWorldScale() target is now required"
								), e = new je), this.updateWorldMatrix(!
								0, !1), this.matrixWorld.decompose(Ft,
								Ut, e), e
						}
					}, {
						key: "getWorldDirection",
						value: function(e) {
							void 0 === e && (console.warn(
								"THREE.Object3D: .getWorldDirection() target is now required"
								), e = new je), this.updateWorldMatrix(!
								0, !1);
							var t = this.matrixWorld.elements;
							return e.set(t[8], t[9], t[10]).normalize()
						}
					}, {
						key: "raycast",
						value: function() {}
					}, {
						key: "traverse",
						value: function(e) {
							e(this);
							for (var t = this.children, n = 0, r = t
								.length; n < r; n++) t[n].traverse(e)
						}
					}, {
						key: "traverseVisible",
						value: function(e) {
							if (!1 !== this.visible) {
								e(this);
								for (var t = this.children, n = 0, r = t
										.length; n < r; n++) t[n]
									.traverseVisible(e)
							}
						}
					}, {
						key: "traverseAncestors",
						value: function(e) {
							var t = this.parent;
							null !== t && (e(t), t.traverseAncestors(e))
						}
					}, {
						key: "updateMatrix",
						value: function() {
							this.matrix.compose(this.position, this
									.quaternion, this.scale), this
								.matrixWorldNeedsUpdate = !0
						}
					}, {
						key: "updateMatrixWorld",
						value: function(e) {
							this.matrixAutoUpdate && this.updateMatrix(), (
								this.matrixWorldNeedsUpdate || e) && (
								null === this.parent ? this.matrixWorld
								.copy(this.matrix) : this.matrixWorld
								.multiplyMatrices(this.parent
									.matrixWorld, this.matrix), this
								.matrixWorldNeedsUpdate = !1, e = !0);
							for (var t = this.children, n = 0, r = t
								.length; n < r; n++) t[n].updateMatrixWorld(
								e)
						}
					}, {
						key: "updateWorldMatrix",
						value: function(e, t) {
							var n = this.parent;
							if (!0 === e && null !== n && n
								.updateWorldMatrix(!0, !1), this
								.matrixAutoUpdate && this.updateMatrix(),
								null === this.parent ? this.matrixWorld
								.copy(this.matrix) : this.matrixWorld
								.multiplyMatrices(this.parent.matrixWorld,
									this.matrix), !0 === t)
								for (var r = this.children, i = 0, a = r
										.length; i < a; i++) r[i]
									.updateWorldMatrix(!1, !0)
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = void 0 === e || "string" == typeof e,
								n = {};
							t && (e = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {},
								skeletons: {},
								animations: {}
							}, n.metadata = {
								version: 4.5,
								type: "Object",
								generator: "Object3D.toJSON"
							});
							var r = {};

							function i(t, n) {
								return void 0 === t[n.uuid] && (t[n.uuid] =
									n.toJSON(e)), n.uuid
							}
							if (r.uuid = this.uuid, r.type = this.type,
								"" !== this.name && (r.name = this.name), !
								0 === this.castShadow && (r.castShadow = !
								0), !0 === this.receiveShadow && (r
									.receiveShadow = !0), !1 === this
								.visible && (r.visible = !1), !1 === this
								.frustumCulled && (r.frustumCulled = !1),
								0 !== this.renderOrder && (r.renderOrder =
									this.renderOrder), "{}" !== JSON
								.stringify(this.userData) && (r.userData =
									this.userData), r.layers = this.layers
								.mask, r.matrix = this.matrix.toArray(), !
								1 === this.matrixAutoUpdate && (r
									.matrixAutoUpdate = !1), this
								.isInstancedMesh && (r.type =
									"InstancedMesh", r.count = this.count, r
									.instanceMatrix = this.instanceMatrix
									.toJSON(), null !== this
									.instanceColor && (r.instanceColor =
										this.instanceColor.toJSON())), this
								.isMesh || this.isLine || this.isPoints) {
								r.geometry = i(e.geometries, this.geometry);
								var a = this.geometry.parameters;
								if (void 0 !== a && void 0 !== a.shapes) {
									var o = a.shapes;
									if (Array.isArray(o))
										for (var s = 0, l = o.length; s <
											l; s++) {
											var u = o[s];
											i(e.shapes, u)
										} else i(e.shapes, o)
								}
							}
							if (this.isSkinnedMesh && (r.bindMode = this
									.bindMode, r.bindMatrix = this
									.bindMatrix.toArray(), void 0 !== this
									.skeleton && (i(e.skeletons, this
											.skeleton), r.skeleton = this
										.skeleton.uuid)), void 0 !== this
								.material)
								if (Array.isArray(this.material)) {
									for (var c = [], h = 0, d = this
											.material.length; h < d; h++) c
										.push(i(e.materials, this.material[
											h]));
									r.material = c
								} else r.material = i(e.materials, this
									.material);
							if (this.children.length > 0) {
								r.children = [];
								for (var f = 0; f < this.children
									.length; f++) r.children.push(this
									.children[f].toJSON(e).object)
							}
							if (this.animations.length > 0) {
								r.animations = [];
								for (var p = 0; p < this.animations
									.length; p++) {
									var v = this.animations[p];
									r.animations.push(i(e.animations, v))
								}
							}
							if (t) {
								var m = M(e.geometries),
									g = M(e.materials),
									y = M(e.textures),
									x = M(e.images),
									_ = M(e.shapes),
									b = M(e.skeletons),
									w = M(e.animations);
								m.length > 0 && (n.geometries = m), g
									.length > 0 && (n.materials = g), y
									.length > 0 && (n.textures = y), x
									.length > 0 && (n.images = x), _
									.length > 0 && (n.shapes = _), b
									.length > 0 && (n.skeletons = b), w
									.length > 0 && (n.animations = w)
							}
							return n.object = r, n;

							function M(e) {
								var t = [];
								for (var n in e) {
									var r = e[n];
									delete r.metadata, t.push(r)
								}
								return t
							}
						}
					}, {
						key: "clone",
						value: function(e) {
							return (new this.constructor).copy(this, e)
						}
					}, {
						key: "copy",
						value: function(e) {
							var t = !(arguments.length > 1 && void 0 !==
								arguments[1]) || arguments[1];
							if (this.name = e.name, this.up.copy(e.up), this
								.position.copy(e.position), this.rotation
								.order = e.rotation.order, this.quaternion
								.copy(e.quaternion), this.scale.copy(e
									.scale), this.matrix.copy(e.matrix),
								this.matrixWorld.copy(e.matrixWorld), this
								.matrixAutoUpdate = e.matrixAutoUpdate, this
								.matrixWorldNeedsUpdate = e
								.matrixWorldNeedsUpdate, this.layers.mask =
								e.layers.mask, this.visible = e.visible,
								this.castShadow = e.castShadow, this
								.receiveShadow = e.receiveShadow, this
								.frustumCulled = e.frustumCulled, this
								.renderOrder = e.renderOrder, this
								.userData = JSON.parse(JSON.stringify(e
									.userData)), !0 === t)
								for (var n = 0; n < e.children
									.length; n++) {
									var r = e.children[n];
									this.add(r.clone())
								}
							return this
						}
					}]), n
				}(xe);
			Xt.DefaultUp = new je(0, 1, 0), Xt.DefaultMatrixAutoUpdate = !0, Xt.prototype
				.isObject3D = !0;
			var Yt = new je,
				$t = new je,
				Zt = new Ne,
				Jt = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je(1, 0, 0),
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						(0, g.default)(this, e), this.normal = t, this.constant = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.normal.copy(e), this.constant = t,
								this
						}
					}, {
						key: "setComponents",
						value: function(e, t, n, r) {
							return this.normal.set(e, t, n), this.constant =
								r, this
						}
					}, {
						key: "setFromNormalAndCoplanarPoint",
						value: function(e, t) {
							return this.normal.copy(e), this.constant = -t
								.dot(this.normal), this
						}
					}, {
						key: "setFromCoplanarPoints",
						value: function(e, t, n) {
							var r = Yt.subVectors(n, t).cross($t.subVectors(
								e, t)).normalize();
							return this.setFromNormalAndCoplanarPoint(r, e),
								this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.normal.copy(e.normal), this
								.constant = e.constant, this
						}
					}, {
						key: "normalize",
						value: function() {
							var e = 1 / this.normal.length();
							return this.normal.multiplyScalar(e), this
								.constant *= e, this
						}
					}, {
						key: "negate",
						value: function() {
							return this.constant *= -1, this.normal
							.negate(), this
						}
					}, {
						key: "distanceToPoint",
						value: function(e) {
							return this.normal.dot(e) + this.constant
						}
					}, {
						key: "distanceToSphere",
						value: function(e) {
							return this.distanceToPoint(e.center) - e.radius
						}
					}, {
						key: "projectPoint",
						value: function(e, t) {
							return void 0 === t && (console.warn(
									"THREE.Plane: .projectPoint() target is now required"
									), t = new je), t.copy(this.normal)
								.multiplyScalar(-this.distanceToPoint(e))
								.add(e)
						}
					}, {
						key: "intersectLine",
						value: function(e, t) {
							void 0 === t && (console.warn(
								"THREE.Plane: .intersectLine() target is now required"
								), t = new je);
							var n = e.delta(Yt),
								r = this.normal.dot(n);
							if (0 === r) return 0 === this.distanceToPoint(e
								.start) ? t.copy(e.start) : null;
							var i = -(e.start.dot(this.normal) + this
								.constant) / r;
							return i < 0 || i > 1 ? null : t.copy(n)
								.multiplyScalar(i).add(e.start)
						}
					}, {
						key: "intersectsLine",
						value: function(e) {
							var t = this.distanceToPoint(e.start),
								n = this.distanceToPoint(e.end);
							return t < 0 && n > 0 || n < 0 && t > 0
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return e.intersectsPlane(this)
						}
					}, {
						key: "intersectsSphere",
						value: function(e) {
							return e.intersectsPlane(this)
						}
					}, {
						key: "coplanarPoint",
						value: function(e) {
							return void 0 === e && (console.warn(
									"THREE.Plane: .coplanarPoint() target is now required"
									), e = new je), e.copy(this.normal)
								.multiplyScalar(-this.constant)
						}
					}, {
						key: "applyMatrix4",
						value: function(e, t) {
							var n = t || Zt.getNormalMatrix(e),
								r = this.coplanarPoint(Yt).applyMatrix4(e),
								i = this.normal.applyMatrix3(n).normalize();
							return this.constant = -r.dot(i), this
						}
					}, {
						key: "translate",
						value: function(e) {
							return this.constant -= e.dot(this.normal), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.normal.equals(this.normal) && e
								.constant === this.constant
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}();
			Jt.prototype.isPlane = !0;
			var Qt = new je,
				Kt = new je,
				en = new je,
				tn = new je,
				nn = new je,
				rn = new je,
				an = new je,
				on = new je,
				sn = new je,
				ln = new je,
				un = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : new je;
						(0, g.default)(this, e), this.a = t, this.b = n, this.c = r
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t, n) {
							return this.a.copy(e), this.b.copy(t), this.c
								.copy(n), this
						}
					}, {
						key: "setFromPointsAndIndices",
						value: function(e, t, n, r) {
							return this.a.copy(e[t]), this.b.copy(e[n]),
								this.c.copy(e[r]), this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.a.copy(e.a), this.b.copy(e.b), this
								.c.copy(e.c), this
						}
					}, {
						key: "getArea",
						value: function() {
							return Qt.subVectors(this.c, this.b), Kt
								.subVectors(this.a, this.b), .5 * Qt.cross(
									Kt).length()
						}
					}, {
						key: "getMidpoint",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Triangle: .getMidpoint() target is now required"
								), e = new je), e.addVectors(this.a,
								this.b).add(this.c).multiplyScalar(1 /
								3)
						}
					}, {
						key: "getNormal",
						value: function(t) {
							return e.getNormal(this.a, this.b, this.c, t)
						}
					}, {
						key: "getPlane",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Triangle: .getPlane() target is now required"
								), e = new Jt), e.setFromCoplanarPoints(
								this.a, this.b, this.c)
						}
					}, {
						key: "getBarycoord",
						value: function(t, n) {
							return e.getBarycoord(t, this.a, this.b, this.c,
								n)
						}
					}, {
						key: "getUV",
						value: function(t, n, r, i, a) {
							return e.getUV(t, this.a, this.b, this.c, n, r,
								i, a)
						}
					}, {
						key: "containsPoint",
						value: function(t) {
							return e.containsPoint(t, this.a, this.b, this
								.c)
						}
					}, {
						key: "isFrontFacing",
						value: function(t) {
							return e.isFrontFacing(this.a, this.b, this.c,
								t)
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return e.intersectsTriangle(this)
						}
					}, {
						key: "closestPointToPoint",
						value: function(e, t) {
							void 0 === t && (console.warn(
								"THREE.Triangle: .closestPointToPoint() target is now required"
								), t = new je);
							var n, r, i = this.a,
								a = this.b,
								o = this.c;
							nn.subVectors(a, i), rn.subVectors(o, i), on
								.subVectors(e, i);
							var s = nn.dot(on),
								l = rn.dot(on);
							if (s <= 0 && l <= 0) return t.copy(i);
							sn.subVectors(e, a);
							var u = nn.dot(sn),
								c = rn.dot(sn);
							if (u >= 0 && c <= u) return t.copy(a);
							var h = s * c - u * l;
							if (h <= 0 && s >= 0 && u <= 0) return n = s / (
								s - u), t.copy(i).addScaledVector(
								nn, n);
							ln.subVectors(e, o);
							var d = nn.dot(ln),
								f = rn.dot(ln);
							if (f >= 0 && d <= f) return t.copy(o);
							var p = d * l - s * f;
							if (p <= 0 && l >= 0 && f <= 0) return r = l / (
								l - f), t.copy(i).addScaledVector(
								rn, r);
							var v = u * f - d * c;
							if (v <= 0 && c - u >= 0 && d - f >= 0)
							return an.subVectors(o, a), r = (c - u) / (
									c - u + (d - f)), t.copy(a)
								.addScaledVector(an, r);
							var m = 1 / (v + p + h);
							return n = p * m, r = h * m, t.copy(i)
								.addScaledVector(nn, n).addScaledVector(rn,
									r)
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.a.equals(this.a) && e.b.equals(this
								.b) && e.c.equals(this.c)
						}
					}], [{
						key: "getNormal",
						value: function(e, t, n, r) {
							void 0 === r && (console.warn(
									"THREE.Triangle: .getNormal() target is now required"
									), r = new je), r.subVectors(n, t), Qt
								.subVectors(e, t), r.cross(Qt);
							var i = r.lengthSq();
							return i > 0 ? r.multiplyScalar(1 / Math.sqrt(
								i)) : r.set(0, 0, 0)
						}
					}, {
						key: "getBarycoord",
						value: function(e, t, n, r, i) {
							Qt.subVectors(r, t), Kt.subVectors(n, t), en
								.subVectors(e, t);
							var a = Qt.dot(Qt),
								o = Qt.dot(Kt),
								s = Qt.dot(en),
								l = Kt.dot(Kt),
								u = Kt.dot(en),
								c = a * l - o * o;
							if (void 0 === i && (console.warn(
									"THREE.Triangle: .getBarycoord() target is now required"
									), i = new je), 0 === c) return i.set(-
								2, -1, -1);
							var h = 1 / c,
								d = (l * s - o * u) * h,
								f = (a * u - o * s) * h;
							return i.set(1 - d - f, f, d)
						}
					}, {
						key: "containsPoint",
						value: function(e, t, n, r) {
							return this.getBarycoord(e, t, n, r, tn), tn
								.x >= 0 && tn.y >= 0 && tn.x + tn.y <= 1
						}
					}, {
						key: "getUV",
						value: function(e, t, n, r, i, a, o, s) {
							return this.getBarycoord(e, t, n, r, tn), s.set(
									0, 0), s.addScaledVector(i, tn.x), s
								.addScaledVector(a, tn.y), s
								.addScaledVector(o, tn.z), s
						}
					}, {
						key: "isFrontFacing",
						value: function(e, t, n, r) {
							return Qt.subVectors(n, t), Kt.subVectors(e, t),
								Qt.cross(Kt).dot(r) < 0
						}
					}]), e
				}(),
				cn = 0,
				hn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), e = t.call(this), Object
							.defineProperty((0, f.default)(e), "id", {
								value: cn++
							}), e.uuid = Te(), e.name = "", e.type = "Material", e.fog = !0,
							e.blending = 1, e.side = 0, e.vertexColors = !1, e.opacity = 1,
							e.transparent = !1, e.blendSrc = 204, e.blendDst = 205, e
							.blendEquation = r, e.blendSrcAlpha = null, e.blendDstAlpha =
							null, e.blendEquationAlpha = null, e.depthFunc = 3, e
							.depthTest = !0, e.depthWrite = !0, e.stencilWriteMask = 255, e
							.stencilFunc = 519, e.stencilRef = 0, e.stencilFuncMask = 255, e
							.stencilFail = ve, e.stencilZFail = ve, e.stencilZPass = ve, e
							.stencilWrite = !1, e.clippingPlanes = null, e
							.clipIntersection = !1, e.clipShadows = !1, e.shadowSide = null,
							e.colorWrite = !0, e.precision = null, e.polygonOffset = !1, e
							.polygonOffsetFactor = 0, e.polygonOffsetUnits = 0, e
							.dithering = !1, e.alphaTest = 0, e.alphaToCoverage = !1, e
							.premultipliedAlpha = !1, e.visible = !0, e.toneMapped = !0, e
							.userData = {}, e.version = 0, e
					}
					return (0, y.default)(n, [{
						key: "onBuild",
						value: function() {}
					}, {
						key: "onBeforeCompile",
						value: function() {}
					}, {
						key: "customProgramCacheKey",
						value: function() {
							return this.onBeforeCompile.toString()
						}
					}, {
						key: "setValues",
						value: function(e) {
							if (void 0 !== e)
								for (var t in e) {
									var n = e[t];
									if (void 0 !== n)
										if ("shading" !== t) {
											var r = this[t];
											void 0 !== r ? r && r.isColor ?
												r.set(n) : r && r
												.isVector3 && n && n
												.isVector3 ? r.copy(n) :
												this[t] = n : console.warn(
													"THREE." + this.type +
													": '" + t +
													"' is not a property of this material."
													)
										} else console.warn("THREE." + this
												.type +
												": .shading has been removed. Use the boolean .flatShading instead."
												), this.flatShading = 1 ===
											n;
									else console.warn("THREE.Material: '" +
										t + "' parameter is undefined.")
								}
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = void 0 === e || "string" == typeof e;
							t && (e = {
								textures: {},
								images: {}
							});
							var n = {
								metadata: {
									version: 4.5,
									type: "Material",
									generator: "Material.toJSON"
								}
							};

							function r(e) {
								var t = [];
								for (var n in e) {
									var r = e[n];
									delete r.metadata, t.push(r)
								}
								return t
							}
							if (n.uuid = this.uuid, n.type = this.type,
								"" !== this.name && (n.name = this.name),
								this.color && this.color.isColor && (n
									.color = this.color.getHex()),
								void 0 !== this.roughness && (n.roughness =
									this.roughness), void 0 !== this
								.metalness && (n.metalness = this
								.metalness), this.sheen && this.sheen
								.isColor && (n.sheen = this.sheen.getHex()),
								this.emissive && this.emissive.isColor && (n
									.emissive = this.emissive.getHex()),
								this.emissiveIntensity && 1 !== this
								.emissiveIntensity && (n.emissiveIntensity =
									this.emissiveIntensity), this
								.specular && this.specular.isColor && (n
									.specular = this.specular.getHex()),
								void 0 !== this.shininess && (n.shininess =
									this.shininess), void 0 !== this
								.clearcoat && (n.clearcoat = this
								.clearcoat), void 0 !== this
								.clearcoatRoughness && (n
									.clearcoatRoughness = this
									.clearcoatRoughness), this
								.clearcoatMap && this.clearcoatMap
								.isTexture && (n.clearcoatMap = this
									.clearcoatMap.toJSON(e).uuid), this
								.clearcoatRoughnessMap && this
								.clearcoatRoughnessMap.isTexture && (n
									.clearcoatRoughnessMap = this
									.clearcoatRoughnessMap.toJSON(e).uuid),
								this.clearcoatNormalMap && this
								.clearcoatNormalMap.isTexture && (n
									.clearcoatNormalMap = this
									.clearcoatNormalMap.toJSON(e).uuid, n
									.clearcoatNormalScale = this
									.clearcoatNormalScale.toArray()), this
								.map && this.map.isTexture && (n.map = this
									.map.toJSON(e).uuid), this.matcap &&
								this.matcap.isTexture && (n.matcap = this
									.matcap.toJSON(e).uuid), this
								.alphaMap && this.alphaMap.isTexture && (n
									.alphaMap = this.alphaMap.toJSON(e).uuid
									), this.lightMap && this.lightMap
								.isTexture && (n.lightMap = this.lightMap
									.toJSON(e).uuid, n.lightMapIntensity =
									this.lightMapIntensity), this.aoMap &&
								this.aoMap.isTexture && (n.aoMap = this
									.aoMap.toJSON(e).uuid, n
									.aoMapIntensity = this.aoMapIntensity),
								this.bumpMap && this.bumpMap.isTexture && (n
									.bumpMap = this.bumpMap.toJSON(e).uuid,
									n.bumpScale = this.bumpScale), this
								.normalMap && this.normalMap.isTexture && (n
									.normalMap = this.normalMap.toJSON(e)
									.uuid, n.normalMapType = this
									.normalMapType, n.normalScale = this
									.normalScale.toArray()), this
								.displacementMap && this.displacementMap
								.isTexture && (n.displacementMap = this
									.displacementMap.toJSON(e).uuid, n
									.displacementScale = this
									.displacementScale, n.displacementBias =
									this.displacementBias), this
								.roughnessMap && this.roughnessMap
								.isTexture && (n.roughnessMap = this
									.roughnessMap.toJSON(e).uuid), this
								.metalnessMap && this.metalnessMap
								.isTexture && (n.metalnessMap = this
									.metalnessMap.toJSON(e).uuid), this
								.emissiveMap && this.emissiveMap
								.isTexture && (n.emissiveMap = this
									.emissiveMap.toJSON(e).uuid), this
								.specularMap && this.specularMap
								.isTexture && (n.specularMap = this
									.specularMap.toJSON(e).uuid), this
								.envMap && this.envMap.isTexture && (n
									.envMap = this.envMap.toJSON(e).uuid,
									void 0 !== this.combine && (n.combine =
										this.combine)), void 0 !== this
								.envMapIntensity && (n.envMapIntensity =
									this.envMapIntensity), void 0 !== this
								.reflectivity && (n.reflectivity = this
									.reflectivity), void 0 !== this
								.refractionRatio && (n.refractionRatio =
									this.refractionRatio), this
								.gradientMap && this.gradientMap
								.isTexture && (n.gradientMap = this
									.gradientMap.toJSON(e).uuid), void 0 !==
								this.transmission && (n.transmission = this
									.transmission), this.transmissionMap &&
								this.transmissionMap.isTexture && (n
									.transmissionMap = this.transmissionMap
									.toJSON(e).uuid), void 0 !== this
								.thickness && (n.thickness = this
								.thickness), this.thicknessMap && this
								.thicknessMap.isTexture && (n.thicknessMap =
									this.thicknessMap.toJSON(e).uuid),
								void 0 !== this.attenuationDistance && (n
									.attenuationDistance = this
									.attenuationDistance), void 0 !== this
								.attenuationColor && (n.attenuationColor =
									this.attenuationColor.getHex()),
								void 0 !== this.size && (n.size = this
								.size), null !== this.shadowSide && (n
									.shadowSide = this.shadowSide),
								void 0 !== this.sizeAttenuation && (n
									.sizeAttenuation = this.sizeAttenuation
									), 1 !== this.blending && (n.blending =
									this.blending), 0 !== this.side && (n
									.side = this.side), this.vertexColors &&
								(n.vertexColors = !0), this.opacity < 1 && (
									n.opacity = this.opacity), !0 === this
								.transparent && (n.transparent = this
									.transparent), n.depthFunc = this
								.depthFunc, n.depthTest = this.depthTest, n
								.depthWrite = this.depthWrite, n
								.colorWrite = this.colorWrite, n
								.stencilWrite = this.stencilWrite, n
								.stencilWriteMask = this.stencilWriteMask, n
								.stencilFunc = this.stencilFunc, n
								.stencilRef = this.stencilRef, n
								.stencilFuncMask = this.stencilFuncMask, n
								.stencilFail = this.stencilFail, n
								.stencilZFail = this.stencilZFail, n
								.stencilZPass = this.stencilZPass, this
								.rotation && 0 !== this.rotation && (n
									.rotation = this.rotation), !0 === this
								.polygonOffset && (n.polygonOffset = !0),
								0 !== this.polygonOffsetFactor && (n
									.polygonOffsetFactor = this
									.polygonOffsetFactor), 0 !== this
								.polygonOffsetUnits && (n
									.polygonOffsetUnits = this
									.polygonOffsetUnits), this.linewidth &&
								1 !== this.linewidth && (n.linewidth = this
									.linewidth), void 0 !== this.dashSize &&
								(n.dashSize = this.dashSize), void 0 !==
								this.gapSize && (n.gapSize = this.gapSize),
								void 0 !== this.scale && (n.scale = this
									.scale), !0 === this.dithering && (n
									.dithering = !0), this.alphaTest > 0 &&
								(n.alphaTest = this.alphaTest), !0 === this
								.alphaToCoverage && (n.alphaToCoverage =
									this.alphaToCoverage), !0 === this
								.premultipliedAlpha && (n
									.premultipliedAlpha = this
									.premultipliedAlpha), !0 === this
								.wireframe && (n.wireframe = this
								.wireframe), this.wireframeLinewidth > 1 &&
								(n.wireframeLinewidth = this
									.wireframeLinewidth), "round" !== this
								.wireframeLinecap && (n.wireframeLinecap =
									this.wireframeLinecap), "round" !== this
								.wireframeLinejoin && (n.wireframeLinejoin =
									this.wireframeLinejoin), !0 === this
								.morphTargets && (n.morphTargets = !0), !
								0 === this.morphNormals && (n
									.morphNormals = !0), !0 === this
								.flatShading && (n.flatShading = this
									.flatShading), !1 === this.visible && (n
									.visible = !1), !1 === this
								.toneMapped && (n.toneMapped = !1), "{}" !==
								JSON.stringify(this.userData) && (n
									.userData = this.userData), t) {
								var i = r(e.textures),
									a = r(e.images);
								i.length > 0 && (n.textures = i), a.length >
									0 && (n.images = a)
							}
							return n
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							this.name = e.name, this.fog = e.fog, this
								.blending = e.blending, this.side = e.side,
								this.vertexColors = e.vertexColors, this
								.opacity = e.opacity, this.transparent = e
								.transparent, this.blendSrc = e.blendSrc,
								this.blendDst = e.blendDst, this
								.blendEquation = e.blendEquation, this
								.blendSrcAlpha = e.blendSrcAlpha, this
								.blendDstAlpha = e.blendDstAlpha, this
								.blendEquationAlpha = e.blendEquationAlpha,
								this.depthFunc = e.depthFunc, this
								.depthTest = e.depthTest, this.depthWrite =
								e.depthWrite, this.stencilWriteMask = e
								.stencilWriteMask, this.stencilFunc = e
								.stencilFunc, this.stencilRef = e
								.stencilRef, this.stencilFuncMask = e
								.stencilFuncMask, this.stencilFail = e
								.stencilFail, this.stencilZFail = e
								.stencilZFail, this.stencilZPass = e
								.stencilZPass, this.stencilWrite = e
								.stencilWrite;
							var t = e.clippingPlanes,
								n = null;
							if (null !== t) {
								var r = t.length;
								n = new Array(r);
								for (var i = 0; i !== r; ++i) n[i] = t[i]
									.clone()
							}
							return this.clippingPlanes = n, this
								.clipIntersection = e.clipIntersection, this
								.clipShadows = e.clipShadows, this
								.shadowSide = e.shadowSide, this
								.colorWrite = e.colorWrite, this.precision =
								e.precision, this.polygonOffset = e
								.polygonOffset, this.polygonOffsetFactor = e
								.polygonOffsetFactor, this
								.polygonOffsetUnits = e.polygonOffsetUnits,
								this.dithering = e.dithering, this
								.alphaTest = e.alphaTest, this
								.alphaToCoverage = e.alphaToCoverage, this
								.premultipliedAlpha = e.premultipliedAlpha,
								this.visible = e.visible, this.toneMapped =
								e.toneMapped, this.userData = JSON.parse(
									JSON.stringify(e.userData)), this
						}
					}, {
						key: "dispose",
						value: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}, {
						key: "needsUpdate",
						set: function(e) {
							!0 === e && this.version++
						}
					}]), n
				}(xe);
			hn.prototype.isMaterial = !0;
			var dn = {
					aliceblue: 15792383,
					antiquewhite: 16444375,
					aqua: 65535,
					aquamarine: 8388564,
					azure: 15794175,
					beige: 16119260,
					bisque: 16770244,
					black: 0,
					blanchedalmond: 16772045,
					blue: 255,
					blueviolet: 9055202,
					brown: 10824234,
					burlywood: 14596231,
					cadetblue: 6266528,
					chartreuse: 8388352,
					chocolate: 13789470,
					coral: 16744272,
					cornflowerblue: 6591981,
					cornsilk: 16775388,
					crimson: 14423100,
					cyan: 65535,
					darkblue: 139,
					darkcyan: 35723,
					darkgoldenrod: 12092939,
					darkgray: 11119017,
					darkgreen: 25600,
					darkgrey: 11119017,
					darkkhaki: 12433259,
					darkmagenta: 9109643,
					darkolivegreen: 5597999,
					darkorange: 16747520,
					darkorchid: 10040012,
					darkred: 9109504,
					darksalmon: 15308410,
					darkseagreen: 9419919,
					darkslateblue: 4734347,
					darkslategray: 3100495,
					darkslategrey: 3100495,
					darkturquoise: 52945,
					darkviolet: 9699539,
					deeppink: 16716947,
					deepskyblue: 49151,
					dimgray: 6908265,
					dimgrey: 6908265,
					dodgerblue: 2003199,
					firebrick: 11674146,
					floralwhite: 16775920,
					forestgreen: 2263842,
					fuchsia: 16711935,
					gainsboro: 14474460,
					ghostwhite: 16316671,
					gold: 16766720,
					goldenrod: 14329120,
					gray: 8421504,
					green: 32768,
					greenyellow: 11403055,
					grey: 8421504,
					honeydew: 15794160,
					hotpink: 16738740,
					indianred: 13458524,
					indigo: 4915330,
					ivory: 16777200,
					khaki: 15787660,
					lavender: 15132410,
					lavenderblush: 16773365,
					lawngreen: 8190976,
					lemonchiffon: 16775885,
					lightblue: 11393254,
					lightcoral: 15761536,
					lightcyan: 14745599,
					lightgoldenrodyellow: 16448210,
					lightgray: 13882323,
					lightgreen: 9498256,
					lightgrey: 13882323,
					lightpink: 16758465,
					lightsalmon: 16752762,
					lightseagreen: 2142890,
					lightskyblue: 8900346,
					lightslategray: 7833753,
					lightslategrey: 7833753,
					lightsteelblue: 11584734,
					lightyellow: 16777184,
					lime: 65280,
					limegreen: 3329330,
					linen: 16445670,
					magenta: 16711935,
					maroon: 8388608,
					mediumaquamarine: 6737322,
					mediumblue: 205,
					mediumorchid: 12211667,
					mediumpurple: 9662683,
					mediumseagreen: 3978097,
					mediumslateblue: 8087790,
					mediumspringgreen: 64154,
					mediumturquoise: 4772300,
					mediumvioletred: 13047173,
					midnightblue: 1644912,
					mintcream: 16121850,
					mistyrose: 16770273,
					moccasin: 16770229,
					navajowhite: 16768685,
					navy: 128,
					oldlace: 16643558,
					olive: 8421376,
					olivedrab: 7048739,
					orange: 16753920,
					orangered: 16729344,
					orchid: 14315734,
					palegoldenrod: 15657130,
					palegreen: 10025880,
					paleturquoise: 11529966,
					palevioletred: 14381203,
					papayawhip: 16773077,
					peachpuff: 16767673,
					peru: 13468991,
					pink: 16761035,
					plum: 14524637,
					powderblue: 11591910,
					purple: 8388736,
					rebeccapurple: 6697881,
					red: 16711680,
					rosybrown: 12357519,
					royalblue: 4286945,
					saddlebrown: 9127187,
					salmon: 16416882,
					sandybrown: 16032864,
					seagreen: 3050327,
					seashell: 16774638,
					sienna: 10506797,
					silver: 12632256,
					skyblue: 8900331,
					slateblue: 6970061,
					slategray: 7372944,
					slategrey: 7372944,
					snow: 16775930,
					springgreen: 65407,
					steelblue: 4620980,
					tan: 13808780,
					teal: 32896,
					thistle: 14204888,
					tomato: 16737095,
					turquoise: 4251856,
					violet: 15631086,
					wheat: 16113331,
					white: 16777215,
					whitesmoke: 16119285,
					yellow: 16776960,
					yellowgreen: 10145074
				},
				fn = {
					h: 0,
					s: 0,
					l: 0
				},
				pn = {
					h: 0,
					s: 0,
					l: 0
				};

			function vn(e, t, n) {
				return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) *
					n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
			}

			function mn(e) {
				return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e +
					.0521327014, 2.4)
			}

			function gn(e) {
				return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
			}
			var yn = function() {
				function e(t, n, r) {
					return (0, g.default)(this, e), void 0 === n && void 0 === r ? this
						.set(t) : this.setRGB(t, n, r)
				}
				return (0, y.default)(e, [{
					key: "set",
					value: function(e) {
						return e && e.isColor ? this.copy(e) :
							"number" == typeof e ? this.setHex(e) :
							"string" == typeof e && this.setStyle(e),
							this
					}
				}, {
					key: "setScalar",
					value: function(e) {
						return this.r = e, this.g = e, this.b = e, this
					}
				}, {
					key: "setHex",
					value: function(e) {
						return e = Math.floor(e), this.r = (e >> 16 &
								255) / 255, this.g = (e >> 8 & 255) /
							255, this.b = (255 & e) / 255, this
					}
				}, {
					key: "setRGB",
					value: function(e, t, n) {
						return this.r = e, this.g = t, this.b = n, this
					}
				}, {
					key: "setHSL",
					value: function(e, t, n) {
						if (e = Ae(e, 1), t = Ee(t, 0, 1), n = Ee(n, 0,
								1), 0 === t) this.r = this.g = this.b =
							n;
						else {
							var r = n <= .5 ? n * (1 + t) : n + t - n *
								t,
								i = 2 * n - r;
							this.r = vn(i, r, e + 1 / 3), this.g = vn(i,
								r, e), this.b = vn(i, r, e - 1 / 3)
						}
						return this
					}
				}, {
					key: "setStyle",
					value: function(e) {
						function t(t) {
							void 0 !== t && parseFloat(t) < 1 && console
								.warn(
									"THREE.Color: Alpha component of " +
									e + " will be ignored.")
						}
						var n;
						if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(
							e)) {
							var r, i = n[1],
								a = n[2];
							switch (i) {
								case "rgb":
								case "rgba":
									if (r =
										/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/
										.exec(a)) return this.r = Math
										.min(255, parseInt(r[1],
											10)) / 255, this.g =
										Math.min(255, parseInt(r[2],
											10)) / 255, this.b =
										Math.min(255, parseInt(r[3],
											10)) / 255, t(r[4]),
										this;
									if (r =
										/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/
										.exec(a)) return this.r = Math
										.min(100, parseInt(r[1],
											10)) / 100, this.g =
										Math.min(100, parseInt(r[2],
											10)) / 100, this.b =
										Math.min(100, parseInt(r[3],
											10)) / 100, t(r[4]),
										this;
									break;
								case "hsl":
								case "hsla":
									if (r =
										/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/
										.exec(a)) {
										var o = parseFloat(r[1]) / 360,
											s = parseInt(r[2], 10) /
											100,
											l = parseInt(r[3], 10) /
											100;
										return t(r[4]), this.setHSL(o,
											s, l)
									}
							}
						} else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
							var u = n[1],
								c = u.length;
							if (3 === c) return this.r = parseInt(u
									.charAt(0) + u.charAt(0), 16) /
								255, this.g = parseInt(u.charAt(1) +
									u.charAt(1), 16) / 255, this.b =
								parseInt(u.charAt(2) + u.charAt(2),
									16) / 255, this;
							if (6 === c) return this.r = parseInt(u
									.charAt(0) + u.charAt(1), 16) /
								255, this.g = parseInt(u.charAt(2) +
									u.charAt(3), 16) / 255, this.b =
								parseInt(u.charAt(4) + u.charAt(5),
									16) / 255, this
						}
						return e && e.length > 0 ? this.setColorName(
							e) : this
					}
				}, {
					key: "setColorName",
					value: function(e) {
						var t = dn[e.toLowerCase()];
						return void 0 !== t ? this.setHex(t) : console
							.warn("THREE.Color: Unknown color " + e),
							this
					}
				}, {
					key: "clone",
					value: function() {
						return new this.constructor(this.r, this.g, this
							.b)
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.r = e.r, this.g = e.g, this.b = e.b,
							this
					}
				}, {
					key: "copyGammaToLinear",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 2;
						return this.r = Math.pow(e.r, t), this.g = Math
							.pow(e.g, t), this.b = Math.pow(e.b, t),
							this
					}
				}, {
					key: "copyLinearToGamma",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 2,
							n = t > 0 ? 1 / t : 1;
						return this.r = Math.pow(e.r, n), this.g = Math
							.pow(e.g, n), this.b = Math.pow(e.b, n),
							this
					}
				}, {
					key: "convertGammaToLinear",
					value: function(e) {
						return this.copyGammaToLinear(this, e), this
					}
				}, {
					key: "convertLinearToGamma",
					value: function(e) {
						return this.copyLinearToGamma(this, e), this
					}
				}, {
					key: "copySRGBToLinear",
					value: function(e) {
						return this.r = mn(e.r), this.g = mn(e.g), this
							.b = mn(e.b), this
					}
				}, {
					key: "copyLinearToSRGB",
					value: function(e) {
						return this.r = gn(e.r), this.g = gn(e.g), this
							.b = gn(e.b), this
					}
				}, {
					key: "convertSRGBToLinear",
					value: function() {
						return this.copySRGBToLinear(this), this
					}
				}, {
					key: "convertLinearToSRGB",
					value: function() {
						return this.copyLinearToSRGB(this), this
					}
				}, {
					key: "getHex",
					value: function() {
						return 255 * this.r << 16 ^ 255 * this.g << 8 ^
							255 * this.b << 0
					}
				}, {
					key: "getHexString",
					value: function() {
						return ("000000" + this.getHex().toString(16))
							.slice(-6)
					}
				}, {
					key: "getHSL",
					value: function(e) {
						void 0 === e && (console.warn(
							"THREE.Color: .getHSL() target is now required"
							), e = {
							h: 0,
							s: 0,
							l: 0
						});
						var t, n, r = this.r,
							i = this.g,
							a = this.b,
							o = Math.max(r, i, a),
							s = Math.min(r, i, a),
							l = (s + o) / 2;
						if (s === o) t = 0, n = 0;
						else {
							var u = o - s;
							switch (n = l <= .5 ? u / (o + s) : u / (2 -
								o - s), o) {
								case r:
									t = (i - a) / u + (i < a ? 6 : 0);
									break;
								case i:
									t = (a - r) / u + 2;
									break;
								case a:
									t = (r - i) / u + 4
							}
							t /= 6
						}
						return e.h = t, e.s = n, e.l = l, e
					}
				}, {
					key: "getStyle",
					value: function() {
						return "rgb(" + (255 * this.r | 0) + "," + (
							255 * this.g | 0) + "," + (255 * this
							.b | 0) + ")"
					}
				}, {
					key: "offsetHSL",
					value: function(e, t, n) {
						return this.getHSL(fn), fn.h += e, fn.s += t, fn
							.l += n, this.setHSL(fn.h, fn.s, fn.l), this
					}
				}, {
					key: "add",
					value: function(e) {
						return this.r += e.r, this.g += e.g, this.b += e
							.b, this
					}
				}, {
					key: "addColors",
					value: function(e, t) {
						return this.r = e.r + t.r, this.g = e.g + t.g,
							this.b = e.b + t.b, this
					}
				}, {
					key: "addScalar",
					value: function(e) {
						return this.r += e, this.g += e, this.b += e,
							this
					}
				}, {
					key: "sub",
					value: function(e) {
						return this.r = Math.max(0, this.r - e.r), this
							.g = Math.max(0, this.g - e.g), this.b =
							Math.max(0, this.b - e.b), this
					}
				}, {
					key: "multiply",
					value: function(e) {
						return this.r *= e.r, this.g *= e.g, this.b *= e
							.b, this
					}
				}, {
					key: "multiplyScalar",
					value: function(e) {
						return this.r *= e, this.g *= e, this.b *= e,
							this
					}
				}, {
					key: "lerp",
					value: function(e, t) {
						return this.r += (e.r - this.r) * t, this.g += (
							e.g - this.g) * t, this.b += (e.b - this
							.b) * t, this
					}
				}, {
					key: "lerpColors",
					value: function(e, t, n) {
						return this.r = e.r + (t.r - e.r) * n, this.g =
							e.g + (t.g - e.g) * n, this.b = e.b + (t.b -
								e.b) * n, this
					}
				}, {
					key: "lerpHSL",
					value: function(e, t) {
						this.getHSL(fn), e.getHSL(pn);
						var n = Le(fn.h, pn.h, t),
							r = Le(fn.s, pn.s, t),
							i = Le(fn.l, pn.l, t);
						return this.setHSL(n, r, i), this
					}
				}, {
					key: "equals",
					value: function(e) {
						return e.r === this.r && e.g === this.g && e
							.b === this.b
					}
				}, {
					key: "fromArray",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return this.r = e[t], this.g = e[t + 1], this
							.b = e[t + 2], this
					}
				}, {
					key: "toArray",
					value: function() {
						var e = arguments.length > 0 && void 0 !==
							arguments[0] ? arguments[0] : [],
							t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return e[t] = this.r, e[t + 1] = this.g, e[t +
							2] = this.b, e
					}
				}, {
					key: "fromBufferAttribute",
					value: function(e, t) {
						return this.r = e.getX(t), this.g = e.getY(t),
							this.b = e.getZ(t), !0 === e.normalized && (
								this.r /= 255, this.g /= 255, this.b /=
								255), this
					}
				}, {
					key: "toJSON",
					value: function() {
						return this.getHex()
					}
				}]), e
			}();
			yn.NAMES = dn, yn.prototype.isColor = !0, yn.prototype.r = 1, yn.prototype.g =
				1, yn.prototype.b = 1;
			var xn = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshBasicMaterial", r.color = new yn(16777215), r.map = null, r
						.lightMap = null, r.lightMapIntensity = 1, r.aoMap = null, r
						.aoMapIntensity = 1, r.specularMap = null, r.alphaMap = null, r
						.envMap = null, r.combine = 0, r.reflectivity = 1, r
						.refractionRatio = .98, r.wireframe = !1, r.wireframeLinewidth =
						1, r.wireframeLinecap = "round", r.wireframeLinejoin = "round",
						r.morphTargets = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.map = e
							.map, this.lightMap = e.lightMap, this
							.lightMapIntensity = e.lightMapIntensity,
							this.aoMap = e.aoMap, this.aoMapIntensity =
							e.aoMapIntensity, this.specularMap = e
							.specularMap, this.alphaMap = e.alphaMap,
							this.envMap = e.envMap, this.combine = e
							.combine, this.reflectivity = e
							.reflectivity, this.refractionRatio = e
							.refractionRatio, this.wireframe = e
							.wireframe, this.wireframeLinewidth = e
							.wireframeLinewidth, this.wireframeLinecap =
							e.wireframeLinecap, this.wireframeLinejoin =
							e.wireframeLinejoin, this.morphTargets = e
							.morphTargets, this
					}
				}]), n
			}(hn);
			xn.prototype.isMeshBasicMaterial = !0;
			var _n = new je,
				bn = new Ie,
				wn = function() {
					function e(t, n, r) {
						if ((0, g.default)(this, e), Array.isArray(t)) throw new TypeError(
							"THREE.BufferAttribute: array should be a Typed Array.");
						this.name = "", this.array = t, this.itemSize = n, this.count =
							void 0 !== t ? t.length / n : 0, this.normalized = !0 === r,
							this.usage = me, this.updateRange = {
								offset: 0,
								count: -1
							}, this.version = 0
					}
					return (0, y.default)(e, [{
						key: "onUploadCallback",
						value: function() {}
					}, {
						key: "needsUpdate",
						set: function(e) {
							!0 === e && this.version++
						}
					}, {
						key: "setUsage",
						value: function(e) {
							return this.usage = e, this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.name = e.name, this.array = new e
								.array.constructor(e.array), this.itemSize =
								e.itemSize, this.count = e.count, this
								.normalized = e.normalized, this.usage = e
								.usage, this
						}
					}, {
						key: "copyAt",
						value: function(e, t, n) {
							e *= this.itemSize, n *= t.itemSize;
							for (var r = 0, i = this.itemSize; r < i; r++)
								this.array[e + r] = t.array[n + r];
							return this
						}
					}, {
						key: "copyArray",
						value: function(e) {
							return this.array.set(e), this
						}
					}, {
						key: "copyColorsArray",
						value: function(e) {
							for (var t = this.array, n = 0, r = 0, i = e
									.length; r < i; r++) {
								var a = e[r];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyColorsArray(): color is undefined",
									r), a = new yn), t[n++] = a.r, t[
									n++] = a.g, t[n++] = a.b
							}
							return this
						}
					}, {
						key: "copyVector2sArray",
						value: function(e) {
							for (var t = this.array, n = 0, r = 0, i = e
									.length; r < i; r++) {
								var a = e[r];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
									r), a = new Ie), t[n++] = a.x, t[
									n++] = a.y
							}
							return this
						}
					}, {
						key: "copyVector3sArray",
						value: function(e) {
							for (var t = this.array, n = 0, r = 0, i = e
									.length; r < i; r++) {
								var a = e[r];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
									r), a = new je), t[n++] = a.x, t[
									n++] = a.y, t[n++] = a.z
							}
							return this
						}
					}, {
						key: "copyVector4sArray",
						value: function(e) {
							for (var t = this.array, n = 0, r = 0, i = e
									.length; r < i; r++) {
								var a = e[r];
								void 0 === a && (console.warn(
										"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
										r), a = new He), t[n++] = a.x, t[
										n++] = a.y, t[n++] = a.z, t[n++] = a
									.w
							}
							return this
						}
					}, {
						key: "applyMatrix3",
						value: function(e) {
							if (2 === this.itemSize)
								for (var t = 0, n = this.count; t < n; t++)
									bn.fromBufferAttribute(this, t), bn
									.applyMatrix3(e), this.setXY(t, bn.x, bn
										.y);
							else if (3 === this.itemSize)
								for (var r = 0, i = this.count; r < i; r++)
									_n.fromBufferAttribute(this, r), _n
									.applyMatrix3(e), this.setXYZ(r, _n.x,
										_n.y, _n.z);
							return this
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							for (var t = 0, n = this.count; t < n; t++) _n
								.x = this.getX(t), _n.y = this.getY(t), _n
								.z = this.getZ(t), _n.applyMatrix4(e), this
								.setXYZ(t, _n.x, _n.y, _n.z);
							return this
						}
					}, {
						key: "applyNormalMatrix",
						value: function(e) {
							for (var t = 0, n = this.count; t < n; t++) _n
								.x = this.getX(t), _n.y = this.getY(t), _n
								.z = this.getZ(t), _n.applyNormalMatrix(e),
								this.setXYZ(t, _n.x, _n.y, _n.z);
							return this
						}
					}, {
						key: "transformDirection",
						value: function(e) {
							for (var t = 0, n = this.count; t < n; t++) _n
								.x = this.getX(t), _n.y = this.getY(t), _n
								.z = this.getZ(t), _n.transformDirection(e),
								this.setXYZ(t, _n.x, _n.y, _n.z);
							return this
						}
					}, {
						key: "set",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0;
							return this.array.set(e, t), this
						}
					}, {
						key: "getX",
						value: function(e) {
							return this.array[e * this.itemSize]
						}
					}, {
						key: "setX",
						value: function(e, t) {
							return this.array[e * this.itemSize] = t, this
						}
					}, {
						key: "getY",
						value: function(e) {
							return this.array[e * this.itemSize + 1]
						}
					}, {
						key: "setY",
						value: function(e, t) {
							return this.array[e * this.itemSize + 1] = t,
								this
						}
					}, {
						key: "getZ",
						value: function(e) {
							return this.array[e * this.itemSize + 2]
						}
					}, {
						key: "setZ",
						value: function(e, t) {
							return this.array[e * this.itemSize + 2] = t,
								this
						}
					}, {
						key: "getW",
						value: function(e) {
							return this.array[e * this.itemSize + 3]
						}
					}, {
						key: "setW",
						value: function(e, t) {
							return this.array[e * this.itemSize + 3] = t,
								this
						}
					}, {
						key: "setXY",
						value: function(e, t, n) {
							return e *= this.itemSize, this.array[e + 0] =
								t, this.array[e + 1] = n, this
						}
					}, {
						key: "setXYZ",
						value: function(e, t, n, r) {
							return e *= this.itemSize, this.array[e + 0] =
								t, this.array[e + 1] = n, this.array[e +
								2] = r, this
						}
					}, {
						key: "setXYZW",
						value: function(e, t, n, r, i) {
							return e *= this.itemSize, this.array[e + 0] =
								t, this.array[e + 1] = n, this.array[e +
								2] = r, this.array[e + 3] = i, this
						}
					}, {
						key: "onUpload",
						value: function(e) {
							return this.onUploadCallback = e, this
						}
					}, {
						key: "clone",
						value: function() {
							return new this.constructor(this.array, this
								.itemSize).copy(this)
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = {
								itemSize: this.itemSize,
								type: this.array.constructor.name,
								array: Array.prototype.slice.call(this
									.array),
								normalized: this.normalized
							};
							return "" !== this.name && (e.name = this.name),
								this.usage !== me && (e.usage = this.usage),
								0 === this.updateRange.offset && -1 === this
								.updateRange.count || (e.updateRange = this
									.updateRange), e
						}
					}]), e
				}();
			wn.prototype.isBufferAttribute = !0;
			var Mn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Int8Array(e), r, i)
					}
					return n
				}(wn),
				Sn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Uint8Array(e), r,
							i)
					}
					return n
				}(wn),
				Tn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Uint8ClampedArray(
							e), r, i)
					}
					return n
				}(wn),
				En = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Int16Array(e), r,
							i)
					}
					return n
				}(wn),
				An = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Uint16Array(e), r,
							i)
					}
					return n
				}(wn),
				Ln = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Int32Array(e), r,
							i)
					}
					return n
				}(wn),
				kn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Uint32Array(e), r,
							i)
					}
					return n
				}(wn),
				Rn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Uint16Array(e), r,
							i)
					}
					return n
				}(wn);
			Rn.prototype.isFloat16BufferAttribute = !0;
			var Cn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Float32Array(e), r,
							i)
					}
					return n
				}(wn),
				Pn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						return (0, g.default)(this, n), t.call(this, new Float64Array(e), r,
							i)
					}
					return n
				}(wn);

			function In(e) {
				if (0 === e.length) return -1 / 0;
				for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
				return t
			}
			var Dn = {
				Int8Array: Int8Array,
				Uint8Array: Uint8Array,
				Uint8ClampedArray: Uint8ClampedArray,
				Int16Array: Int16Array,
				Uint16Array: Uint16Array,
				Int32Array: Int32Array,
				Uint32Array: Uint32Array,
				Float32Array: Float32Array,
				Float64Array: Float64Array
			};

			function Nn(e, t) {
				return new Dn[e](t)
			}
			var On = 0,
				Bn = new wt,
				zn = new Xt,
				Fn = new je,
				Hn = new Ye,
				Un = new Ye,
				Gn = new je,
				Vn = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), e = t.call(this), Object
							.defineProperty((0, f.default)(e), "id", {
								value: On++
							}), e.uuid = Te(), e.name = "", e.type = "BufferGeometry", e
							.index = null, e.attributes = {}, e.morphAttributes = {}, e
							.morphTargetsRelative = !1, e.groups = [], e.boundingBox = null,
							e.boundingSphere = null, e.drawRange = {
								start: 0,
								count: 1 / 0
							}, e.userData = {}, e
					}
					return (0, y.default)(n, [{
						key: "getIndex",
						value: function() {
							return this.index
						}
					}, {
						key: "setIndex",
						value: function(e) {
							return Array.isArray(e) ? this.index = new(In(
									e) > 65535 ? kn : An)(e, 1) : this
								.index = e, this
						}
					}, {
						key: "getAttribute",
						value: function(e) {
							return this.attributes[e]
						}
					}, {
						key: "setAttribute",
						value: function(e, t) {
							return this.attributes[e] = t, this
						}
					}, {
						key: "deleteAttribute",
						value: function(e) {
							return delete this.attributes[e], this
						}
					}, {
						key: "hasAttribute",
						value: function(e) {
							return void 0 !== this.attributes[e]
						}
					}, {
						key: "addGroup",
						value: function(e, t) {
							var n = arguments.length > 2 && void 0 !==
								arguments[2] ? arguments[2] : 0;
							this.groups.push({
								start: e,
								count: t,
								materialIndex: n
							})
						}
					}, {
						key: "clearGroups",
						value: function() {
							this.groups = []
						}
					}, {
						key: "setDrawRange",
						value: function(e, t) {
							this.drawRange.start = e, this.drawRange.count =
								t
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							var t = this.attributes.position;
							void 0 !== t && (t.applyMatrix4(e), t
								.needsUpdate = !0);
							var n = this.attributes.normal;
							if (void 0 !== n) {
								var r = (new Ne).getNormalMatrix(e);
								n.applyNormalMatrix(r), n.needsUpdate = !0
							}
							var i = this.attributes.tangent;
							return void 0 !== i && (i.transformDirection(e),
									i.needsUpdate = !0), null !== this
								.boundingBox && this.computeBoundingBox(),
								null !== this.boundingSphere && this
								.computeBoundingSphere(), this
						}
					}, {
						key: "applyQuaternion",
						value: function(e) {
							return Bn.makeRotationFromQuaternion(e), this
								.applyMatrix4(Bn), this
						}
					}, {
						key: "rotateX",
						value: function(e) {
							return Bn.makeRotationX(e), this.applyMatrix4(
								Bn), this
						}
					}, {
						key: "rotateY",
						value: function(e) {
							return Bn.makeRotationY(e), this.applyMatrix4(
								Bn), this
						}
					}, {
						key: "rotateZ",
						value: function(e) {
							return Bn.makeRotationZ(e), this.applyMatrix4(
								Bn), this
						}
					}, {
						key: "translate",
						value: function(e, t, n) {
							return Bn.makeTranslation(e, t, n), this
								.applyMatrix4(Bn), this
						}
					}, {
						key: "scale",
						value: function(e, t, n) {
							return Bn.makeScale(e, t, n), this.applyMatrix4(
								Bn), this
						}
					}, {
						key: "lookAt",
						value: function(e) {
							return zn.lookAt(e), zn.updateMatrix(), this
								.applyMatrix4(zn.matrix), this
						}
					}, {
						key: "center",
						value: function() {
							return this.computeBoundingBox(), this
								.boundingBox.getCenter(Fn).negate(), this
								.translate(Fn.x, Fn.y, Fn.z), this
						}
					}, {
						key: "setFromPoints",
						value: function(e) {
							for (var t = [], n = 0, r = e.length; n <
								r; n++) {
								var i = e[n];
								t.push(i.x, i.y, i.z || 0)
							}
							return this.setAttribute("position", new Cn(t,
								3)), this
						}
					}, {
						key: "computeBoundingBox",
						value: function() {
							null === this.boundingBox && (this.boundingBox =
								new Ye);
							var e = this.attributes.position,
								t = this.morphAttributes.position;
							if (e && e.isGLBufferAttribute) return console
								.error(
									'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
									this), void this.boundingBox.set(
									new je(-1 / 0, -1 / 0, -1 / 0),
									new je(1 / 0, 1 / 0, 1 / 0));
							if (void 0 !== e) {
								if (this.boundingBox.setFromBufferAttribute(
										e), t)
									for (var n = 0, r = t.length; n <
										r; n++) {
										var i = t[n];
										Hn.setFromBufferAttribute(i), this
											.morphTargetsRelative ? (Gn
												.addVectors(this.boundingBox
													.min, Hn.min), this
												.boundingBox.expandByPoint(
													Gn), Gn.addVectors(this
													.boundingBox.max, Hn.max
													), this.boundingBox
												.expandByPoint(Gn)) : (this
												.boundingBox.expandByPoint(
													Hn.min), this
												.boundingBox.expandByPoint(
													Hn.max))
									}
							} else this.boundingBox.makeEmpty();
							(isNaN(this.boundingBox.min.x) || isNaN(this
								.boundingBox.min.y) || isNaN(this
								.boundingBox.min.z)) && console.error(
								'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
								this)
						}
					}, {
						key: "computeBoundingSphere",
						value: function() {
							null === this.boundingSphere && (this
								.boundingSphere = new ft);
							var e = this.attributes.position,
								t = this.morphAttributes.position;
							if (e && e.isGLBufferAttribute) return console
								.error(
									'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
									this), void this.boundingSphere.set(
									new je, 1 / 0);
							if (e) {
								var n = this.boundingSphere.center;
								if (Hn.setFromBufferAttribute(e), t)
									for (var r = 0, i = t.length; r <
										i; r++) {
										var a = t[r];
										Un.setFromBufferAttribute(a), this
											.morphTargetsRelative ? (Gn
												.addVectors(Hn.min, Un.min),
												Hn.expandByPoint(Gn), Gn
												.addVectors(Hn.max, Un.max),
												Hn.expandByPoint(Gn)) : (Hn
												.expandByPoint(Un.min), Hn
												.expandByPoint(Un.max))
									}
								Hn.getCenter(n);
								for (var o = 0, s = 0, l = e.count; s <
									l; s++) Gn.fromBufferAttribute(e, s),
									o = Math.max(o, n.distanceToSquared(
									Gn));
								if (t)
									for (var u = 0, c = t.length; u <
										c; u++)
										for (var h = t[u], d = this
												.morphTargetsRelative, f =
												0, p = h.count; f < p; f++)
											Gn.fromBufferAttribute(h, f),
											d && (Fn.fromBufferAttribute(e,
												f), Gn.add(Fn)), o = Math
											.max(o, n.distanceToSquared(
											Gn));
								this.boundingSphere.radius = Math.sqrt(o),
									isNaN(this.boundingSphere.radius) &&
									console.error(
										'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
										this)
							}
						}
					}, {
						key: "computeFaceNormals",
						value: function() {}
					}, {
						key: "computeTangents",
						value: function() {
							var e = this.index,
								t = this.attributes;
							if (null !== e && void 0 !== t.position &&
								void 0 !== t.normal && void 0 !== t.uv) {
								var n = e.array,
									r = t.position.array,
									i = t.normal.array,
									a = t.uv.array,
									o = r.length / 3;
								void 0 === t.tangent && this.setAttribute(
									"tangent", new wn(new Float32Array(
										4 * o), 4));
								for (var s = t.tangent.array, l = [],
									u = [], c = 0; c < o; c++) l[c] =
									new je, u[c] = new je;
								var h = new je,
									d = new je,
									f = new je,
									p = new Ie,
									v = new Ie,
									m = new Ie,
									g = new je,
									y = new je,
									x = this.groups;
								0 === x.length && (x = [{
									start: 0,
									count: n.length
								}]);
								for (var _ = 0, b = x.length; _ < b; ++_)
									for (var w = x[_], M = w.start, S = M,
											T = M + w.count; S < T; S += 3)
										O(n[S + 0], n[S + 1], n[S + 2]);
								for (var E = new je, A = new je, L = new je,
										k = new je, R = 0, C = x.length; R <
									C; ++R)
									for (var P = x[R], I = P.start, D = I,
											N = I + P.count; D < N; D += 3)
										B(n[D + 0]), B(n[D + 1]), B(n[D +
											2])
							} else console.error(
								"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
								);

							function O(e, t, n) {
								h.fromArray(r, 3 * e), d.fromArray(r, 3 *
									t), f.fromArray(r, 3 * n), p.fromArray(
										a, 2 * e), v.fromArray(a, 2 * t), m
									.fromArray(a, 2 * n), d.sub(h), f.sub(
									h), v.sub(p), m.sub(p);
								var i = 1 / (v.x * m.y - m.x * v.y);
								isFinite(i) && (g.copy(d).multiplyScalar(m
										.y).addScaledVector(f, -v.y)
									.multiplyScalar(i), y.copy(f)
									.multiplyScalar(v.x)
									.addScaledVector(d, -m.x)
									.multiplyScalar(i), l[e].add(g), l[
										t].add(g), l[n].add(g), u[e]
									.add(y), u[t].add(y), u[n].add(y))
							}

							function B(e) {
								L.fromArray(i, 3 * e), k.copy(L);
								var t = l[e];
								E.copy(t), E.sub(L.multiplyScalar(L.dot(t)))
									.normalize(), A.crossVectors(k, t);
								var n = A.dot(u[e]) < 0 ? -1 : 1;
								s[4 * e] = E.x, s[4 * e + 1] = E.y, s[4 *
									e + 2] = E.z, s[4 * e + 3] = n
							}
						}
					}, {
						key: "computeVertexNormals",
						value: function() {
							var e = this.index,
								t = this.getAttribute("position");
							if (void 0 !== t) {
								var n = this.getAttribute("normal");
								if (void 0 === n) n = new wn(
										new Float32Array(3 * t.count), 3),
									this.setAttribute("normal", n);
								else
									for (var r = 0, i = n.count; r < i; r++)
										n.setXYZ(r, 0, 0, 0);
								var a = new je,
									o = new je,
									s = new je,
									l = new je,
									u = new je,
									c = new je,
									h = new je,
									d = new je;
								if (e)
									for (var f = 0, p = e.count; f < p; f +=
										3) {
										var v = e.getX(f + 0),
											m = e.getX(f + 1),
											g = e.getX(f + 2);
										a.fromBufferAttribute(t, v), o
											.fromBufferAttribute(t, m), s
											.fromBufferAttribute(t, g), h
											.subVectors(s, o), d.subVectors(
												a, o), h.cross(d), l
											.fromBufferAttribute(n, v), u
											.fromBufferAttribute(n, m), c
											.fromBufferAttribute(n, g), l
											.add(h), u.add(h), c.add(h), n
											.setXYZ(v, l.x, l.y, l.z), n
											.setXYZ(m, u.x, u.y, u.z), n
											.setXYZ(g, c.x, c.y, c.z)
									} else
										for (var y = 0, x = t.count; y <
											x; y += 3) a
											.fromBufferAttribute(t, y + 0),
											o.fromBufferAttribute(t, y + 1),
											s.fromBufferAttribute(t, y + 2),
											h.subVectors(s, o), d
											.subVectors(a, o), h.cross(d), n
											.setXYZ(y + 0, h.x, h.y, h.z), n
											.setXYZ(y + 1, h.x, h.y, h.z), n
											.setXYZ(y + 2, h.x, h.y, h.z);
								this.normalizeNormals(), n.needsUpdate = !0
							}
						}
					}, {
						key: "merge",
						value: function(e, t) {
							if (e && e.isBufferGeometry) {
								void 0 === t && (t = 0, console.warn(
									"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
									));
								var n = this.attributes;
								for (var r in n)
									if (void 0 !== e.attributes[r])
										for (var i = n[r].array, a = e
												.attributes[r], o = a.array,
												s = a.itemSize * t, l = Math
												.min(o.length, i.length -
												s), u = 0, c = s; u <
											l; u++, c++) i[c] = o[u];
								return this
							}
							console.error(
								"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
								e)
						}
					}, {
						key: "normalizeNormals",
						value: function() {
							for (var e = this.attributes.normal, t = 0, n =
									e.count; t < n; t++) Gn
								.fromBufferAttribute(e, t), Gn.normalize(),
								e.setXYZ(t, Gn.x, Gn.y, Gn.z)
						}
					}, {
						key: "toNonIndexed",
						value: function() {
							function e(e, t) {
								for (var n = e.array, r = e.itemSize, i = e
										.normalized, a = new n.constructor(t
											.length * r), o = 0, s = 0, l =
										0, u = t.length; l < u; l++) {
									o = t[l] * r;
									for (var c = 0; c < r; c++) a[s++] = n[
										o++]
								}
								return new wn(a, r, i)
							}
							if (null === this.index) return console.warn(
								"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
								), this;
							var t = new n,
								r = this.index.array,
								i = this.attributes;
							for (var a in i) {
								var o = e(i[a], r);
								t.setAttribute(a, o)
							}
							var s = this.morphAttributes;
							for (var l in s) {
								for (var u = [], c = s[l], h = 0, d = c
										.length; h < d; h++) {
									var f = e(c[h], r);
									u.push(f)
								}
								t.morphAttributes[l] = u
							}
							t.morphTargetsRelative = this
								.morphTargetsRelative;
							for (var p = this.groups, v = 0, m = p
								.length; v < m; v++) {
								var g = p[v];
								t.addGroup(g.start, g.count, g
									.materialIndex)
							}
							return t
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = {
								metadata: {
									version: 4.5,
									type: "BufferGeometry",
									generator: "BufferGeometry.toJSON"
								}
							};
							if (e.uuid = this.uuid, e.type = this.type,
								"" !== this.name && (e.name = this.name),
								Object.keys(this.userData).length > 0 && (e
									.userData = this.userData), void 0 !==
								this.parameters) {
								var t = this.parameters;
								for (var n in t) void 0 !== t[n] && (e[n] =
									t[n]);
								return e
							}
							e.data = {
								attributes: {}
							};
							var r = this.index;
							null !== r && (e.data.index = {
								type: r.array.constructor.name,
								array: Array.prototype.slice.call(r
									.array)
							});
							var i = this.attributes;
							for (var a in i) {
								var o = i[a];
								e.data.attributes[a] = o.toJSON(e.data)
							}
							var s = {},
								l = !1;
							for (var u in this.morphAttributes) {
								for (var c = this.morphAttributes[u],
									h = [], d = 0, f = c.length; d <
									f; d++) {
									var p = c[d];
									h.push(p.toJSON(e.data))
								}
								h.length > 0 && (s[u] = h, l = !0)
							}
							l && (e.data.morphAttributes = s, e.data
								.morphTargetsRelative = this
								.morphTargetsRelative);
							var v = this.groups;
							v.length > 0 && (e.data.groups = JSON.parse(JSON
								.stringify(v)));
							var m = this.boundingSphere;
							return null !== m && (e.data.boundingSphere = {
								center: m.center.toArray(),
								radius: m.radius
							}), e
						}
					}, {
						key: "clone",
						value: function() {
							return (new n).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							this.index = null, this.attributes = {}, this
								.morphAttributes = {}, this.groups = [],
								this.boundingBox = null, this
								.boundingSphere = null;
							var t = {};
							this.name = e.name;
							var n = e.index;
							null !== n && this.setIndex(n.clone(t));
							var r = e.attributes;
							for (var i in r) {
								var a = r[i];
								this.setAttribute(i, a.clone(t))
							}
							var o = e.morphAttributes;
							for (var s in o) {
								for (var l = [], u = o[s], c = 0, h = u
										.length; c < h; c++) l.push(u[c]
									.clone(t));
								this.morphAttributes[s] = l
							}
							this.morphTargetsRelative = e
								.morphTargetsRelative;
							for (var d = e.groups, f = 0, p = d.length; f <
								p; f++) {
								var v = d[f];
								this.addGroup(v.start, v.count, v
									.materialIndex)
							}
							var m = e.boundingBox;
							null !== m && (this.boundingBox = m.clone());
							var g = e.boundingSphere;
							return null !== g && (this.boundingSphere = g
									.clone()), this.drawRange.start = e
								.drawRange.start, this.drawRange.count = e
								.drawRange.count, this.userData = e
								.userData, this
						}
					}, {
						key: "dispose",
						value: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}]), n
				}(xe);
			Vn.prototype.isBufferGeometry = !0;
			var Wn = new wt,
				jn = new bt,
				qn = new ft,
				Xn = new je,
				Yn = new je,
				$n = new je,
				Zn = new je,
				Jn = new je,
				Qn = new je,
				Kn = new je,
				er = new je,
				tr = new je,
				nr = new Ie,
				rr = new Ie,
				ir = new Ie,
				ar = new je,
				or = new je,
				sr = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new Vn,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new xn;
						return (0, g.default)(this, n), (e = t.call(this)).type = "Mesh", e
							.geometry = r, e.material = i, e.updateMorphTargets(), e
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), void 0 !== e.morphTargetInfluences && (
									this.morphTargetInfluences = e
									.morphTargetInfluences.slice()),
								void 0 !== e.morphTargetDictionary && (this
									.morphTargetDictionary = Object
									.assign({}, e.morphTargetDictionary)),
								this.material = e.material, this.geometry =
								e.geometry, this
						}
					}, {
						key: "updateMorphTargets",
						value: function() {
							var e = this.geometry;
							if (e.isBufferGeometry) {
								var t = e.morphAttributes,
									n = Object.keys(t);
								if (n.length > 0) {
									var r = t[n[0]];
									if (void 0 !== r) {
										this.morphTargetInfluences = [],
											this.morphTargetDictionary = {};
										for (var i = 0, a = r.length; i <
											a; i++) {
											var o = r[i].name || String(i);
											this.morphTargetInfluences.push(
													0), this
												.morphTargetDictionary[o] =
												i
										}
									}
								}
							} else {
								var s = e.morphTargets;
								void 0 !== s && s.length > 0 && console
									.error(
										"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
										)
							}
						}
					}, {
						key: "raycast",
						value: function(e, t) {
							var n, r = this.geometry,
								i = this.material,
								a = this.matrixWorld;
							if (void 0 !== i && (null === r
									.boundingSphere && r
									.computeBoundingSphere(), qn.copy(r
										.boundingSphere), qn.applyMatrix4(
									a), !1 !== e.ray.intersectsSphere(qn) &&
									(Wn.copy(a).invert(), jn.copy(e.ray)
										.applyMatrix4(Wn), null === r
										.boundingBox || !1 !== jn
										.intersectsBox(r.boundingBox))))
								if (r.isBufferGeometry) {
									var o = r.index,
										s = r.attributes.position,
										l = r.morphAttributes.position,
										u = r.morphTargetsRelative,
										c = r.attributes.uv,
										h = r.attributes.uv2,
										d = r.groups,
										f = r.drawRange;
									if (null !== o)
										if (Array.isArray(i))
											for (var p = 0, v = d
												.length; p < v; p++)
												for (var m = d[p], g = i[m
															.materialIndex],
														y = Math.max(m
															.start, f.start
															), x = Math.min(
															m.start + m
															.count, f
															.start + f.count
															); y < x; y +=
													3) {
													var _ = o.getX(y),
														b = o.getX(y + 1),
														w = o.getX(y + 2);
													(n = lr(this, g, e, jn,
														s, l, u, c, h,
														_, b, w)) && (n
														.faceIndex = Math
														.floor(y / 3), n
														.face
														.materialIndex = m
														.materialIndex, t
														.push(n))
												} else
													for (var M = Math.max(0,
																f.start),
															S = Math.min(o
																.count, f
																.start + f
																.count); M <
														S; M += 3) {
														var T = o.getX(M),
															E = o.getX(M +
																1),
															A = o.getX(M +
																2);
														(n = lr(this, i, e,
															jn, s, l, u,
															c, h, T, E,
															A)) && (n
															.faceIndex =
															Math.floor(M /
																3), t.push(
																n))
													} else if (void 0 !== s)
														if (Array.isArray(
															i))
															for (var L = 0,
																	k = d
																	.length; L <
																k; L++)
																for (var R =
																		d[
																		L],
																		C =
																		i[R
																			.materialIndex],
																		P =
																		Math
																		.max(
																			R
																			.start,
																			f
																			.start
																			),
																		I =
																		Math
																		.min(
																			R
																			.start +
																			R
																			.count,
																			f
																			.start +
																			f
																			.count
																			); P <
																	I; P +=
																	3)(n =
																		lr(this,
																			C,
																			e,
																			jn,
																			s,
																			l,
																			u,
																			c,
																			h,
																			P,
																			P +
																			1,
																			P +
																			2
																			)
																		) &&
																	(n.faceIndex =
																		Math
																		.floor(
																			P /
																			3
																			),
																		n
																		.face
																		.materialIndex =
																		R
																		.materialIndex,
																		t
																		.push(
																			n
																			)
																		);
														else
															for (var D =
																	Math
																	.max(0,
																		f
																		.start
																		),
																	N = Math
																	.min(s
																		.count,
																		f
																		.start +
																		f
																		.count
																		); D <
																N; D += 3)(
																	n = lr(
																		this,
																		i,
																		e,
																		jn,
																		s,
																		l,
																		u,
																		c,
																		h,
																		D,
																		D +
																		1,
																		D +
																		2)
																	) && (n
																	.faceIndex =
																	Math
																	.floor(
																		D /
																		3),
																	t.push(
																		n))
								} else r.isGeometry && console.error(
									"THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
						}
					}]), n
				}(Xt);

			function lr(e, t, n, r, i, a, o, s, l, u, c, h) {
				Xn.fromBufferAttribute(i, u), Yn.fromBufferAttribute(i, c), $n
					.fromBufferAttribute(i, h);
				var d = e.morphTargetInfluences;
				if (t.morphTargets && a && d) {
					Kn.set(0, 0, 0), er.set(0, 0, 0), tr.set(0, 0, 0);
					for (var f = 0, p = a.length; f < p; f++) {
						var v = d[f],
							m = a[f];
						0 !== v && (Zn.fromBufferAttribute(m, u), Jn.fromBufferAttribute(m,
							c), Qn.fromBufferAttribute(m, h), o ? (Kn
							.addScaledVector(Zn, v), er.addScaledVector(Jn, v), tr
							.addScaledVector(Qn, v)) : (Kn.addScaledVector(Zn.sub(
								Xn), v), er.addScaledVector(Jn.sub(Yn), v), tr
							.addScaledVector(Qn.sub($n), v)))
					}
					Xn.add(Kn), Yn.add(er), $n.add(tr)
				}
				e.isSkinnedMesh && (e.boneTransform(u, Xn), e.boneTransform(c, Yn), e
					.boneTransform(h, $n));
				var g = function(e, t, n, r, i, a, o, s) {
					if (null === (1 === t.side ? r.intersectTriangle(o, a, i, !0, s) : r
							.intersectTriangle(i, a, o, 2 !== t.side, s))) return null;
					or.copy(s), or.applyMatrix4(e.matrixWorld);
					var l = n.ray.origin.distanceTo(or);
					return l < n.near || l > n.far ? null : {
						distance: l,
						point: or.clone(),
						object: e
					}
				}(e, t, n, r, Xn, Yn, $n, ar);
				if (g) {
					s && (nr.fromBufferAttribute(s, u), rr.fromBufferAttribute(s, c), ir
						.fromBufferAttribute(s, h), g.uv = un.getUV(ar, Xn, Yn, $n, nr,
							rr, ir, new Ie)), l && (nr.fromBufferAttribute(l, u), rr
						.fromBufferAttribute(l, c), ir.fromBufferAttribute(l, h), g
						.uv2 = un.getUV(ar, Xn, Yn, $n, nr, rr, ir, new Ie));
					var y = {
						a: u,
						b: c,
						c: h,
						normal: new je,
						materialIndex: 0
					};
					un.getNormal(Xn, Yn, $n, y.normal), g.face = y
				}
				return g
			}
			sr.prototype.isMesh = !0;
			var ur = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : 1,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 1,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1,
						s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
							4] : 1,
						l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
							5] : 1;
					(0, g.default)(this, n), (e = t.call(this)).type = "BoxGeometry", e
						.parameters = {
							width: r,
							height: i,
							depth: a,
							widthSegments: o,
							heightSegments: s,
							depthSegments: l
						};
					var u = (0, f.default)(e);
					o = Math.floor(o), s = Math.floor(s), l = Math.floor(l);
					var c = [],
						h = [],
						d = [],
						p = [],
						v = 0,
						m = 0;

					function y(e, t, n, r, i, a, o, s, l, f, g) {
						for (var y = a / l, x = o / f, _ = a / 2, b = o / 2, w = s / 2,
								M = l + 1, S = f + 1, T = 0, E = 0, A = new je, L =
								0; L < S; L++)
							for (var k = L * x - b, R = 0; R < M; R++) {
								var C = R * y - _;
								A[e] = C * r, A[t] = k * i, A[n] = w, h.push(A.x, A.y, A
										.z), A[e] = 0, A[t] = 0, A[n] = s > 0 ? 1 : -1,
									d.push(A.x, A.y, A.z), p.push(R / l), p.push(1 - L /
										f), T += 1
							}
						for (var P = 0; P < f; P++)
							for (var I = 0; I < l; I++) {
								var D = v + I + M * P,
									N = v + I + M * (P + 1),
									O = v + (I + 1) + M * (P + 1),
									B = v + (I + 1) + M * P;
								c.push(D, N, B), c.push(N, O, B), E += 6
							}
						u.addGroup(m, E, g), m += E, v += T
					}
					return y("z", "y", "x", -1, -1, a, i, r, l, s, 0), y("z", "y", "x",
						1, -1, a, i, -r, l, s, 1), y("x", "z", "y", 1, 1, r, a, i,
						o, l, 2), y("x", "z", "y", 1, -1, r, a, -i, o, l, 3), y("x",
						"y", "z", 1, -1, r, i, a, o, s, 4), y("x", "y", "z", -1, -1,
						r, i, -a, o, s, 5), e.setIndex(c), e.setAttribute(
						"position", new Cn(h, 3)), e.setAttribute("normal", new Cn(
						d, 3)), e.setAttribute("uv", new Cn(p, 2)), e
				}
				return n
			}(Vn);

			function cr(e) {
				var t = {};
				for (var n in e)
					for (var r in t[n] = {}, e[n]) {
						var i = e[n][r];
						i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i
								.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion
								) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i
							.slice() : t[n][r] = i
					}
				return t
			}

			function hr(e) {
				for (var t = {}, n = 0; n < e.length; n++) {
					var r = cr(e[n]);
					for (var i in r) t[i] = r[i]
				}
				return t
			}
			var dr = {
					clone: cr,
					merge: hr
				},
				fr = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this)).type =
							"ShaderMaterial", r.defines = {}, r.uniforms = {}, r
							.vertexShader =
							"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
							r.fragmentShader =
							"void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
							r.linewidth = 1, r.wireframe = !1, r.wireframeLinewidth = 1, r
							.fog = !1, r.lights = !1, r.clipping = !1, r.morphTargets = !1,
							r.morphNormals = !1, r.extensions = {
								derivatives: !1,
								fragDepth: !1,
								drawBuffers: !1,
								shaderTextureLOD: !1
							}, r.defaultAttributeValues = {
								color: [1, 1, 1],
								uv: [0, 0],
								uv2: [0, 0]
							}, r.index0AttributeName = void 0, r.uniformsNeedUpdate = !1, r
							.glslVersion = null, void 0 !== e && (void 0 !== e.attributes &&
								console.error(
									"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
									), r.setValues(e)), r
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.fragmentShader = e.fragmentShader,
								this.vertexShader = e.vertexShader, this
								.uniforms = cr(e.uniforms), this.defines =
								Object.assign({}, e.defines), this
								.wireframe = e.wireframe, this
								.wireframeLinewidth = e.wireframeLinewidth,
								this.lights = e.lights, this.clipping = e
								.clipping, this.morphTargets = e
								.morphTargets, this.morphNormals = e
								.morphNormals, this.extensions = Object
								.assign({}, e.extensions), this
								.glslVersion = e.glslVersion, this
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this,
								e);
							for (var r in t.glslVersion = this.glslVersion,
									t.uniforms = {}, this.uniforms) {
								var i = this.uniforms[r].value;
								i && i.isTexture ? t.uniforms[r] = {
									type: "t",
									value: i.toJSON(e).uuid
								} : i && i.isColor ? t.uniforms[r] = {
									type: "c",
									value: i.getHex()
								} : i && i.isVector2 ? t.uniforms[r] = {
									type: "v2",
									value: i.toArray()
								} : i && i.isVector3 ? t.uniforms[r] = {
									type: "v3",
									value: i.toArray()
								} : i && i.isVector4 ? t.uniforms[r] = {
									type: "v4",
									value: i.toArray()
								} : i && i.isMatrix3 ? t.uniforms[r] = {
									type: "m3",
									value: i.toArray()
								} : i && i.isMatrix4 ? t.uniforms[r] = {
									type: "m4",
									value: i.toArray()
								} : t.uniforms[r] = {
									value: i
								}
							}
							Object.keys(this.defines).length > 0 && (t
									.defines = this.defines), t
								.vertexShader = this.vertexShader, t
								.fragmentShader = this.fragmentShader;
							var a = {};
							for (var o in this.extensions) !0 === this
								.extensions[o] && (a[o] = !0);
							return Object.keys(a).length > 0 && (t
								.extensions = a), t
						}
					}]), n
				}(hn);
			fr.prototype.isShaderMaterial = !0;
			var pr = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e;
					return (0, g.default)(this, n), (e = t.call(this)).type = "Camera",
						e.matrixWorldInverse = new wt, e.projectionMatrix = new wt, e
						.projectionMatrixInverse = new wt, e
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e, t) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this, e,
								t), this.matrixWorldInverse.copy(e
								.matrixWorldInverse), this
							.projectionMatrix.copy(e.projectionMatrix),
							this.projectionMatrixInverse.copy(e
								.projectionMatrixInverse), this
					}
				}, {
					key: "getWorldDirection",
					value: function(e) {
						void 0 === e && (console.warn(
							"THREE.Camera: .getWorldDirection() target is now required"
							), e = new je), this.updateWorldMatrix(!
							0, !1);
						var t = this.matrixWorld.elements;
						return e.set(-t[8], -t[9], -t[10]).normalize()
					}
				}, {
					key: "updateMatrixWorld",
					value: function(e) {
						(0, h.default)((0, m.default)(n.prototype),
							"updateMatrixWorld", this).call(this, e),
							this.matrixWorldInverse.copy(this
								.matrixWorld).invert()
					}
				}, {
					key: "updateWorldMatrix",
					value: function(e, t) {
						(0, h.default)((0, m.default)(n.prototype),
							"updateWorldMatrix", this).call(this, e, t),
							this.matrixWorldInverse.copy(this
								.matrixWorld).invert()
					}
				}, {
					key: "clone",
					value: function() {
						return (new this.constructor).copy(this)
					}
				}]), n
			}(Xt);
			pr.prototype.isCamera = !0;
			var vr = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : 50,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : .1,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 2e3;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"PerspectiveCamera", e.fov = r, e.zoom = 1, e.near = a, e.far =
						o, e.focus = 10, e.aspect = i, e.view = null, e.filmGauge = 35,
						e.filmOffset = 0, e.updateProjectionMatrix(), e
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e, t) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this, e,
								t), this.fov = e.fov, this.zoom = e
							.zoom, this.near = e.near, this.far = e.far,
							this.focus = e.focus, this.aspect = e
							.aspect, this.view = null === e.view ?
							null : Object.assign({}, e.view), this
							.filmGauge = e.filmGauge, this.filmOffset =
							e.filmOffset, this
					}
				}, {
					key: "setFocalLength",
					value: function(e) {
						var t = .5 * this.getFilmHeight() / e;
						this.fov = 2 * Se * Math.atan(t), this
							.updateProjectionMatrix()
					}
				}, {
					key: "getFocalLength",
					value: function() {
						var e = Math.tan(.5 * Me * this.fov);
						return .5 * this.getFilmHeight() / e
					}
				}, {
					key: "getEffectiveFOV",
					value: function() {
						return 2 * Se * Math.atan(Math.tan(.5 * Me *
							this.fov) / this.zoom)
					}
				}, {
					key: "getFilmWidth",
					value: function() {
						return this.filmGauge * Math.min(this.aspect, 1)
					}
				}, {
					key: "getFilmHeight",
					value: function() {
						return this.filmGauge / Math.max(this.aspect, 1)
					}
				}, {
					key: "setViewOffset",
					value: function(e, t, n, r, i, a) {
						this.aspect = e / t, null === this.view && (this
								.view = {
									enabled: !0,
									fullWidth: 1,
									fullHeight: 1,
									offsetX: 0,
									offsetY: 0,
									width: 1,
									height: 1
								}), this.view.enabled = !0, this.view
							.fullWidth = e, this.view.fullHeight = t,
							this.view.offsetX = n, this.view.offsetY =
							r, this.view.width = i, this.view.height =
							a, this.updateProjectionMatrix()
					}
				}, {
					key: "clearViewOffset",
					value: function() {
						null !== this.view && (this.view.enabled = !1),
							this.updateProjectionMatrix()
					}
				}, {
					key: "updateProjectionMatrix",
					value: function() {
						var e = this.near,
							t = e * Math.tan(.5 * Me * this.fov) / this
							.zoom,
							n = 2 * t,
							r = this.aspect * n,
							i = -.5 * r,
							a = this.view;
						if (null !== this.view && this.view.enabled) {
							var o = a.fullWidth,
								s = a.fullHeight;
							i += a.offsetX * r / o, t -= a.offsetY * n /
								s, r *= a.width / o, n *= a.height / s
						}
						var l = this.filmOffset;
						0 !== l && (i += e * l / this.getFilmWidth()),
							this.projectionMatrix.makePerspective(i, i +
								r, t, t - n, e, this.far), this
							.projectionMatrixInverse.copy(this
								.projectionMatrix).invert()
					}
				}, {
					key: "toJSON",
					value: function(e) {
						var t = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this,
							e);
						return t.object.fov = this.fov, t.object.zoom =
							this.zoom, t.object.near = this.near, t
							.object.far = this.far, t.object.focus =
							this.focus, t.object.aspect = this.aspect,
							null !== this.view && (t.object.view =
								Object.assign({}, this.view)), t.object
							.filmGauge = this.filmGauge, t.object
							.filmOffset = this.filmOffset, t
					}
				}]), n
			}(pr);
			vr.prototype.isPerspectiveCamera = !0;
			var mr = 90,
				gr = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						if ((0, g.default)(this, n), (a = t.call(this)).type = "CubeCamera",
							!0 !== i.isWebGLCubeRenderTarget) return (0, v.default)(a,
							void console.error(
								"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
								));
						a.renderTarget = i;
						var o = new vr(mr, 1, e, r);
						o.layers = a.layers, o.up.set(0, -1, 0), o.lookAt(new je(1, 0, 0)),
							a.add(o);
						var s = new vr(mr, 1, e, r);
						s.layers = a.layers, s.up.set(0, -1, 0), s.lookAt(new je(-1, 0, 0)),
							a.add(s);
						var l = new vr(mr, 1, e, r);
						l.layers = a.layers, l.up.set(0, 0, 1), l.lookAt(new je(0, 1, 0)), a
							.add(l);
						var u = new vr(mr, 1, e, r);
						u.layers = a.layers, u.up.set(0, 0, -1), u.lookAt(new je(0, -1, 0)),
							a.add(u);
						var c = new vr(mr, 1, e, r);
						c.layers = a.layers, c.up.set(0, -1, 0), c.lookAt(new je(0, 0, 1)),
							a.add(c);
						var h = new vr(mr, 1, e, r);
						return h.layers = a.layers, h.up.set(0, -1, 0), h.lookAt(new je(0,
							0, -1)), a.add(h), (0, v.default)(a)
					}
					return (0, y.default)(n, [{
						key: "update",
						value: function(e, t) {
							null === this.parent && this
						.updateMatrixWorld();
							var n = this.renderTarget,
								r = (0, c.default)(this.children, 6),
								i = r[0],
								a = r[1],
								o = r[2],
								s = r[3],
								l = r[4],
								u = r[5],
								h = e.xr.enabled,
								d = e.getRenderTarget();
							e.xr.enabled = !1;
							var f = n.texture.generateMipmaps;
							n.texture.generateMipmaps = !1, e
								.setRenderTarget(n, 0), e.render(t, i), e
								.setRenderTarget(n, 1), e.render(t, a), e
								.setRenderTarget(n, 2), e.render(t, o), e
								.setRenderTarget(n, 3), e.render(t, s), e
								.setRenderTarget(n, 4), e.render(t, l), n
								.texture.generateMipmaps = f, e
								.setRenderTarget(n, 5), e.render(t, u), e
								.setRenderTarget(d), e.xr.enabled = h
						}
					}]), n
				}(Xt),
				yr = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i, o, s, l, u, c, h, d) {
						var f;
						return (0, g.default)(this, n), (f = t.call(this, e = void 0 !== e ?
								e : [], r = void 0 !== r ? r : a, i, o, s, l, u =
								void 0 !== u ? u : H, c, h, d))._needsFlipEnvMap = !0, f
							.flipY = !1, f
					}
					return (0, y.default)(n, [{
						key: "images",
						get: function() {
							return this.image
						},
						set: function(e) {
							this.image = e
						}
					}]), n
				}(ze);
			yr.prototype.isCubeTexture = !0;
			var xr = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i) {
					var a;
					return (0, g.default)(this, n), Number.isInteger(r) && (console
							.warn(
								"THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
								), r = i), a = t.call(this, e, e, r), r = r || {}, a
						.texture = new yr(void 0, r.mapping, r.wrapS, r.wrapT, r
							.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r
							.encoding), a.texture.generateMipmaps = void 0 !== r
						.generateMipmaps && r.generateMipmaps, a.texture.minFilter =
						void 0 !== r.minFilter ? r.minFilter : C, a.texture
						._needsFlipEnvMap = !1, a
				}
				return (0, y.default)(n, [{
					key: "fromEquirectangularTexture",
					value: function(e, t) {
						this.texture.type = t.type, this.texture
							.format = U, this.texture.encoding = t
							.encoding, this.texture.generateMipmaps = t
							.generateMipmaps, this.texture.minFilter = t
							.minFilter, this.texture.magFilter = t
							.magFilter;
						var n = {
								tEquirect: {
									value: null
								}
							},
							r =
							"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
							i =
							"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
							a = new ur(5, 5, 5),
							o = new fr({
								name: "CubemapFromEquirect",
								uniforms: cr(n),
								vertexShader: r,
								fragmentShader: i,
								side: 1,
								blending: 0
							});
						o.uniforms.tEquirect.value = t;
						var s = new sr(a, o),
							l = t.minFilter;
						return t.minFilter === I && (t.minFilter = C),
							new gr(1, 10, this).update(e, s), t
							.minFilter = l, s.geometry.dispose(), s
							.material.dispose(), this
					}
				}, {
					key: "clear",
					value: function(e, t, n, r) {
						for (var i = e.getRenderTarget(), a = 0; a <
							6; a++) e.setRenderTarget(this, a), e.clear(
							t, n, r);
						e.setRenderTarget(i)
					}
				}]), n
			}(Ue);
			xr.prototype.isWebGLCubeRenderTarget = !0;
			var _r = new ft,
				br = new je,
				wr = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new Jt,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new Jt,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : new Jt,
							i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : new Jt,
							a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : new Jt,
							o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : new Jt;
						(0, g.default)(this, e), this.planes = [t, n, r, i, a, o]
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t, n, r, i, a) {
							var o = this.planes;
							return o[0].copy(e), o[1].copy(t), o[2].copy(n),
								o[3].copy(r), o[4].copy(i), o[5].copy(a),
								this
						}
					}, {
						key: "copy",
						value: function(e) {
							for (var t = this.planes, n = 0; n < 6; n++) t[
								n].copy(e.planes[n]);
							return this
						}
					}, {
						key: "setFromProjectionMatrix",
						value: function(e) {
							var t = this.planes,
								n = e.elements,
								r = n[0],
								i = n[1],
								a = n[2],
								o = n[3],
								s = n[4],
								l = n[5],
								u = n[6],
								c = n[7],
								h = n[8],
								d = n[9],
								f = n[10],
								p = n[11],
								v = n[12],
								m = n[13],
								g = n[14],
								y = n[15];
							return t[0].setComponents(o - r, c - s, p - h,
									y - v).normalize(), t[1].setComponents(
									o + r, c + s, p + h, y + v).normalize(),
								t[2].setComponents(o + i, c + l, p + d, y +
									m).normalize(), t[3].setComponents(o -
									i, c - l, p - d, y - m).normalize(), t[
									4].setComponents(o - a, c - u, p - f,
									y - g).normalize(), t[5].setComponents(
									o + a, c + u, p + f, y + g).normalize(),
								this
						}
					}, {
						key: "intersectsObject",
						value: function(e) {
							var t = e.geometry;
							return null === t.boundingSphere && t
								.computeBoundingSphere(), _r.copy(t
									.boundingSphere).applyMatrix4(e
									.matrixWorld), this.intersectsSphere(_r)
						}
					}, {
						key: "intersectsSprite",
						value: function(e) {
							return _r.center.set(0, 0, 0), _r.radius =
								.7071067811865476, _r.applyMatrix4(e
									.matrixWorld), this.intersectsSphere(_r)
						}
					}, {
						key: "intersectsSphere",
						value: function(e) {
							for (var t = this.planes, n = e.center, r = -e
									.radius, i = 0; i < 6; i++)
								if (t[i].distanceToPoint(n) < r) return !1;
							return !0
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							for (var t = this.planes, n = 0; n < 6; n++) {
								var r = t[n];
								if (br.x = r.normal.x > 0 ? e.max.x : e.min
									.x, br.y = r.normal.y > 0 ? e.max.y : e
									.min.y, br.z = r.normal.z > 0 ? e.max
									.z : e.min.z, r.distanceToPoint(br) < 0)
									return !1
							}
							return !0
						}
					}, {
						key: "containsPoint",
						value: function(e) {
							for (var t = this.planes, n = 0; n < 6; n++)
								if (t[n].distanceToPoint(e) < 0) return !1;
							return !0
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}();

			function Mr() {
				var e = null,
					t = !1,
					n = null,
					r = null;

				function i(t, a) {
					n(t, a), r = e.requestAnimationFrame(i)
				}
				return {
					start: function() {
						!0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !
							0)
					},
					stop: function() {
						e.cancelAnimationFrame(r), t = !1
					},
					setAnimationLoop: function(e) {
						n = e
					},
					setContext: function(t) {
						e = t
					}
				}
			}

			function Sr(e, t) {
				var n = t.isWebGL2,
					r = new WeakMap;
				return {
					get: function(e) {
						return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
					},
					remove: function(t) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var n = r.get(t);
						n && (e.deleteBuffer(n.buffer), r.delete(t))
					},
					update: function(t, i) {
						if (t.isGLBufferAttribute) {
							var a = r.get(t);
							(!a || a.version < t.version) && r.set(t, {
								buffer: t.buffer,
								type: t.type,
								bytesPerElement: t.elementSize,
								version: t.version
							})
						} else {
							t.isInterleavedBufferAttribute && (t = t.data);
							var o = r.get(t);
							void 0 === o ? r.set(t, function(t, r) {
								var i = t.array,
									a = t.usage
								var s = 5126;
								return i instanceof Float32Array ? s = 5126 :
									i instanceof Float64Array ? console.warn(
										"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
										) : i instanceof Uint16Array ? t
									.isFloat16BufferAttribute ? n ? s = 5131 :
									console.warn(
										"THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
										) : s = 5123 : i instanceof Int16Array ?
									s = 5122 : i instanceof Uint32Array ? s =
									5125 : i instanceof Int32Array ? s = 5124 :
									i instanceof Int8Array ? s = 5120 : (
										i instanceof Uint8Array ||
										i instanceof Uint8ClampedArray) && (s =
										5121), {
										buffer: o,
										type: s,
										bytesPerElement: i.BYTES_PER_ELEMENT,
										version: t.version
									}
							}(t, i)) : o.version < t.version && (function(t, r, i) {
								var a = r.array,
									o = r.updateRange;
								e.bindBuffer(i, t), -1 === o.count ? e
									.bufferSubData(i, 0, a) : (n ? e
										.bufferSubData(i, o.offset * a
											.BYTES_PER_ELEMENT, a, o.offset, o
											.count) : e.bufferSubData(i, o
											.offset * a.BYTES_PER_ELEMENT, a
											.subarray(o.offset, o.offset + o
												.count)), o.count = -1)
							}(o.buffer, t, i), o.version = t.version)
						}
					}
				}
			}
			var Tr = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 1,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1;
						(0, g.default)(this, n), (e = t.call(this)).type = "PlaneGeometry",
							e.parameters = {
								width: r,
								height: i,
								widthSegments: a,
								heightSegments: o
							};
						for (var s = r / 2, l = i / 2, u = Math.floor(a), c = Math.floor(o),
								h = u + 1, d = c + 1, f = r / u, p = i / c, v = [], m = [],
								y = [], x = [], _ = 0; _ < d; _++)
							for (var b = _ * p - l, w = 0; w < h; w++) {
								var M = w * f - s;
								m.push(M, -b, 0), y.push(0, 0, 1), x.push(w / u), x.push(1 -
									_ / c)
							}
						for (var S = 0; S < c; S++)
							for (var T = 0; T < u; T++) {
								var E = T + h * S,
									A = T + h * (S + 1),
									L = T + 1 + h * (S + 1),
									k = T + 1 + h * S;
								v.push(E, A, k), v.push(A, L, k)
							}
						return e.setIndex(v), e.setAttribute("position", new Cn(m, 3)), e
							.setAttribute("normal", new Cn(y, 3)), e.setAttribute("uv",
								new Cn(x, 2)), e
					}
					return n
				}(Vn),
				Er = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
					bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
					common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
					envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
					lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
					lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
					lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
					map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
					normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
					normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
					clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
					clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
					clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
					transmission_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif",
					transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
					uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
				},
				Ar = {
					common: {
						diffuse: {
							value: new yn(16777215)
						},
						opacity: {
							value: 1
						},
						map: {
							value: null
						},
						uvTransform: {
							value: new Ne
						},
						uv2Transform: {
							value: new Ne
						},
						alphaMap: {
							value: null
						}
					},
					specularmap: {
						specularMap: {
							value: null
						}
					},
					envmap: {
						envMap: {
							value: null
						},
						flipEnvMap: {
							value: -1
						},
						reflectivity: {
							value: 1
						},
						refractionRatio: {
							value: .98
						},
						maxMipLevel: {
							value: 0
						}
					},
					aomap: {
						aoMap: {
							value: null
						},
						aoMapIntensity: {
							value: 1
						}
					},
					lightmap: {
						lightMap: {
							value: null
						},
						lightMapIntensity: {
							value: 1
						}
					},
					emissivemap: {
						emissiveMap: {
							value: null
						}
					},
					bumpmap: {
						bumpMap: {
							value: null
						},
						bumpScale: {
							value: 1
						}
					},
					normalmap: {
						normalMap: {
							value: null
						},
						normalScale: {
							value: new Ie(1, 1)
						}
					},
					displacementmap: {
						displacementMap: {
							value: null
						},
						displacementScale: {
							value: 1
						},
						displacementBias: {
							value: 0
						}
					},
					roughnessmap: {
						roughnessMap: {
							value: null
						}
					},
					metalnessmap: {
						metalnessMap: {
							value: null
						}
					},
					gradientmap: {
						gradientMap: {
							value: null
						}
					},
					fog: {
						fogDensity: {
							value: 25e-5
						},
						fogNear: {
							value: 1
						},
						fogFar: {
							value: 2e3
						},
						fogColor: {
							value: new yn(16777215)
						}
					},
					lights: {
						ambientLightColor: {
							value: []
						},
						lightProbe: {
							value: []
						},
						directionalLights: {
							value: [],
							properties: {
								direction: {},
								color: {}
							}
						},
						directionalLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						directionalShadowMap: {
							value: []
						},
						directionalShadowMatrix: {
							value: []
						},
						spotLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								direction: {},
								distance: {},
								coneCos: {},
								penumbraCos: {},
								decay: {}
							}
						},
						spotLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						spotShadowMap: {
							value: []
						},
						spotShadowMatrix: {
							value: []
						},
						pointLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								decay: {},
								distance: {}
							}
						},
						pointLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},
						pointShadowMap: {
							value: []
						},
						pointShadowMatrix: {
							value: []
						},
						hemisphereLights: {
							value: [],
							properties: {
								direction: {},
								skyColor: {},
								groundColor: {}
							}
						},
						rectAreaLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								width: {},
								height: {}
							}
						},
						ltc_1: {
							value: null
						},
						ltc_2: {
							value: null
						}
					},
					points: {
						diffuse: {
							value: new yn(16777215)
						},
						opacity: {
							value: 1
						},
						size: {
							value: 1
						},
						scale: {
							value: 1
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						uvTransform: {
							value: new Ne
						}
					},
					sprite: {
						diffuse: {
							value: new yn(16777215)
						},
						opacity: {
							value: 1
						},
						center: {
							value: new Ie(.5, .5)
						},
						rotation: {
							value: 0
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						uvTransform: {
							value: new Ne
						}
					}
				},
				Lr = {
					basic: {
						uniforms: hr([Ar.common, Ar.specularmap, Ar.envmap, Ar.aomap, Ar
							.lightmap, Ar.fog
						]),
						vertexShader: Er.meshbasic_vert,
						fragmentShader: Er.meshbasic_frag
					},
					lambert: {
						uniforms: hr([Ar.common, Ar.specularmap, Ar.envmap, Ar.aomap, Ar
							.lightmap, Ar.emissivemap, Ar.fog, Ar.lights, {
								emissive: {
									value: new yn(0)
								}
							}
						]),
						vertexShader: Er.meshlambert_vert,
						fragmentShader: Er.meshlambert_frag
					},
					phong: {
						uniforms: hr([Ar.common, Ar.specularmap, Ar.envmap, Ar.aomap, Ar
							.lightmap, Ar.emissivemap, Ar.bumpmap, Ar.normalmap, Ar
							.displacementmap, Ar.fog, Ar.lights, {
								emissive: {
									value: new yn(0)
								},
								specular: {
									value: new yn(1118481)
								},
								shininess: {
									value: 30
								}
							}
						]),
						vertexShader: Er.meshphong_vert,
						fragmentShader: Er.meshphong_frag
					},
					standard: {
						uniforms: hr([Ar.common, Ar.envmap, Ar.aomap, Ar.lightmap, Ar
							.emissivemap, Ar.bumpmap, Ar.normalmap, Ar
							.displacementmap, Ar.roughnessmap, Ar.metalnessmap, Ar
							.fog, Ar.lights, {
								emissive: {
									value: new yn(0)
								},
								roughness: {
									value: 1
								},
								metalness: {
									value: 0
								},
								envMapIntensity: {
									value: 1
								}
							}
						]),
						vertexShader: Er.meshphysical_vert,
						fragmentShader: Er.meshphysical_frag
					},
					toon: {
						uniforms: hr([Ar.common, Ar.aomap, Ar.lightmap, Ar.emissivemap, Ar
							.bumpmap, Ar.normalmap, Ar.displacementmap, Ar
							.gradientmap, Ar.fog, Ar.lights, {
								emissive: {
									value: new yn(0)
								}
							}
						]),
						vertexShader: Er.meshtoon_vert,
						fragmentShader: Er.meshtoon_frag
					},
					matcap: {
						uniforms: hr([Ar.common, Ar.bumpmap, Ar.normalmap, Ar
							.displacementmap, Ar.fog, {
								matcap: {
									value: null
								}
							}
						]),
						vertexShader: Er.meshmatcap_vert,
						fragmentShader: Er.meshmatcap_frag
					},
					points: {
						uniforms: hr([Ar.points, Ar.fog]),
						vertexShader: Er.points_vert,
						fragmentShader: Er.points_frag
					},
					dashed: {
						uniforms: hr([Ar.common, Ar.fog, {
							scale: {
								value: 1
							},
							dashSize: {
								value: 1
							},
							totalSize: {
								value: 2
							}
						}]),
						vertexShader: Er.linedashed_vert,
						fragmentShader: Er.linedashed_frag
					},
					depth: {
						uniforms: hr([Ar.common, Ar.displacementmap]),
						vertexShader: Er.depth_vert,
						fragmentShader: Er.depth_frag
					},
					normal: {
						uniforms: hr([Ar.common, Ar.bumpmap, Ar.normalmap, Ar
							.displacementmap, {
								opacity: {
									value: 1
								}
							}
						]),
						vertexShader: Er.normal_vert,
						fragmentShader: Er.normal_frag
					},
					sprite: {
						uniforms: hr([Ar.sprite, Ar.fog]),
						vertexShader: Er.sprite_vert,
						fragmentShader: Er.sprite_frag
					},
					background: {
						uniforms: {
							uvTransform: {
								value: new Ne
							},
							t2D: {
								value: null
							}
						},
						vertexShader: Er.background_vert,
						fragmentShader: Er.background_frag
					},
					cube: {
						uniforms: hr([Ar.envmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Er.cube_vert,
						fragmentShader: Er.cube_frag
					},
					equirect: {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: Er.equirect_vert,
						fragmentShader: Er.equirect_frag
					},
					distanceRGBA: {
						uniforms: hr([Ar.common, Ar.displacementmap, {
							referencePosition: {
								value: new je
							},
							nearDistance: {
								value: 1
							},
							farDistance: {
								value: 1e3
							}
						}]),
						vertexShader: Er.distanceRGBA_vert,
						fragmentShader: Er.distanceRGBA_frag
					},
					shadow: {
						uniforms: hr([Ar.lights, Ar.fog, {
							color: {
								value: new yn(0)
							},
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Er.shadow_vert,
						fragmentShader: Er.shadow_frag
					}
				};

			function kr(e, t, n, r, i) {
				var a, o, s = new yn(0),
					l = 0,
					u = null,
					c = 0,
					h = null;

				function d(e, t) {
					n.buffers.color.setClear(e.r, e.g, e.b, t, i)
				}
				return {
					getClearColor: function() {
						return s
					},
					setClearColor: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 1;
						s.set(e), d(s, l = t)
					},
					getClearAlpha: function() {
						return l
					},
					setClearAlpha: function(e) {
						d(s, l = e)
					},
					render: function(n, i) {
						var f = !1,
							p = !0 === i.isScene ? i.background : null;
						p && p.isTexture && (p = t.get(p));
						var v = e.xr,
							m = v.getSession && v.getSession();
						m && "additive" === m.environmentBlendMode && (p = null),
							null === p ? d(s, l) : p && p.isColor && (d(p, 1), f = !0),
							(e.autoClear || f) && e.clear(e.autoClearColor, e
								.autoClearDepth, e.autoClearStencil), p && (p
								.isCubeTexture || p.mapping === b) ? (void 0 === o && ((
										o = new sr(new ur(1, 1, 1), new fr({
											name: "BackgroundCubeMaterial",
											uniforms: cr(Lr.cube.uniforms),
											vertexShader: Lr.cube.vertexShader,
											fragmentShader: Lr.cube
												.fragmentShader,
											side: 1,
											depthTest: !1,
											depthWrite: !1,
											fog: !1
										}))).geometry.deleteAttribute("normal"), o
									.geometry.deleteAttribute("uv"), o.onBeforeRender =
									function(e, t, n) {
										this.matrixWorld.copyPosition(n.matrixWorld)
									}, Object.defineProperty(o.material, "envMap", {
										get: function() {
											return this.uniforms.envMap.value
										}
									}), r.update(o)), o.material.uniforms.envMap.value =
								p, o.material.uniforms.flipEnvMap.value = p
								.isCubeTexture && p._needsFlipEnvMap ? -1 : 1, u ===
								p && c === p.version && h === e.toneMapping || (o
									.material.needsUpdate = !0, u = p, c = p.version,
									h = e.toneMapping), n.unshift(o, o.geometry, o
									.material, 0, 0, null)) : p && p.isTexture && (
								void 0 === a && ((a = new sr(new Tr(2, 2), new fr({
										name: "BackgroundMaterial",
										uniforms: cr(Lr.background
											.uniforms),
										vertexShader: Lr.background
											.vertexShader,
										fragmentShader: Lr.background
											.fragmentShader,
										side: 0,
										depthTest: !1,
										depthWrite: !1,
										fog: !1
									}))).geometry.deleteAttribute("normal"), Object
									.defineProperty(a.material, "map", {
										get: function() {
											return this.uniforms.t2D.value
										}
									}), r.update(a)), a.material.uniforms.t2D.value = p,
								!0 === p.matrixAutoUpdate && p.updateMatrix(), a
								.material.uniforms.uvTransform.value.copy(p.matrix),
								u === p && c === p.version && h === e.toneMapping || (a
									.material.needsUpdate = !0, u = p, c = p.version,
									h = e.toneMapping), n.unshift(a, a.geometry, a
									.material, 0, 0, null))
					}
				}
			}

			function Rr(e, t, n, r) {
				var i = {},
					a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
					o = r.isWebGL2 || null !== a,
					s = {},
					l = d(null),
					u = l;

				function c(t) {
					return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
				}

				function h(t) {
					return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
				}

				function d(e) {
					for (var t = [], n = [], r = [], a = 0; a < i; a++) t[a] = 0, n[a] = 0,
						r[a] = 0;
					return {
						geometry: null,
						program: null,
						wireframe: !1,
						newAttributes: t,
						enabledAttributes: n,
						attributeDivisors: r,
						object: e,
						attributes: {},
						index: null
					}
				}

				function f() {
					for (var e = u.newAttributes, t = 0, n = e.length; t < n; t++) e[t] = 0
				}

				function p(e) {
					v(e, 0)
				}

				function v(n, i) {
					var a = u.newAttributes,
						o = u.enabledAttributes,
						s = u.attributeDivisors;
					a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[
						n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r
							.isWebGL2 ? "vertexAttribDivisor" :
							"vertexAttribDivisorANGLE"](n, i), s[n] = i)
				}

				function m() {
					for (var t = u.newAttributes, n = u.enabledAttributes, r = 0, i = n
							.length; r < i; r++) n[r] !== t[r] && (e
						.disableVertexAttribArray(r), n[r] = 0)
				}

				function g(t, n, i, a, o, s) {
					!0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t,
						n, i, a, o, s) : e.vertexAttribIPointer(t, n, i, o, s)
				}

				function y() {
					x(), u !== l && c((u = l).object)
				}

				function x() {
					l.geometry = null, l.program = null, l.wireframe = !1
				}
				return {
					reset: y,
					resetDefaultState: x,
					dispose: function() {
						for (var e in y(), s) {
							var t = s[e];
							for (var n in t) {
								var r = t[n];
								for (var i in r) h(r[i].object), delete r[i];
								delete t[n]
							}
							delete s[e]
						}
					},
					releaseStatesOfGeometry: function(e) {
						if (void 0 !== s[e.id]) {
							var t = s[e.id];
							for (var n in t) {
								var r = t[n];
								for (var i in r) h(r[i].object), delete r[i];
								delete t[n]
							}
							delete s[e.id]
						}
					},
					releaseStatesOfProgram: function(e) {
						for (var t in s) {
							var n = s[t];
							if (void 0 !== n[e.id]) {
								var r = n[e.id];
								for (var i in r) h(r[i].object), delete r[i];
								delete n[e.id]
							}
						}
					},
					initAttributes: f,
					enableAttribute: p,
					disableUnusedAttributes: m
				}
			}

			function Cr(e, t, n, r) {
				var i, a = r.isWebGL2;
				this.setMode = function(e) {
					i = e
				}, this.render = function(t, r) {
					e.drawArrays(i, t, r), n.update(r, i, 1)
				}, this.renderInstances = function(r, o, s) {
					if (0 !== s) {
						var l, u;
						if (a) l = e, u = "drawArraysInstanced";
						else if (u = "drawArraysInstancedANGLE", null === (l = t.get(
								"ANGLE_instanced_arrays"))) return void console.error(
							"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						l[u](i, r, o, s), n.update(o, i, s)
					}
				}
			}

			function Pr(e, t, n) {
				var r;

				function i(t) {
					if ("highp" === t) {
						return "highp";
						t = "mediump"
					}
					return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337)
						.precision > 0 && e.getShaderPrecisionFormat(35632, 36337)
						.precision > 0 ? "mediump" : "lowp"
				}
				var a = "undefined" != typeof WebGL2RenderingContext &&
					e instanceof WebGL2RenderingContext || "undefined" !=
					typeof WebGL2ComputeRenderingContext &&
					e instanceof WebGL2ComputeRenderingContext,
					o = void 0 !== n.precision ? n.precision : "highp",
					s = i(o);
				s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using",
					s, "instead."), o = s);
				var l = a || t.has("WEBGL_draw_buffers"),
					u = !0 === n.logarithmicDepthBuffer,
					c = (34930),
					h = (35660),
					d = (3379),
					f = (34076),
					p = (34921),
					v = (36347),
					m = (36348),
					g = (36349),
					y = h > 0,
					x = a || t.has("OES_texture_float");
				return {
					isWebGL2: a,
					drawBuffers: l,
					getMaxAnisotropy: function() {
						if (void 0 !== r) return r;
						return r
					},
					getMaxPrecision: i,
					precision: o,
					logarithmicDepthBuffer: u,
					maxTextures: c,
					maxVertexTextures: h,
					maxTextureSize: d,
					maxCubemapSize: f,
					maxAttributes: p,
					maxVertexUniforms: v,
					maxVaryings: m,
					maxFragmentUniforms: g,
					vertexTextures: y,
					floatFragmentTextures: x,
					floatVertexTextures: y && x,
					maxSamples: a
				}
			}

			function Ir(e) {
				var t = this,
					n = null,
					r = 0,
					i = !1,
					a = !1,
					o = new Jt,
					s = new Ne,
					l = {
						value: null,
						needsUpdate: !1
					};

				function u() {
					l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r,
						t.numIntersection = 0
				}

				function c(e, n, r, i) {
					var a = null !== e ? e.length : 0,
						u = null;
					if (0 !== a) {
						if (u = l.value, !0 !== i || null === u) {
							var c = r + 4 * a,
								h = n.matrixWorldInverse;
							s.getNormalMatrix(h), (null === u || u.length < c) && (u =
								new Float32Array(c));
							for (var d = 0, f = r; d !== a; ++d, f += 4) o.copy(e[d])
								.applyMatrix4(h, s), o.normal.toArray(u, f), u[f + 3] = o
								.constant
						}
						l.value = u, l.needsUpdate = !0
					}
					return t.numPlanes = a, t.numIntersection = 0, u
				}
				this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init =
					function(e, t, a) {
						var o = 0 !== e.length || t || 0 !== r || i;
						return i = t, n = c(e, a, 0), r = e.length, o
					}, this.beginShadows = function() {
						a = !0, c(null)
					}, this.endShadows = function() {
						a = !1, u()
					}, this.setState = function(t, o, s) {
						var h = t.clippingPlanes,
							d = t.clipIntersection,
							f = t.clipShadows,
							p = e.get(t);
						if (!i || null === h || 0 === h.length || a && !f) a ? c(null) :
					u();
						else {
							var v = a ? 0 : r,
								m = 4 * v,
								g = p.clippingState || null;
							l.value = g, g = c(h, o, m, s);
							for (var y = 0; y !== m; ++y) g[y] = n[y];
							p.clippingState = g, this.numIntersection = d ? this.numPlanes :
								0, this.numPlanes += v
						}
					}
			}

			function Dr(e) {
				var t = new WeakMap;

				function n(e, t) {
					return t === s ? e.mapping = a : t === x && (e.mapping = o), e
				}

				function r(e) {
					var n = e.target;
					n.removeEventListener("dispose", r);
					var i = t.get(n);
					void 0 !== i && (t.delete(n), i.dispose())
				}
				return {
					get: function(i) {
						if (i && i.isTexture) {
							var a = i.mapping;
							if (a === s || a === x) {
								if (t.has(i)) return n(t.get(i).texture, i.mapping);
								var o = i.image;
								if (o && o.height > 0) {
									var l = e.getRenderTarget(),
										u = new xr(o.height / 2);
									return u.fromEquirectangularTexture(e, i), t.set(i,
											u), e.setRenderTarget(l), i
										.addEventListener("dispose", r), n(u.texture, i
											.mapping)
								}
								return null
							}
						}
						return i
					},
					dispose: function() {
						t = new WeakMap
					}
				}
			}

			function Nr(e) {
				var t = {};

				function n(n) {
					if (void 0 !== t[n]) return t[n];
					var r;
					switch (n) {
						case "WEBGL_compressed_texture_pvrtc":
							break;
						default:
							r = (n)
					}
					return t[n] = r, r
				}
				return {
					has: function(e) {
						return null !== n(e)
					},
					init: function(e) {
						e.isWebGL2 ? n("EXT_color_buffer_float") : (n(
							"WEBGL_depth_texture"), n("OES_texture_float"), n(
							"OES_texture_half_float"), n(
							"OES_texture_half_float_linear"), n(
							"OES_standard_derivatives"), n(
							"OES_element_index_uint"), n(
							"OES_vertex_array_object"), n(
							"ANGLE_instanced_arrays")), n(
							"OES_texture_float_linear"), n(
							"EXT_color_buffer_half_float")
					},
					get: function(e) {
						var t = n(e);
						return null === t && console.warn("THREE.WebGLRenderer: " + e +
							" extension not supported."), t
					}
				}
			}

			function Or(e, t, n, r) {
				var i = {},
					a = new WeakMap;

				function o(e) {
					var s = e.target;
					for (var l in null !== s.index && t.remove(s.index), s.attributes) t
						.remove(s.attributes[l]);
					s.removeEventListener("dispose", o), delete i[s.id];
					var u = a.get(s);
					u && (t.remove(u), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s
						.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory
						.geometries--
				}

				function s(e) {
					var n = [],
						r = e.index,
						i = e.attributes.position,
						o = 0;
					if (null !== r) {
						var s = r.array;
						o = r.version;
						for (var l = 0, u = s.length; l < u; l += 3) {
							var c = s[l + 0],
								h = s[l + 1],
								d = s[l + 2];
							n.push(c, h, h, d, d, c)
						}
					} else {
						var f = i.array;
						o = i.version;
						for (var p = 0, v = f.length / 3 - 1; p < v; p += 3) {
							var m = p + 0,
								g = p + 1,
								y = p + 2;
							n.push(m, g, g, y, y, m)
						}
					}
					var x = new(In(n) > 65535 ? kn : An)(n, 1);
					x.version = o;
					var _ = a.get(e);
					_ && t.remove(_), a.set(e, x)
				}
				return {
					get: function(e, t) {
						return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t
							.id] = !0, n.memory.geometries++), t
					},
					update: function(e) {
						var n = e.attributes;
						for (var r in n) t.update(n[r], 34962);
						var i = e.morphAttributes;
						for (var a in i)
							for (var o = i[a], s = 0, l = o.length; s < l; s++) t
								.update(o[s], 34962)
					},
					getWireframeAttribute: function(e) {
						var t = a.get(e);
						if (t) {
							var n = e.index;
							null !== n && t.version < n.version && s(e)
						} else s(e);
						return a.get(e)
					}
				}
			}

			
			
			function Gr(e, t, n, r) {
				var i = new WeakMap;

				function a(e) {
					var t = e.target;
					t.removeEventListener("dispose", a), n.remove(t.instanceMatrix),
						null !== t.instanceColor && n.remove(t.instanceColor)
				}
				return {
					update: function(e) {
						var o = r.render.frame,
							s = e.geometry,
							l = t.get(e, s);
						return i.get(l) !== o && (t.update(l), i.set(l, o)), e
							.isInstancedMesh && (!1 === e.hasEventListener("dispose",
								a) && e.addEventListener("dispose", a), n.update(e
									.instanceMatrix, 34962), null !== e.instanceColor &&
								n.update(e.instanceColor, 34962)), l
					},
					dispose: function() {
						i = new WeakMap
					}
				}
			}
			Lr.physical = {
				uniforms: hr([Lr.standard.uniforms, {
					clearcoat: {
						value: 0
					},
					clearcoatMap: {
						value: null
					},
					clearcoatRoughness: {
						value: 0
					},
					clearcoatRoughnessMap: {
						value: null
					},
					clearcoatNormalScale: {
						value: new Ie(1, 1)
					},
					clearcoatNormalMap: {
						value: null
					},
					sheen: {
						value: new yn(0)
					},
					transmission: {
						value: 0
					},
					transmissionMap: {
						value: null
					},
					transmissionSamplerSize: {
						value: new Ie
					},
					transmissionSamplerMap: {
						value: null
					},
					thickness: {
						value: 0
					},
					thicknessMap: {
						value: null
					},
					attenuationDistance: {
						value: 0
					},
					attenuationColor: {
						value: new yn(0)
					}
				}]),
				vertexShader: Er.meshphysical_vert,
				fragmentShader: Er.meshphysical_frag
			};
			var Vr = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : null,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 1,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1;
					return (0, g.default)(this, n), (e = t.call(this, null)).image = {
							data: r,
							width: i,
							height: a,
							depth: o
						}, e.magFilter = L, e.minFilter = L, e.wrapR = E, e
						.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
						.needsUpdate = !0, e
				}
				return n
			}(ze);
			Vr.prototype.isDataTexture2DArray = !0;
			var Wr = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : null,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 1,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1;
					return (0, g.default)(this, n), (e = t.call(this, null)).image = {
							data: r,
							width: i,
							height: a,
							depth: o
						}, e.magFilter = L, e.minFilter = L, e.wrapR = E, e
						.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
						.needsUpdate = !0, e
				}
				return n
			}(ze);
			Wr.prototype.isDataTexture3D = !0;
			var jr = new ze,
				qr = new Vr,
				Xr = new Wr,
				Yr = new yr,
				$r = [],
				Zr = [],
				Jr = new Float32Array(16),
				Qr = new Float32Array(9),
				Kr = new Float32Array(4);

			function ei(e, t, n) {
				var r = e[0];
				if (r <= 0 || r > 0) return e;
				var i = t * n,
					a = $r[i];
				if (void 0 === a && (a = new Float32Array(i), $r[i] = a), 0 !== t) {
					r.toArray(a, 0);
					for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
				}
				return a
			}

			function ti(e, t) {
				if (e.length !== t.length) return !1;
				for (var n = 0, r = e.length; n < r; n++)
					if (e[n] !== t[n]) return !1;
				return !0
			}

			function ni(e, t) {
				for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
			}

			function ri(e, t) {
				var n = Zr[t];
				void 0 === n && (n = new Int32Array(t), Zr[t] = n);
				for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
				return n
			}

			function ii(e, t) {
				var n = this.cache;
				n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
			}

			function ai(e, t) {
				var n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr,
					t.x, t.y), n[0] = t.x, n[1] = t.y);
				else {
					if (ti(n, t)) return;
					e.uniform2fv(this.addr, t), ni(n, t)
				}
			}

			function oi(e, t) {
				var n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e
					.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] =
					t.z);
				else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e
					.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] =
					t.b);
				else {
					if (ti(n, t)) return;
					e.uniform3fv(this.addr, t), ni(n, t)
				}
			}

			function si(e, t) {
				var n = this.cache;
				if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] ===
					t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t
						.y, n[2] = t.z, n[3] = t.w);
				else {
					if (ti(n, t)) return;
					e.uniform4fv(this.addr, t), ni(n, t)
				}
			}

			function li(e, t) {
				var n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (ti(n, t)) return;
					e.uniformMatrix2fv(this.addr, !1, t), ni(n, t)
				} else {
					if (ti(n, r)) return;
					Kr.set(r), e.uniformMatrix2fv(this.addr, !1, Kr), ni(n, r)
				}
			}

			function ui(e, t) {
				var n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (ti(n, t)) return;
					e.uniformMatrix3fv(this.addr, !1, t), ni(n, t)
				} else {
					if (ti(n, r)) return;
					Qr.set(r), e.uniformMatrix3fv(this.addr, !1, Qr), ni(n, r)
				}
			}

			function ci(e, t) {
				var n = this.cache,
					r = t.elements;
				if (void 0 === r) {
					if (ti(n, t)) return;
					e.uniformMatrix4fv(this.addr, !1, t), ni(n, t)
				} else {
					if (ti(n, r)) return;
					Jr.set(r), e.uniformMatrix4fv(this.addr, !1, Jr), ni(n, r)
				}
			}

			function hi(e, t) {
				var n = this.cache;
				n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
			}

			function di(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform2iv(this.addr, t), ni(n, t))
			}

			function fi(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform3iv(this.addr, t), ni(n, t))
			}

			function pi(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform4iv(this.addr, t), ni(n, t))
			}

			function vi(e, t) {
				var n = this.cache;
				n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
			}

			function mi(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform2uiv(this.addr, t), ni(n, t))
			}

			function gi(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform3uiv(this.addr, t), ni(n, t))
			}

			function yi(e, t) {
				var n = this.cache;
				ti(n, t) || (e.uniform4uiv(this.addr, t), ni(n, t))
			}

			function xi(e, t, n) {
				var r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t ||
					jr, i)
			}

			function _i(e, t, n) {
				var r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Xr,
					i)
			}

			function bi(e, t, n) {
				var r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(
					t || Yr, i)
			}

			function wi(e, t, n) {
				var r = this.cache,
					i = n.allocateTextureUnit();
				r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(
					t || qr, i)
			}

			function Mi(e, t) {
				e.uniform1fv(this.addr, t)
			}

			function Si(e, t) {
				var n = ei(t, this.size, 2);
				e.uniform2fv(this.addr, n)
			}

			function Ti(e, t) {
				var n = ei(t, this.size, 3);
				e.uniform3fv(this.addr, n)
			}

			function Ei(e, t) {
				var n = ei(t, this.size, 4);
				e.uniform4fv(this.addr, n)
			}

			function Ai(e, t) {
				var n = ei(t, this.size, 4);
				e.uniformMatrix2fv(this.addr, !1, n)
			}

			function Li(e, t) {
				var n = ei(t, this.size, 9);
				e.uniformMatrix3fv(this.addr, !1, n)
			}

			function ki(e, t) {
				var n = ei(t, this.size, 16);
				e.uniformMatrix4fv(this.addr, !1, n)
			}

			function Ri(e, t) {
				e.uniform1iv(this.addr, t)
			}

			function Ci(e, t) {
				e.uniform2iv(this.addr, t)
			}

			function Pi(e, t) {
				e.uniform3iv(this.addr, t)
			}

			function Ii(e, t) {
				e.uniform4iv(this.addr, t)
			}

			function Di(e, t) {
				e.uniform1uiv(this.addr, t)
			}

			function Ni(e, t) {
				e.uniform2uiv(this.addr, t)
			}

			function Oi(e, t) {
				e.uniform3uiv(this.addr, t)
			}

			function Bi(e, t) {
				e.uniform4uiv(this.addr, t)
			}

			function zi(e, t, n) {
				var r = t.length,
					i = ri(n, r);
				e.uniform1iv(this.addr, i);
				for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || jr, i[a])
			}

			function Fi(e, t, n) {
				var r = t.length,
					i = ri(n, r);
				e.uniform1iv(this.addr, i);
				for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || Yr, i[a])
			}

			function Hi(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
					switch (e) {
						case 5126:
							return ii;
						case 35664:
							return ai;
						case 35665:
							return oi;
						case 35666:
							return si;
						case 35674:
							return li;
						case 35675:
							return ui;
						case 35676:
							return ci;
						case 5124:
						case 35670:
							return hi;
						case 35667:
						case 35671:
							return di;
						case 35668:
						case 35672:
							return fi;
						case 35669:
						case 35673:
							return pi;
						case 5125:
							return vi;
						case 36294:
							return mi;
						case 36295:
							return gi;
						case 36296:
							return yi;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return xi;
						case 35679:
						case 36299:
						case 36307:
							return _i;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return bi;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return wi
					}
				}(t.type)
			}

			function Ui(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.size = t.size, this
					.setValue = function(e) {
						switch (e) {
							case 5126:
								return Mi;
							case 35664:
								return Si;
							case 35665:
								return Ti;
							case 35666:
								return Ei;
							case 35674:
								return Ai;
							case 35675:
								return Li;
							case 35676:
								return ki;
							case 5124:
							case 35670:
								return Ri;
							case 35667:
							case 35671:
								return Ci;
							case 35668:
							case 35672:
								return Pi;
							case 35669:
							case 35673:
								return Ii;
							case 5125:
								return Di;
							case 36294:
								return Ni;
							case 36295:
								return Oi;
							case 36296:
								return Bi;
							case 35678:
							case 36198:
							case 36298:
							case 36306:
							case 35682:
								return zi;
							case 35680:
							case 36300:
							case 36308:
							case 36293:
								return Fi
						}
					}(t.type)
			}

			function Gi(e) {
				this.id = e, this.seq = [], this.map = {}
			}
			Ui.prototype.updateCache = function(e) {
				var t = this.cache;
				e instanceof Float32Array && t.length !== e.length && (this.cache =
					new Float32Array(e.length)), ni(t, e)
			}, Gi.prototype.setValue = function(e, t, n) {
				for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
					var o = r[i];
					o.setValue(e, t[o.id], n)
				}
			};
			var Vi = /(\w+)(\])?(\[|\.)?/g;

			function Wi(e, t) {
				e.seq.push(t), e.map[t.id] = t
			}

			function ji(e, t, n) {
				var r = e.name,
					i = r.length;
				for (Vi.lastIndex = 0;;) {
					var a = Vi.exec(r),
						o = Vi.lastIndex,
						s = a[1],
						l = "]" === a[2],
						u = a[3];
					if (l && (s |= 0), void 0 === u || "[" === u && o + 2 === i) {
						Wi(n, void 0 === u ? new Hi(s, e, t) : new Ui(s, e, t));
						break
					}
					var c = n.map[s];
					void 0 === c && Wi(n, c = new Gi(s)), n = c
				}
			}

			function qi(e, t) {
				this.seq = [], this.map = {};
				for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
					var i = e.getActiveUniform(t, r);
					ji(i, e.getUniformLocation(t, i.name), this)
				}
			}
			qi.prototype.setValue = function(e, t, n, r) {
				var i = this.map[t];
				void 0 !== i && i.setValue(e, n, r)
			}, qi.prototype.setOptional = function(e, t, n) {
				var r = t[n];
				void 0 !== r && this.setValue(e, n, r)
			}, qi.upload = function(e, t, n, r) {
				for (var i = 0, a = t.length; i !== a; ++i) {
					var o = t[i],
						s = n[o.id];
					!1 !== s.needsUpdate && o.setValue(e, s.value, r)
				}
			}, qi.seqWithValue = function(e, t) {
				return n
			};
			var Yi = 0;

			function $i(e) {
				switch (e) {
					case le:
						return ["Linear", "( value )"];
					case ue:
						return ["sRGB", "( value )"];
					case he:
						return ["RGBE", "( value )"];
					case de:
						return ["RGBM", "( value, 7.0 )"];
					case fe:
						return ["RGBM", "( value, 16.0 )"];
					case pe:
						return ["RGBD", "( value, 256.0 )"];
					case ce:
						return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
					case 3003:
						return ["LogLuv", "( value )"];
					default:
						return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
							["Linear", "( value )"]
				}
			}

			function Zi(e, t, n) {
				var r = e.getShaderParameter(t, 35713),
					i = e.getShaderInfoLog(t).trim();
				return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " +
					n + "\n" + i + function(e) {
						for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 +
							": " + t[n];
						return t.join("\n")
					}(e.getShaderSource(t))
			}

			function Ji(e, t) {
				var n = $i(t);
				return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] +
					"; }"
			}

			function Qi(e, t) {
				var n = $i(t);
				return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] +
					"; }"
			}

			function Ki(e, t) {
				var n;
				switch (t) {
					case 1:
						n = "Linear";
						break;
					case 2:
						n = "Reinhard";
						break;
					case 3:
						n = "OptimizedCineon";
						break;
					case 4:
						n = "ACESFilmic";
						break;
					case 5:
						n = "Custom";
						break;
					default:
						console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n =
							"Linear"
				}
				return "vec3 " + e + "( vec3 color ) { return " + n +
					"ToneMapping( color ); }"
			}

			function ea(e) {
				return "" !== e
			}

			function ta(e, t) {
				return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(
					/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(
					/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(
					/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t
					.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t
					.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t
					.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t
					.numPointLightShadows)
			}

			function na(e, t) {
				return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(
					/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t
					.numClipIntersection)
			}
			var ra = /^[ \t]*#include +<([\w\d./]+)>/gm;

			function ia(e) {
				return e.replace(ra, aa)
			}

			function aa(e, t) {
				var n = Er[t];
				if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
				return ia(n)
			}
			var oa =
				/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
				sa =
				/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

			function la(e) {
				return e.replace(sa, ca).replace(oa, ua)
			}

			function ua(e, t, n, r) {
				return console.warn(
					"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
					), ca(0, t, n, r)
			}

			function ca(e, t, n, r) {
				for (var i = "", a = parseInt(t); a < parseInt(n); a++) i += r.replace(
					/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
				return i
			}

			function ha(e) {
				var t = "precision " + e.precision + " float;\nprecision " + e.precision +
					" int;";
				return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" :
					"mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" :
					"lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
			}

			function da(e, t, n, r) {
				var i, s, l = e.getContext(),
					u = n.defines,
					c = n.vertexShader,
					h = n.fragmentShader,
					d = function(e) {
						var t = "SHADOWMAP_TYPE_BASIC";
						return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e
							.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e
							.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
					}(n),
					f = function(e) {
						var t = "ENVMAP_TYPE_CUBE";
						if (e.envMap) switch (e.envMapMode) {
							case a:
							case o:
								t = "ENVMAP_TYPE_CUBE";
								break;
							case b:
							case S:
								t = "ENVMAP_TYPE_CUBE_UV"
						}
						return t
					}(n),
					p = function(e) {
						var t = "ENVMAP_MODE_REFLECTION";
						if (e.envMap) switch (e.envMapMode) {
							case o:
							case S:
								t = "ENVMAP_MODE_REFRACTION"
						}
						return t
					}(n),
					v = function(e) {
						var t = "ENVMAP_BLENDING_NONE";
						if (e.envMap) switch (e.combine) {
							case 0:
								t = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case 1:
								t = "ENVMAP_BLENDING_MIX";
								break;
							case 2:
								t = "ENVMAP_BLENDING_ADD"
						}
						return t
					}(n),
					m = e.gammaFactor > 0 ? e.gammaFactor : 1,
					g = n.isWebGL2 ? "" : function(e) {
						return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e
							.tangentSpaceNormalMap || e.clearcoatNormalMap || e
							.flatShading || "physical" === e.shaderID ?
							"#extension GL_OES_standard_derivatives : enable" : "", (e
								.extensionFragDepth || e.logarithmicDepthBuffer) && e
							.rendererExtensionFragDepth ?
							"#extension GL_EXT_frag_depth : enable" : "", e
							.extensionDrawBuffers && e.rendererExtensionDrawBuffers ?
							"#extension GL_EXT_draw_buffers : require" : "", (e
								.extensionShaderTextureLOD || e.envMap || e
								.transmission > 0) && e
							.rendererExtensionShaderTextureLod ?
							"#extension GL_EXT_shader_texture_lod : enable" : ""
						].filter(ea).join("\n")
					}(n),
					y = function(e) {
						var t = [];
						for (var n in e) {
							var r = e[n];
							!1 !== r && t.push("#define " + n + " " + r)
						}
						return t.join("\n")
					}(u),
					x = {},
					_ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
				n.isRawShaderMaterial ? ((i = [y].filter(ea).join("\n")).length > 0 && (i +=
						"\n"), (s = [g, y].filter(ea).join("\n")).length > 0 && (s +=
						"\n")) : (i = [ha(n), "#define SHADER_NAME " + n.shaderName, y, n
						.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ?
						"#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ?
						"#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m,
						"#define MAX_BONES " + n.maxBones, n.useFog && n.fog ?
						"#define USE_FOG" : "", n.useFog && n.fogExp2 ?
						"#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n
						.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p :
						"", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ?
						"#define USE_AOMAP" : "", n.emissiveMap ?
						"#define USE_EMISSIVEMAP" : "", n.bumpMap ?
						"#define USE_BUMPMAP" : "", n.normalMap ?
						"#define USE_NORMALMAP" : "", n.normalMap && n
						.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n
						.normalMap && n.tangentSpaceNormalMap ?
						"#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ?
						"#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ?
						"#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n
						.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n
						.displacementMap && n.supportsVertexTextures ?
						"#define USE_DISPLACEMENTMAP" : "", n.specularMap ?
						"#define USE_SPECULARMAP" : "", n.roughnessMap ?
						"#define USE_ROUGHNESSMAP" : "", n.metalnessMap ?
						"#define USE_METALNESSMAP" : "", n.alphaMap ?
						"#define USE_ALPHAMAP" : "", n.transmission ?
						"#define USE_TRANSMISSION" : "", n.transmissionMap ?
						"#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ?
						"#define USE_THICKNESSMAP" : "", n.vertexTangents ?
						"#define USE_TANGENT" : "", n.vertexColors ?
						"#define USE_COLOR" : "", n.vertexAlphas ?
						"#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" :
						"", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n
						.flatShading ? "#define FLAT_SHADED" : "", n.skinning ?
						"#define USE_SKINNING" : "", n.useVertexTexture ?
						"#define BONE_TEXTURE" : "", n.morphTargets ?
						"#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n
						.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ?
						"#define DOUBLE_SIDED" : "", n.flipSided ?
						"#define FLIP_SIDED" : "", n.shadowMapEnabled ?
						"#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " +
						d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
						n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n
						.logarithmicDepthBuffer && n.rendererExtensionFragDepth ?
						"#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;",
						"uniform mat4 modelViewMatrix;",
						"uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;",
						"uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;",
						"uniform bool isOrthographic;", "#ifdef USE_INSTANCING",
						"\tattribute mat4 instanceMatrix;", "#endif",
						"#ifdef USE_INSTANCING_COLOR",
						"\tattribute vec3 instanceColor;", "#endif",
						"attribute vec3 position;", "attribute vec3 normal;",
						"attribute vec2 uv;", "#ifdef USE_TANGENT",
						"\tattribute vec4 tangent;", "#endif",
						"#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;",
						"#elif defined( USE_COLOR )", "\tattribute vec3 color;",
						"#endif", "#ifdef USE_MORPHTARGETS",
						"\tattribute vec3 morphTarget0;",
						"\tattribute vec3 morphTarget1;",
						"\tattribute vec3 morphTarget2;",
						"\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS",
						"\t\tattribute vec3 morphNormal0;",
						"\t\tattribute vec3 morphNormal1;",
						"\t\tattribute vec3 morphNormal2;",
						"\t\tattribute vec3 morphNormal3;", "\t#else",
						"\t\tattribute vec3 morphTarget4;",
						"\t\tattribute vec3 morphTarget5;",
						"\t\tattribute vec3 morphTarget6;",
						"\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif",
						"#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;",
						"\tattribute vec4 skinWeight;", "#endif", "\n"
					].filter(ea).join("\n"), s = [g, ha(n), "#define SHADER_NAME " + n
						.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n
						.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "",
						"#define GAMMA_FACTOR " + m, n.useFog && n.fog ?
						"#define USE_FOG" : "", n.useFog && n.fogExp2 ?
						"#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n
						.matcap ? "#define USE_MATCAP" : "", n.envMap ?
						"#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n
						.envMap ? "#define " + p : "", n.envMap ? "#define " + v : "", n
						.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ?
						"#define USE_AOMAP" : "", n.emissiveMap ?
						"#define USE_EMISSIVEMAP" : "", n.bumpMap ?
						"#define USE_BUMPMAP" : "", n.normalMap ?
						"#define USE_NORMALMAP" : "", n.normalMap && n
						.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n
						.normalMap && n.tangentSpaceNormalMap ?
						"#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ?
						"#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ?
						"#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n
						.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n
						.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ?
						"#define USE_ROUGHNESSMAP" : "", n.metalnessMap ?
						"#define USE_METALNESSMAP" : "", n.alphaMap ?
						"#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "",
						n.transmission ? "#define USE_TRANSMISSION" : "", n
						.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n
						.thicknessMap ? "#define USE_THICKNESSMAP" : "", n
						.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ||
						n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ?
						"#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" :
						"", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n
						.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ?
						"#define FLAT_SHADED" : "", n.doubleSided ?
						"#define DOUBLE_SIDED" : "", n.flipSided ?
						"#define FLIP_SIDED" : "", n.shadowMapEnabled ?
						"#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " +
						d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" :
						"", n.physicallyCorrectLights ?
						"#define PHYSICALLY_CORRECT_LIGHTS" : "", n
						.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n
						.logarithmicDepthBuffer && n.rendererExtensionFragDepth ?
						"#define USE_LOGDEPTHBUF_EXT" : "", (n
							.extensionShaderTextureLOD || n.envMap) && n
						.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" :
						"", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;",
						"uniform bool isOrthographic;", 0 !== n.toneMapping ?
						"#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Er
						.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ki(
							"toneMapping", n.toneMapping) : "", n.dithering ?
						"#define DITHERING" : "", Er.encodings_pars_fragment, n.map ?
						Ji("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ji(
							"matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ?
						Ji("envMapTexelToLinear", n.envMapEncoding) : "", n
						.emissiveMap ? Ji("emissiveMapTexelToLinear", n
							.emissiveMapEncoding) : "", n.lightMap ? Ji(
							"lightMapTexelToLinear", n.lightMapEncoding) : "", Qi(
							"linearToOutputTexel", n.outputEncoding), n.depthPacking ?
						"#define DEPTH_PACKING " + n.depthPacking : "", "\n"
					].filter(ea).join("\n")), c = na(c = ta(c = ia(c), n), n), h = na(h =
						ta(h = ia(h), n), n), c = la(c), h = la(h), n.isWebGL2 && !0 !== n
					.isRawShaderMaterial && (_ = "#version 300 es\n", i = [
						"#define attribute in", "#define varying out",
						"#define texture2D texture"
					].join("\n") + "\n" + i, s = ["#define varying in", n
						.glslVersion === ye ? "" : "out highp vec4 pc_fragColor;", n
						.glslVersion === ye ? "" : "#define gl_FragColor pc_fragColor",
						"#define gl_FragDepthEXT gl_FragDepth",
						"#define texture2D texture", "#define textureCube texture",
						"#define texture2DProj textureProj",
						"#define texture2DLodEXT textureLod",
						"#define texture2DProjLodEXT textureProjLod",
						"#define textureCubeLodEXT textureLod",
						"#define texture2DGradEXT textureGrad",
						"#define texture2DProjGradEXT textureProjGrad",
						"#define textureCubeGradEXT textureGrad"
					].join("\n") + "\n" + s);
				var w, M, T = _ + s + h,
					E = {},
					A = {};
			}

			function fa(e, t, n, r, i, a) {
				var o = [],
					s = r.isWebGL2,
					l = r.logarithmicDepthBuffer,
					u = r.floatVertexTextures,
					c = r.maxVertexUniforms,
					h = r.vertexTextures,
					d = r.precision,
					f = {
						MeshDepthMaterial: "depth",
						MeshDistanceMaterial: "distanceRGBA",
						MeshNormalMaterial: "normal",
						MeshBasicMaterial: "basic",
						MeshLambertMaterial: "lambert",
						MeshPhongMaterial: "phong",
						MeshToonMaterial: "toon",
						MeshStandardMaterial: "physical",
						MeshPhysicalMaterial: "physical",
						MeshMatcapMaterial: "matcap",
						LineBasicMaterial: "basic",
						LineDashedMaterial: "dashed",
						PointsMaterial: "points",
						ShadowMaterial: "shadow",
						SpriteMaterial: "sprite"
					},
					p = ["precision", "isWebGL2", "supportsVertexTextures",
						"outputEncoding", "instancing", "instancingColor", "map",
						"mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode",
						"envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding",
						"aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap",
						"normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap",
						"clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap",
						"displacementMap", "specularMap", "roughnessMap", "metalnessMap",
						"gradientMap", "alphaMap", "combine", "vertexColors",
						"vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly",
						"fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation",
						"logarithmicDepthBuffer", "skinning", "maxBones",
						"useVertexTexture", "morphTargets", "morphNormals",
						"premultipliedAlpha", "numDirLights", "numPointLights",
						"numSpotLights", "numHemiLights", "numRectAreaLights",
						"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
						"shadowMapEnabled", "shadowMapType", "toneMapping",
						"physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided",
						"numClippingPlanes", "numClipIntersection", "depthPacking",
						"dithering", "sheen", "transmission", "transmissionMap",
						"thicknessMap"
					];

				function v(e) {
					var t;
					return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ?
						(console.warn(
							"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							), t = e.texture.encoding) : t = le, t
				}
				return {
					getParameters: function(i, o, p, m, g) {
						var y, x, _ = m.fog,
							w = i.isMeshStandardMaterial ? m.environment : null,
							M = t.get(i.envMap || w),
							T = f[i.type],
							E = g.isSkinnedMesh ? function(e) {
								var t = e.skeleton.bones;
								if (u) return 1024;
								var n = c,
									r = Math.floor((n - 20) / 4),
									i = Math.min(r, t.length);
								return i < t.length ? (console.warn(
									"THREE.WebGLRenderer: Skeleton has " + t
									.length + " bones. This GPU supports " + i +
									"."), 0) : i
							}(g) : 0;
						if (null !== i.precision && (d = r.getMaxPrecision(i
							.precision)) !== i.precision && console.warn(
								"THREE.WebGLProgram.getParameters:", i.precision,
								"not supported, using", d, "instead."), T) {
							var A = Lr[T];
							y = A.vertexShader, x = A.fragmentShader
						} else y = i.vertexShader, x = i.fragmentShader;
						var L = e.getRenderTarget();
						return {
							isWebGL2: s,
							shaderID: T,
							shaderName: i.type,
							vertexShader: y,
							fragmentShader: x,
							defines: i.defines,
							isRawShaderMaterial: !0 === i.isRawShaderMaterial,
							glslVersion: i.glslVersion,
							precision: d,
							instancing: !0 === g.isInstancedMesh,
							instancingColor: !0 === g.isInstancedMesh && null !== g
								.instanceColor,
							supportsVertexTextures: h,
							outputEncoding: null !== L ? v(L.texture) : e
								.outputEncoding,
							map: !!i.map,
							mapEncoding: v(i.map),
							matcap: !!i.matcap,
							matcapEncoding: v(i.matcap),
							envMap: !!M,
							envMapMode: M && M.mapping,
							envMapEncoding: v(M),
							envMapCubeUV: !!M && (M.mapping === b || M.mapping === S),
							lightMap: !!i.lightMap,
							lightMapEncoding: v(i.lightMap),
							aoMap: !!i.aoMap,
							emissiveMap: !!i.emissiveMap,
							emissiveMapEncoding: v(i.emissiveMap),
							bumpMap: !!i.bumpMap,
							normalMap: !!i.normalMap,
							objectSpaceNormalMap: 1 === i.normalMapType,
							tangentSpaceNormalMap: 0 === i.normalMapType,
							clearcoatMap: !!i.clearcoatMap,
							clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
							clearcoatNormalMap: !!i.clearcoatNormalMap,
							displacementMap: !!i.displacementMap,
							roughnessMap: !!i.roughnessMap,
							metalnessMap: !!i.metalnessMap,
							specularMap: !!i.specularMap,
							alphaMap: !!i.alphaMap,
							gradientMap: !!i.gradientMap,
							sheen: !!i.sheen,
							transmission: !!i.transmission,
							transmissionMap: !!i.transmissionMap,
							thicknessMap: !!i.thicknessMap,
							combine: i.combine,
							vertexTangents: i.normalMap && i.vertexTangents,
							vertexColors: i.vertexColors,
							vertexAlphas: !0 === i.vertexColors && g.geometry && g
								.geometry.attributes.color && 4 === g.geometry
								.attributes.color.itemSize,
							vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i
								.specularMap || i.alphaMap || i.emissiveMap || i
								.roughnessMap || i.metalnessMap || i.clearcoatMap ||
								i.clearcoatRoughnessMap || i.clearcoatNormalMap || i
								.displacementMap || i.transmission || i
								.transmissionMap || i.thicknessMap),
							uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i
								.specularMap || i.alphaMap || i.emissiveMap || i
								.roughnessMap || i.metalnessMap || i
								.clearcoatNormalMap || i.transmission || i
								.transmissionMap || i.thicknessMap || !i
								.displacementMap),
							fog: !!_,
							useFog: i.fog,
							fogExp2: _ && _.isFogExp2,
							flatShading: !!i.flatShading,
							sizeAttenuation: i.sizeAttenuation,
							logarithmicDepthBuffer: l,
							skinning: !0 === g.isSkinnedMesh && E > 0,
							maxBones: E,
							useVertexTexture: u,
							morphTargets: i.morphTargets,
							morphNormals: i.morphNormals,
							numDirLights: o.directional.length,
							numPointLights: o.point.length,
							numSpotLights: o.spot.length,
							numRectAreaLights: o.rectArea.length,
							numHemiLights: o.hemi.length,
							numDirLightShadows: o.directionalShadowMap.length,
							numPointLightShadows: o.pointShadowMap.length,
							numSpotLightShadows: o.spotShadowMap.length,
							numClippingPlanes: a.numPlanes,
							numClipIntersection: a.numIntersection,
							dithering: i.dithering,
							shadowMapEnabled: e.shadowMap.enabled && p.length > 0,
							shadowMapType: e.shadowMap.type,
							toneMapping: i.toneMapped ? e.toneMapping : 0,
							physicallyCorrectLights: e.physicallyCorrectLights,
							premultipliedAlpha: i.premultipliedAlpha,
							alphaTest: i.alphaTest,
							doubleSided: 2 === i.side,
							flipSided: 1 === i.side,
							depthPacking: void 0 !== i.depthPacking && i.depthPacking,
							index0AttributeName: i.index0AttributeName,
							extensionDerivatives: i.extensions && i.extensions
								.derivatives,
							extensionFragDepth: i.extensions && i.extensions.fragDepth,
							extensionDrawBuffers: i.extensions && i.extensions
								.drawBuffers,
							extensionShaderTextureLOD: i.extensions && i.extensions
								.shaderTextureLOD,
							rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
							rendererExtensionDrawBuffers: s || n.has(
								"WEBGL_draw_buffers"),
							rendererExtensionShaderTextureLod: s || n.has(
								"EXT_shader_texture_lod"),
							customProgramCacheKey: i.customProgramCacheKey()
						}
					},
					getProgramCacheKey: function(t) {
						var n = [];
						if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader),
								n.push(t.vertexShader)), void 0 !== t.defines)
							for (var r in t.defines) n.push(r), n.push(t.defines[r]);
						if (!1 === t.isRawShaderMaterial) {
							for (var i = 0; i < p.length; i++) n.push(t[p[i]]);
							n.push(e.outputEncoding), n.push(e.gammaFactor)
						}
						return n.push(t.customProgramCacheKey), n.join()
					},
					getUniforms: function(e) {
						var t, n = f[e.type];
						if (n) {
							var r = Lr[n];
							t = dr.clone(r.uniforms)
						} else t = e.uniforms;
						return t
					},
					acquireProgram: function(t, n) {
						for (var r, a = 0, s = o.length; a < s; a++) {
							var l = o[a];
							if (l.cacheKey === n) {
								++(r = l).usedTimes;
								break
							}
						}
						return void 0 === r && (r = new da(e, n, t, i), o.push(r)), r
					},
					releaseProgram: function(e) {
						if (0 == --e.usedTimes) {
							var t = o.indexOf(e);
							o[t] = o[o.length - 1], o.pop(), e.destroy()
						}
					},
					programs: o
				}
			}

			function pa() {
				var e = new WeakMap;
				return {
					get: function(t) {
						var n = e.get(t);
						return void 0 === n && (n = {}, e.set(t, n)), n
					},
					remove: function(t) {
						e.delete(t)
					},
					update: function(t, n, r) {
						e.get(t)[n] = r
					},
					dispose: function() {
						e = new WeakMap
					}
				}
			}

			function va(e, t) {
				return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e
					.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e
					.program !== t.program ? e.program.id - t.program.id : e.material.id !==
					t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t
					.z : e.id - t.id
			}

			function ma(e, t) {
				return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e
					.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !==
					t.z ? t.z - e.z : e.id - t.id
			}

			function ga(e) {
				var t = [],
					n = 0,
					r = [],
					i = [],
					a = [],
					o = {
						id: -1
					};

				function s(r, i, a, s, l, u) {
					var c = t[n],
						h = e.get(a);
					return void 0 === c ? (c = {
						id: r.id,
						object: r,
						geometry: i,
						material: a,
						program: h.program || o,
						groupOrder: s,
						renderOrder: r.renderOrder,
						z: l,
						group: u
					}, t[n] = c) : (c.id = r.id, c.object = r, c.geometry = i, c
						.material = a, c.program = h.program || o, c.groupOrder = s, c
						.renderOrder = r.renderOrder, c.z = l, c.group = u), n++, c
				}
				return {
					opaque: r,
					transmissive: i,
					transparent: a,
					init: function() {
						n = 0, r.length = 0, i.length = 0, a.length = 0
					},
					push: function(e, t, n, o, l, u) {
						var c = s(e, t, n, o, l, u);
						n.transmission > 0 ? i.push(c) : !0 === n.transparent ? a.push(
							c) : r.push(c)
					},
					unshift: function(e, t, n, o, l, u) {
						var c = s(e, t, n, o, l, u);
						n.transmission > 0 ? i.unshift(c) : !0 === n.transparent ? a
							.unshift(c) : r.unshift(c)
					},
					finish: function() {
						for (var e = n, r = t.length; e < r; e++) {
							var i = t[e];
							if (null === i.id) break;
							i.id = null, i.object = null, i.geometry = null, i
								.material = null, i.program = null, i.group = null
						}
					},
					sort: function(e, t) {
						r.length > 1 && r.sort(e || va), i.length > 1 && i.sort(t ||
							ma), a.length > 1 && a.sort(t || ma)
					}
				}
			}

			function ya(e) {
				var t = new WeakMap;
				return {
					get: function(n, r) {
						var i;
						return !1 === t.has(n) ? (i = new ga(e), t.set(n, [i])) : r >= t
							.get(n).length ? (i = new ga(e), t.get(n).push(i)) : i = t
							.get(n)[r], i
					},
					dispose: function() {
						t = new WeakMap
					}
				}
			}

			function xa() {
				var e = {};
				return {
					get: function(t) {
						if (void 0 !== e[t.id]) return e[t.id];
						var n;
						switch (t.type) {
							case "DirectionalLight":
								n = {
									direction: new je,
									color: new yn
								};
								break;
							case "SpotLight":
								n = {
									position: new je,
									direction: new je,
									color: new yn,
									distance: 0,
									coneCos: 0,
									penumbraCos: 0,
									decay: 0
								};
								break;
							case "PointLight":
								n = {
									position: new je,
									color: new yn,
									distance: 0,
									decay: 0
								};
								break;
							case "HemisphereLight":
								n = {
									direction: new je,
									skyColor: new yn,
									groundColor: new yn
								};
								break;
							case "RectAreaLight":
								n = {
									color: new yn,
									position: new je,
									halfWidth: new je,
									halfHeight: new je
								}
						}
						return e[t.id] = n, n
					}
				}
			}
			var _a = 0;

			function ba(e, t) {
				return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
			}

			function wa(e, t) {
				for (var n = new xa, r = function() {
						var e = {};
						return {
							get: function(t) {
								if (void 0 !== e[t.id]) return e[t.id];
								var n;
								switch (t.type) {
									case "DirectionalLight":
									case "SpotLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new Ie
										};
										break;
									case "PointLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new Ie,
											shadowCameraNear: 1,
											shadowCameraFar: 1e3
										}
								}
								return e[t.id] = n, n
							}
						}
					}(), i = {
						version: 0,
						hash: {
							directionalLength: -1,
							pointLength: -1,
							spotLength: -1,
							rectAreaLength: -1,
							hemiLength: -1,
							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						},
						ambient: [0, 0, 0],
						probe: [],
						directional: [],
						directionalShadow: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadow: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						rectAreaLTC1: null,
						rectAreaLTC2: null,
						point: [],
						pointShadow: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					}, a = 0; a < 9; a++) i.probe.push(new je);
				var o = new je,
					s = new wt,
					l = new wt;
				return {
					setup: function(a) {
						for (var o = 0, s = 0, l = 0, u = 0; u < 9; u++) i.probe[u].set(
							0, 0, 0);
						var c = 0,
							h = 0,
							d = 0,
							f = 0,
							p = 0,
							v = 0,
							m = 0,
							g = 0;
						a.sort(ba);
						for (var y = 0, x = a.length; y < x; y++) {
							var _ = a[y],
								b = _.color,
								w = _.intensity,
								M = _.distance,
								S = _.shadow && _.shadow.map ? _.shadow.map.texture :
								null;
							if (_.isAmbientLight) o += b.r * w, s += b.g * w, l += b.b *
								w;
							else if (_.isLightProbe)
								for (var T = 0; T < 9; T++) i.probe[T].addScaledVector(_
									.sh.coefficients[T], w);
							else if (_.isDirectionalLight) {
								var E = n.get(_);
								if (E.color.copy(_.color).multiplyScalar(_.intensity), _
									.castShadow) {
									var A = _.shadow,
										L = r.get(_);
									L.shadowBias = A.bias, L.shadowNormalBias = A
										.normalBias, L.shadowRadius = A.radius, L
										.shadowMapSize = A.mapSize, i.directionalShadow[
											c] = L, i.directionalShadowMap[c] = S, i
										.directionalShadowMatrix[c] = _.shadow.matrix,
										v++
								}
								i.directional[c] = E, c++
							} else if (_.isSpotLight) {
								var k = n.get(_);
								if (k.position.setFromMatrixPosition(_.matrixWorld), k
									.color.copy(b).multiplyScalar(w), k.distance = M, k
									.coneCos = Math.cos(_.angle), k.penumbraCos = Math
									.cos(_.angle * (1 - _.penumbra)), k.decay = _.decay,
									_.castShadow) {
									var R = _.shadow,
										C = r.get(_);
									C.shadowBias = R.bias, C.shadowNormalBias = R
										.normalBias, C.shadowRadius = R.radius, C
										.shadowMapSize = R.mapSize, i.spotShadow[d] = C,
										i.spotShadowMap[d] = S, i.spotShadowMatrix[d] =
										_.shadow.matrix, g++
								}
								i.spot[d] = k, d++
							} else if (_.isRectAreaLight) {
								var P = n.get(_);
								P.color.copy(b).multiplyScalar(w), P.halfWidth.set(.5 *
									_.width, 0, 0), P.halfHeight.set(0, .5 * _
									.height, 0), i.rectArea[f] = P, f++
							} else if (_.isPointLight) {
								var I = n.get(_);
								if (I.color.copy(_.color).multiplyScalar(_.intensity), I
									.distance = _.distance, I.decay = _.decay, _
									.castShadow) {
									var D = _.shadow,
										N = r.get(_);
									N.shadowBias = D.bias, N.shadowNormalBias = D
										.normalBias, N.shadowRadius = D.radius, N
										.shadowMapSize = D.mapSize, N.shadowCameraNear =
										D.camera.near, N.shadowCameraFar = D.camera.far,
										i.pointShadow[h] = N, i.pointShadowMap[h] = S, i
										.pointShadowMatrix[h] = _.shadow.matrix, m++
								}
								i.point[h] = I, h++
							} else if (_.isHemisphereLight) {
								var O = n.get(_);
								O.skyColor.copy(_.color).multiplyScalar(w), O
									.groundColor.copy(_.groundColor).multiplyScalar(w),
									i.hemi[p] = O, p++
							}
						}
						f > 0 && (t.isWebGL2 || !0 === e.has(
								"OES_texture_float_linear") ? (i.rectAreaLTC1 = Ar
									.LTC_FLOAT_1, i.rectAreaLTC2 = Ar.LTC_FLOAT_2) : !
								0 === e.has("OES_texture_half_float_linear") ? (i
									.rectAreaLTC1 = Ar.LTC_HALF_1, i.rectAreaLTC2 = Ar
									.LTC_HALF_2) : console.error(
									"THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
									)), i.ambient[0] = o, i.ambient[1] = s, i.ambient[
							2] = l;
						var B = i.hash;
						B.directionalLength === c && B.pointLength === h && B
							.spotLength === d && B.rectAreaLength === f && B
							.hemiLength === p && B.numDirectionalShadows === v && B
							.numPointShadows === m && B.numSpotShadows === g || (i
								.directional.length = c, i.spot.length = d, i.rectArea
								.length = f, i.point.length = h, i.hemi.length = p, i
								.directionalShadow.length = v, i.directionalShadowMap
								.length = v, i.pointShadow.length = m, i.pointShadowMap
								.length = m, i.spotShadow.length = g, i.spotShadowMap
								.length = g, i.directionalShadowMatrix.length = v, i
								.pointShadowMatrix.length = m, i.spotShadowMatrix
								.length = g, B.directionalLength = c, B.pointLength = h,
								B.spotLength = d, B.rectAreaLength = f, B.hemiLength =
								p, B.numDirectionalShadows = v, B.numPointShadows = m, B
								.numSpotShadows = g, i.version = _a++)
					},
					setupView: function(e, t) {
						for (var n = 0, r = 0, a = 0, u = 0, c = 0, h = t
								.matrixWorldInverse, d = 0, f = e.length; d < f; d++) {
							var p = e[d];
							if (p.isDirectionalLight) {
								var v = i.directional[n];
								v.direction.setFromMatrixPosition(p.matrixWorld), o
									.setFromMatrixPosition(p.target.matrixWorld), v
									.direction.sub(o), v.direction.transformDirection(
									h), n++
							} else if (p.isSpotLight) {
								var m = i.spot[a];
								m.position.setFromMatrixPosition(p.matrixWorld), m
									.position.applyMatrix4(h), m.direction
									.setFromMatrixPosition(p.matrixWorld), o
									.setFromMatrixPosition(p.target.matrixWorld), m
									.direction.sub(o), m.direction.transformDirection(
									h), a++
							} else if (p.isRectAreaLight) {
								var g = i.rectArea[u];
								g.position.setFromMatrixPosition(p.matrixWorld), g
									.position.applyMatrix4(h), l.identity(), s.copy(p
										.matrixWorld), s.premultiply(h), l
									.extractRotation(s), g.halfWidth.set(.5 * p.width,
										0, 0), g.halfHeight.set(0, .5 * p.height, 0), g
									.halfWidth.applyMatrix4(l), g.halfHeight
									.applyMatrix4(l), u++
							} else if (p.isPointLight) {
								var y = i.point[r];
								y.position.setFromMatrixPosition(p.matrixWorld), y
									.position.applyMatrix4(h), r++
							} else if (p.isHemisphereLight) {
								var x = i.hemi[c];
								x.direction.setFromMatrixPosition(p.matrixWorld), x
									.direction.transformDirection(h), x.direction
									.normalize(), c++
							}
						}
					},
					state: i
				}
			}

			function Ma(e, t) {
				var n = new wa(e, t),
					r = [],
					i = [];
				return {
					init: function() {
						r.length = 0, i.length = 0
					},
					state: {
						lightsArray: r,
						shadowsArray: i,
						lights: n
					},
					setupLights: function() {
						n.setup(r)
					},
					setupLightsView: function(e) {
						n.setupView(r, e)
					},
					pushLight: function(e) {
						r.push(e)
					},
					pushShadow: function(e) {
						i.push(e)
					}
				}
			}

			function Sa(e, t) {
				var n = new WeakMap;
				return {
					get: function(r) {
						var i, a = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 0;
						return !1 === n.has(r) ? (i = new Ma(e, t), n.set(r, [i])) :
							a >= n.get(r).length ? (i = new Ma(e, t), n.get(r).push(
							i)) : i = n.get(r)[a], i
					},
					dispose: function() {
						n = new WeakMap
					}
				}
			}
			var Ta = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshDepthMaterial", r.depthPacking = 3200, r.morphTargets = !1,
						r.map = null, r.alphaMap = null, r.displacementMap = null, r
						.displacementScale = 1, r.displacementBias = 0, r.wireframe = !
						1, r.wireframeLinewidth = 1, r.fog = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.depthPacking = e.depthPacking, this
							.morphTargets = e.morphTargets, this.map = e
							.map, this.alphaMap = e.alphaMap, this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this.wireframe = e.wireframe, this
							.wireframeLinewidth = e.wireframeLinewidth,
							this
					}
				}]), n
			}(hn);
			Ta.prototype.isMeshDepthMaterial = !0;
			var Ea = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshDistanceMaterial", r.referencePosition = new je, r
						.nearDistance = 1, r.farDistance = 1e3, r.morphTargets = !1, r
						.map = null, r.alphaMap = null, r.displacementMap = null, r
						.displacementScale = 1, r.displacementBias = 0, r.fog = !1, r
						.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.referencePosition.copy(e
								.referencePosition), this.nearDistance =
							e.nearDistance, this.farDistance = e
							.farDistance, this.morphTargets = e
							.morphTargets, this.map = e.map, this
							.alphaMap = e.alphaMap, this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this
					}
				}]), n
			}(hn);

			function Aa(e, t, n) {
				var r = new wr,
					i = new Ie,
					a = new Ie,
					o = new He,
					s = [],
					l = [],
					u = {},
					c = n.maxTextureSize,
					h = {
						0: 1,
						1: 0,
						2: 2
					},
					d = new fr({
						defines: {
							SAMPLE_RATE: 2 / 8,
							HALF_SAMPLE_RATE: 1 / 8
						},
						uniforms: {
							shadow_pass: {
								value: null
							},
							resolution: {
								value: new Ie
							},
							radius: {
								value: 4
							}
						},
						vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
						fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
					}),
					f = d.clone();
				f.defines.HORIZONTAL_PASS = 1;
				var p = new Vn;
				p.setAttribute("position", new wn(new Float32Array([-1, -1, .5, 3, -1, .5, -
					1, 3, .5
				]), 3));
				var v = new sr(p, d),
					m = this;

				function g(n, r) {
					var i = t.update(v);
					d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution
						.value = n.mapSize, d.uniforms.radius.value = n.radius, e
						.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r,
							null, i, d, v, null), f.uniforms.shadow_pass.value = n.mapPass
						.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius
						.value = n.radius, e.setRenderTarget(n.map), e.clear(), e
						.renderBufferDirect(r, null, i, f, v, null)
				}

				function y(e) {
					var t = e << 0,
						n = s[t];
					return void 0 === n && (n = new Ta({
						depthPacking: 3201,
						morphTargets: e
					}), s[t] = n), n
				}

				function x(e) {
					var t = e << 0,
						n = l[t];
					return void 0 === n && (n = new Ea({
						morphTargets: e
					}), l[t] = n), n
				}

				function _(t, n, r, i, a, o, s) {
					var l = null,
						c = y,
						d = t.customDepthMaterial;
					if (!0 === i.isPointLight && (c = x, d = t.customDistanceMaterial),
						void 0 === d) {
						var f = !1;
						!0 === r.morphTargets && (f = n.morphAttributes && n.morphAttributes
							.position && n.morphAttributes.position.length > 0), l = c(
							f)
					} else l = d;
					if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r
						.clippingPlanes.length) {
						var p = l.uuid,
							v = r.uuid,
							m = u[p];
						void 0 === m && (m = {}, u[p] = m);
						var g = m[v];
						void 0 === g && (g = l.clone(), m[v] = g), l = g
					}
					return l.visible = r.visible, l.wireframe = r.wireframe, l.side = 3 ===
						s ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r
						.shadowSide ? r.shadowSide : h[r.side], l.clipShadows = r
						.clipShadows, l.clippingPlanes = r.clippingPlanes, l
						.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r
						.wireframeLinewidth, l.linewidth = r.linewidth, !0 === i
						.isPointLight && !0 === l.isMeshDistanceMaterial && (l
							.referencePosition.setFromMatrixPosition(i.matrixWorld), l
							.nearDistance = a, l.farDistance = o), l
				}

				function b(n, i, a, o, s) {
					if (!1 !== n.visible) {
						if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n
							.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!
								n.frustumCulled || r.intersectsObject(n))) {
							n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n
								.matrixWorld);
							var l = t.update(n),
								u = n.material;
							if (Array.isArray(u))
								for (var c = l.groups, h = 0, d = c.length; h < d; h++) {
									var f = c[h],
										p = u[f.materialIndex];
									if (p && p.visible) {
										var v = _(n, l, p, o, a.near, a.far, s);
										e.renderBufferDirect(a, null, l, v, n, f)
									}
								} else if (u.visible) {
									var m = _(n, l, u, o, a.near, a.far, s);
									e.renderBufferDirect(a, null, l, m, n, null)
								}
						}
						for (var g = n.children, y = 0, x = g.length; y < x; y++) b(g[y], i,
							a, o, s)
					}
				}
				this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type =
					1, this.render = function(t, n, s) {
						if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m
								.needsUpdate) && 0 !== t.length) {
							var l = e.getRenderTarget(),
								u = e.getActiveCubeFace(),
								h = e.getActiveMipmapLevel(),
								d = e.state;
							d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d
								.buffers.depth.setTest(!0), d.setScissorTest(!1);
							for (var f = 0, p = t.length; f < p; f++) {
								var v = t[f],
									y = v.shadow;
								if (void 0 !== y) {
									if (!1 !== y.autoUpdate || !1 !== y.needsUpdate) {
										i.copy(y.mapSize);
										var x = y.getFrameExtents();
										if (i.multiply(x), a.copy(y.mapSize), (i.x > c || i
												.y > c) && (i.x > c && (a.x = Math.floor(c /
													x.x), i.x = a.x * x.x, y.mapSize.x =
												a.x), i.y > c && (a.y = Math.floor(c / x
													.y), i.y = a.y * x.y, y.mapSize.y =
												a.y)), null === y.map && !y
											.isPointLightShadow && 3 === this.type) {
											var _ = {
												minFilter: C,
												magFilter: C,
												format: U
											};
											y.map = new Ue(i.x, i.y, _), y.map.texture
												.name = v.name + ".shadowMap", y.mapPass =
												new Ue(i.x, i.y, _), y.camera
												.updateProjectionMatrix()
										}
										if (null === y.map) {
											var w = {
												minFilter: L,
												magFilter: L,
												format: U
											};
											y.map = new Ue(i.x, i.y, w), y.map.texture
												.name = v.name + ".shadowMap", y.camera
												.updateProjectionMatrix()
										}
										e.setRenderTarget(y.map), e.clear();
										for (var M = y.getViewportCount(), S = 0; S <
											M; S++) {
											var T = y.getViewport(S);
											o.set(a.x * T.x, a.y * T.y, a.x * T.z, a.y * T
												.w), d.viewport(o), y.updateMatrices(v,
												S), r = y.getFrustum(), b(n, s, y
												.camera, v, this.type)
										}
										y.isPointLightShadow || 3 !== this.type || g(y, s),
											y.needsUpdate = !1
									}
								} else console.warn("THREE.WebGLShadowMap:", v,
									"has no shadow.")
							}
							m.needsUpdate = !1, e.setRenderTarget(l, u, h)
						}
					}
			}

			function La(e, t, n) {
				var i, a = n.isWebGL2,
					o = new function() {
						var t = !1,
							n = new He,
							r = null,
							i = new He(0, 0, 0, 0);
						return {
							setMask: function(n) {
								r === n || t || (e.colorMask(n, n, n, n), r = n)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t, r, a, o, s) {
								!0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o),
									!1 === i.equals(n) && (e.clearColor(t, r, a, o), i
										.copy(n))
							},
							reset: function() {
								t = !1, r = null, i.set(-1, 0, 0, 0)
							}
						}
					},
					s = new function() {
						var t = !1,
							n = null,
							r = null,
							i = null;
						return {
							setTest: function(e) {
								e ? H(2929) : U(2929)
							},
							setMask: function(r) {
								n === r || t || (e.depthMask(r), n = r)
							},
							setFunc: function(t) {
								if (r !== t) {
									if (t) switch (t) {
										case 0:
											e.depthFunc(512);
											break;
										case 1:
											e.depthFunc(519);
											break;
										case 2:
											e.depthFunc(513);
											break;
										case 3:
											e.depthFunc(515);
											break;
										case 4:
											e.depthFunc(514);
											break;
										case 5:
											e.depthFunc(518);
											break;
										case 6:
											e.depthFunc(516);
											break;
										case 7:
											e.depthFunc(517);
											break;
										default:
											e.depthFunc(515)
									} else e.depthFunc(515);
									r = t
								}
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								i !== t && (e.clearDepth(t), i = t)
							},
							reset: function() {
								t = !1, n = null, r = null, i = null
							}
						}
					},
					l = new function() {
						var t = !1,
							n = null,
							r = null,
							i = null,
							a = null,
							o = null,
							s = null,
							l = null,
							u = null;
						return {
							setTest: function(e) {
								t || (e ? H(2960) : U(2960))
							},
							setMask: function(r) {
								n === r || t || (e.stencilMask(r), n = r)
							},
							setFunc: function(t, n, o) {
								r === t && i === n && a === o || (e.stencilFunc(t, n,
									o), r = t, i = n, a = o)
							},
							setOp: function(t, n, r) {
								o === t && s === n && l === r || (e.stencilOp(t, n, r),
									o = t, s = n, l = r)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								u !== t && (e.clearStencil(t), u = t)
							},
							reset: function() {
								t = !1, n = null, r = null, i = null, a = null, o =
									null, s = null, l = null, u = null
							}
						}
					},
					u = {},
					c = null,
					h = {},
					f = null,
					p = !1,
					v = null,
					m = null,
					g = null,
					y = null,
					x = null,
					_ = null,
					b = null,
					w = !1,
					M = null,
					S = null,
					T = null,
					E = null,
					A = null,
					L = (35661),
					k = !1,
					R = 0,
					C = {},
					I = {},
					D = (3088),
					N = (2978),
					O = (new He).fromArray(D),
					B = (new He).fromArray(N);

				var F = {};
				function U(t) {
					!1 !== u[t] && (e.disable(t), u[t] = !1)
				}
				var G = (i = {}, (0, d.default)(i, r, 32774), (0, d.default)(i, 101, 32778),
					(0, d.default)(i, 102, 32779), i);
				if (a) G[103] = 32775, G[104] = 32776;
				else {
					var V = t.get("EXT_blend_minmax");
					null !== V && (G[103] = V.MIN_EXT, G[104] = V.MAX_EXT)
				}
				var W = {
					200: 0,
					201: 1,
					202: 768,
					204: 770,
					210: 776,
					208: 774,
					206: 772,
					203: 769,
					205: 771,
					209: 775,
					207: 773
				};

				function j(t, n, i, a, o, s, l, u) {
					if (0 !== t) {
						if (!1 === p && (H(3042), p = !0), 5 === t) o = o || n, s = s || i,
							l = l || a, n === m && o === x || (e.blendEquationSeparate(G[n],
								G[o]), m = n, x = o), i === g && a === y && s === _ && l ===
							b || (e.blendFuncSeparate(W[i], W[a], W[s], W[l]), g = i, y = a,
								_ = s, b = l), v = t, w = null;
						else if (t !== v || u !== w) {
							if (m === r && x === r || (e.blendEquation(32774), m = r, x =
								r), u) switch (t) {
								case 1:
									e.blendFuncSeparate(1, 771, 1, 771);
									break;
								case 2:
									e.blendFunc(1, 1);
									break;
								case 3:
									e.blendFuncSeparate(0, 0, 769, 771);
									break;
								case 4:
									e.blendFuncSeparate(0, 768, 0, 770);
									break;
								default:
									console.error(
										"THREE.WebGLState: Invalid blending: ", t)
							} else switch (t) {
								case 1:
									e.blendFuncSeparate(770, 771, 1, 771);
									break;
								case 2:
									e.blendFunc(770, 1);
									break;
								case 3:
									e.blendFunc(0, 769);
									break;
								case 4:
									e.blendFunc(0, 768);
									break;
								default:
									console.error(
										"THREE.WebGLState: Invalid blending: ",
										t)
							}
							g = null, y = null, _ = null, b = null, v = t, w = u
						}
					} else !0 === p && (U(3042), p = !1)
				}
				function X(t) {
					0 !== t ? (H(2884), t !== S && (1 === t ? e.cullFace(1029) : 2 === t ? e
						.cullFace(1028) : e.cullFace(1032))) : U(2884), S = t
				}

				function Y(t, n, r) {
					t ? (H(32823), E === n && A === r || (e.polygonOffset(n, r), E = n, A =
						r)) : U(32823)
				}

				function $(t) {
					void 0 === t && (t = 33984 + L - 1), P !== t && (e.activeTexture(t), P =
						t)
				}
				return {
					buffers: {
						color: o,
						depth: s,
						stencil: l
					},
					enable: H,
					disable: U,
					bindFramebuffer: function(t, n) {
						return null === n && null !== c && (n = c), h[t] !== n && (e
							.bindFramebuffer(t, n), h[t] = n, a && (36009 === t && (
								h[36160] = n), 36160 === t && (h[36009] = n)), !0)
					},
					bindXRFramebuffer: function(t) {
						t !== c && (e.bindFramebuffer(36160, t), c = t)
					},
					setBlending: j,
					setFlipSided: q,
					setCullFace: X,
					setLineWidth: function(t) {
						t !== T && (k && e.lineWidth(t), T = t)
					},
					setPolygonOffset: Y,
					setScissorTest: function(e) {
						e ? H(3089) : U(3089)
					},
					activeTexture: $,
					bindTexture: function(t, n) {
						null === P && $();
						var r = I[P];
						void 0 === r && (r = {
							type: void 0,
							texture: void 0
						}, I[P] = r), r.type === t && r.texture === n || (e
							.bindTexture(t, n || F[t]), r.type = t, r.texture = n)
					},
					unbindTexture: function() {
						var t = I[P];
						void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type,
							null), t.type = void 0, t.texture = void 0)
					},
					compressedTexImage2D: function() {
						try {
							e.compressedTexImage2D.apply(e, arguments)
						} catch (e) {
							console.error("THREE.WebGLState:", e)
						}
					},
					texImage2D: function() {
						try {
							e.texImage2D.apply(e, arguments)
						} catch (e) {
							console.error("THREE.WebGLState:", e)
						}
					},
					texImage3D: function() {
						try {
							e.texImage3D.apply(e, arguments)
						} catch (e) {
							console.error("THREE.WebGLState:", e)
						}
					},
					scissor: function(t) {
						!1 === O.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), O.copy(t))
					},
					viewport: function(t) {
						!1 === B.equals(t)
					},
					reset: function() {
						e.disable(3042), e.disable(2884), e.disable(2929), e.disable(
								32823), e.disable(3089), e.disable(2960), e.disable(
								32926), e.blendEquation(32774), e.blendFunc(1, 0), e
							.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0),
							e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513),
							e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(
								519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e
							.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e
							.polygonOffset(0, 0), e.activeTexture(33984), e
							.bindFramebuffer(36160, null), !0 === a && (e
								.bindFramebuffer(36009, null), e.bindFramebuffer(36008,
									null)), e.useProgram(null), e.lineWidth(1), e
							.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(
								0, 0, e.canvas.width, e.canvas.height), u = {}, P =
							null, I = {}, c = null, h = {}, f = null, p = !1, v = null,
							m = null, g = null, y = null, x = null, _ = null, b = null,
							w = !1, M = null, S = null, T = null, E = null, A = null, O
							.set(0, 0, e.canvas.width, e.canvas.height), B.set(0, 0, e
								.canvas.width, e.canvas.height), o.reset(), s.reset(), l
							.reset()
					}
				}
			}

			function ka(e, t, n, r, i, a, o) {
				var s, l, u, c = i.isWebGL2,
					h = i.maxTextures,
					f = i.maxCubemapSize,
					p = i.maxTextureSize,
					v = i.maxSamples,
					m = new WeakMap,
					g = !1;
				try {
					g = "undefined" != typeof OffscreenCanvas && null !==
						new OffscreenCanvas(1, 1).getContext("2d")
				} catch (e) {}

				function y(e, t) {
					return g ? new OffscreenCanvas(e, t) : document.createElementNS(
						"http://www.w3.org/1999/xhtml", "canvas")
				}

				function x(e, t, n, r) {
					var i = 1;
					if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e
							.height)), i < 1 || !0 === t) {
						if ("undefined" != typeof HTMLImageElement &&
							e instanceof HTMLImageElement || "undefined" !=
							typeof HTMLCanvasElement && e instanceof HTMLCanvasElement ||
							"undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
							var a = t ? Ce : Math.floor,
								o = a(i * e.width),
								s = a(i * e.height);
							void 0 === u && (u = y(o, s));
							var l = n ? y(o, s) : u;
							return l.width = o, l.height = s, l.getContext("2d").drawImage(
								e, 0, 0, o, s),l
						}
						return "data" in e && console.warn(
							"THREE.WebGLRenderer: Image in DataTexture is too big (" + e
							.width + "x" + e.height + ")."), e
					}
					return e
				}

				function _(e) {
					return ke(e.width) && ke(e.height)
				}

				function b(e, t) {
					return e.generateMipmaps && t && e.minFilter !== L && e.minFilter !== C
				}

				function w(t, n, i, a) {
					e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log2(Math.max(i, a))
				}

				function M(n, r, i) {
					if (!1 === c) return r;
					if (null !== n) {
						if (void 0 !== e[n]) return e[n];
						console.warn(
							"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
							n + "'")
					}
					var a = r;
					return 6403 === r && (5126 === i && (a = 33326), 5131 === i && (a =
							33325), 5121 === i && (a = 33321)), 6407 === r && (5126 === i &&
							(a = 34837), 5131 === i && (a = 34843), 5121 === i && (a =
								32849)), 6408 === r && (5126 === i && (a = 34836), 5131 ===
							i && (a = 34842), 5121 === i && (a = 32856)), 33325 !== a &&
						33326 !== a && 34842 !== a && 34836 !== a || t.get(
							"EXT_color_buffer_float"), a
				}

				function S(e) {
					return e === L || e === k || e === R ? 9728 : 9729
				}

				function D(t) {
					var n = t.target;
					n.removeEventListener("dispose", D),
						function(t) {
							var n = r.get(t);
							void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture),
								r.remove(t))
						}(n), n.isVideoTexture && m.delete(n), o.memory.textures--
				}

				function W(t) {
					var n = t.target;
					n.removeEventListener("dispose", W),
						function(t) {
							var n = t.texture,
								i = r.get(t),
								a = r.get(n);
							if (t) {
								if (void 0 !== a.__webglTexture && (e.deleteTexture(a
										.__webglTexture), o.memory.textures--), t
									.depthTexture && t.depthTexture.dispose(), t
									.isWebGLCubeRenderTarget)
									for (var s = 0; s < 6; s++) e.deleteFramebuffer(i
											.__webglFramebuffer[s]), i.__webglDepthbuffer &&
										e.deleteRenderbuffer(i.__webglDepthbuffer[s]);
								else e.deleteFramebuffer(i.__webglFramebuffer), i
									.__webglDepthbuffer && e.deleteRenderbuffer(i
										.__webglDepthbuffer), i
									.__webglMultisampledFramebuffer && e.deleteFramebuffer(i
										.__webglMultisampledFramebuffer), i
									.__webglColorRenderbuffer && e.deleteRenderbuffer(i
										.__webglColorRenderbuffer), i
									.__webglDepthRenderbuffer && e.deleteRenderbuffer(i
										.__webglDepthRenderbuffer);
								if (t.isWebGLMultipleRenderTargets)
									for (var l = 0, u = n.length; l < u; l++) {
										var c = r.get(n[l]);
										c.__webglTexture && (e.deleteTexture(c
												.__webglTexture), o.memory.textures--), r
											.remove(n[l])
									}
								r.remove(n), r.remove(t)
							}
						}(n)
				}
				var j = 0;

				function q(e, t) {
					var i = r.get(e);
					if (e.isVideoTexture && function(e) {
							var t = o.render.frame;
							m.get(e) !== t && (m.set(e, t), e.update())
						}(e), e.version > 0 && i.__version !== e.version) {
						var a = e.image;
						if (void 0 === a) console.warn(
							"THREE.WebGLRenderer: Texture marked for update but image is undefined"
							);
						else {
							if (!1 !== a.complete) return void Q(i, e, t);
							console.warn(
								"THREE.WebGLRenderer: Texture marked for update but image is incomplete"
								)
						}
					}
					n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture)
				}

				function X(t, i) {
					var o = r.get(t);
					t.version > 0 && o.__version !== t.version ? function(t, r, i) {
						if (6 === r.image.length) {
							J(t, r), n.activeTexture(33984 + i), n.bindTexture(34067, t
									.__webglTexture), e.pixelStorei(37440, r.flipY), e
								.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(
									3317, r.unpackAlignment), e.pixelStorei(37443, 0);
							for (var o = r && (r.isCompressedTexture || r.image[0]
										.isCompressedTexture), s = r.image[0] && r
									.image[0].isDataTexture, l = [], u = 0; u < 6; u++)
								l[u] = o || s ? s ? r.image[u].image : r.image[u] : x(r
									.image[u], !1, !0, f);
							var h, d = l[0],
								p = _(d) || c,
								v = a.convert(r.format),
								m = a.convert(r.type),
								g = M(r.internalFormat, v, m);
							if (Z(34067, r, p), o) {
								for (var y = 0; y < 6; y++) {
									h = l[y].mipmaps;
									for (var S = 0; S < h.length; S++) {
										var T = h[S];
										r.format !== U && r.format !== H ? null !== v ?
											n.compressedTexImage2D(34069 + y, S, g, T
												.width, T.height, 0, T.data) : console
											.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
												) : n.texImage2D(34069 + y, S, g, T
												.width, T.height, 0, v, m, T.data)
									}
								}
								t.__maxMipLevel = h.length - 1
							} else {
								h = r.mipmaps;
								for (var E = 0; E < 6; E++)
									if (s) {
										n.texImage2D(34069 + E, 0, g, l[E].width, l[E]
											.height, 0, v, m, l[E].data);
										for (var A = 0; A < h.length; A++) {
											var L = h[A].image[E].image;
											n.texImage2D(34069 + E, A + 1, g, L.width, L
												.height, 0, v, m, L.data)
										}
									} else {
										n.texImage2D(34069 + E, 0, g, v, m, l[E]);
										for (var k = 0; k < h.length; k++) {
											var R = h[k];
											n.texImage2D(34069 + E, k + 1, g, v, m, R
												.image[E])
										}
									} t.__maxMipLevel = h.length
							}
							b(r, p) && w(34067, r, d.width, d.height), t.__version = r
								.version, r.onUpdate && r.onUpdate(r)
						}
					}(o, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o
						.__webglTexture))
				}
				var Y = (s = {}, (0, d.default)(s, T, 10497), (0, d.default)(s, E, 33071), (
						0, d.default)(s, A, 33648), s),
					$ = (l = {}, (0, d.default)(l, L, 9728), (0, d.default)(l, k, 9984), (0,
						d.default)(l, R, 9986), (0, d.default)(l, C, 9729), (0, d
						.default)(l, P, 9985), (0, d.default)(l, I, 9987), l);

				function Z(n, a, o) {
					if (o ? (e.texParameteri(n, 10242, Y[a.wrapS]), e.texParameteri(n,
								10243, Y[a.wrapT]), 32879 !== n && 35866 !== n || e
							.texParameteri(n, 32882, Y[a.wrapR]), e.texParameteri(n, 10240,
								$[a.magFilter]), e.texParameteri(n, 10241, $[a.minFilter])
							) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243,
								33071), 32879 !== n && 35866 !== n || e.texParameteri(n,
								32882, 33071), a.wrapS === E && a.wrapT === E || console
							.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
								), e.texParameteri(n, 10240, S(a.magFilter)), e
							.texParameteri(n, 10241, S(a.minFilter)), a.minFilter !== L && a
							.minFilter !== C && console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
								)), !0 === t.has("EXT_texture_filter_anisotropic")) {
						var s = t.get("EXT_texture_filter_anisotropic");
						if (a.type === B && !1 === t.has("OES_texture_float_linear"))
					return;
						if (!1 === c && a.type === z && !1 === t.has(
								"OES_texture_half_float_linear")) return;
						(a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e
							.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a
								.anisotropy, i.getMaxAnisotropy())), r.get(a)
							.__currentAnisotropy = a.anisotropy)
					}
				}

				function J(t, n) {
					void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener(
							"dispose", D), t.__webglTexture = e.createTexture(), o
						.memory.textures++)
				}

				function Q(t, r, i) {
					var o = 3553;
					r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879),
						J(t, r), n.activeTexture(33984 + i), n.bindTexture(o, t
							.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(
							37441, r.premultiplyAlpha), e.pixelStorei(3317, r
							.unpackAlignment), e.pixelStorei(37443, 0);
					var s, l = function(e) {
							return !c && (e.wrapS !== E || e.wrapT !== E || e.minFilter !==
								L && e.minFilter !== C)
						}(r) && !1 === _(r.image),
						u = x(r.image, l, !1, p),
						h = _(u) || c,
						d = a.convert(r.format),
						f = a.convert(r.type),
						v = M(r.internalFormat, d, f);
					Z(o, r, h);
					var m = r.mipmaps;
					if (r.isDepthTexture) v = 6402, c ? v = r.type === B ? 36012 : r
						.type === O ? 33190 : r.type === F ? 35056 : 33189 : r.type === B &&
						console.error(
							"WebGLRenderer: Floating point depth texture requires WebGL2."),
						r.format === G && 6402 === v && r.type !== N && r.type !== O && (
							console.warn(
								"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
								), r.type = N, f = a.convert(r.type)), r.format === V &&
						6402 === v && (v = 34041, r.type !== F && (console.warn(
							"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
							), r.type = F, f = a.convert(r.type))), n.texImage2D(3553, 0, v,
							u.width, u.height, 0, d, f, null);
					else if (r.isDataTexture)
						if (m.length > 0 && h) {
							for (var g = 0, y = m.length; g < y; g++) s = m[g], n
								.texImage2D(3553, g, v, s.width, s.height, 0, d, f, s.data);
							r.generateMipmaps = !1, t.__maxMipLevel = m.length - 1
						} else n.texImage2D(3553, 0, v, u.width, u.height, 0, d, f, u.data),
							t.__maxMipLevel = 0;
					else if (r.isCompressedTexture) {
						for (var S = 0, T = m.length; S < T; S++) s = m[S], r.format !==
							U && r.format !== H ? null !== d ? n.compressedTexImage2D(3553,
								S, v, s.width, s.height, 0, s.data) : console.warn(
								"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
								) : n.texImage2D(3553, S, v, s.width, s.height, 0, d, f, s
								.data);
						t.__maxMipLevel = m.length - 1
					} else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, v, u.width, u
						.height, u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
					else if (r.isDataTexture3D) n.texImage3D(32879, 0, v, u.width, u.height,
						u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
					else if (m.length > 0 && h) {
						for (var A = 0, k = m.length; A < k; A++) s = m[A], n.texImage2D(
							3553, A, v, d, f, s);
						r.generateMipmaps = !1, t.__maxMipLevel = m.length - 1
					} else n.texImage2D(3553, 0, v, d, f, u), t.__maxMipLevel = 0;
					b(r, h) && w(o, r, u.width, u.height), t.__version = r.version, r
						.onUpdate && r.onUpdate(r)
				}

				function K(t, i, o, s, l) {
					var u = a.convert(o.format),
						c = a.convert(o.type),
						h = M(o.internalFormat, u, c);
					32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i
							.depth, 0, u, c, null) : n.texImage2D(l, 0, h, i.width, i
							.height, 0, u, c, null), n.bindFramebuffer(36160, t), e
						.framebufferTexture2D(36160, s, l, r.get(o).__webglTexture, 0), n
						.bindFramebuffer(36160, null)
				}

				function ee(t, n, r) {
					if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
						var i = 33189;
						if (r) {
							var o = n.depthTexture;
							o && o.isDepthTexture && (o.type === B ? i = 36012 : o.type ===
								O && (i = 33190));
							var s = te(n);
							e.renderbufferStorageMultisample(36161, s, i, n.width, n.height)
						} else e.renderbufferStorage(36161, i, n.width, n.height);
						e.framebufferRenderbuffer(36160, 36096, 36161, t)
					} else if (n.depthBuffer && n.stencilBuffer) {
						if (r) {
							var l = te(n);
							e.renderbufferStorageMultisample(36161, l, 35056, n.width, n
								.height)
						} else e.renderbufferStorage(36161, 34041, n.width, n.height);
						e.framebufferRenderbuffer(36160, 33306, 36161, t)
					} else {
						var u = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n
							.texture,
							c = a.convert(u.format),
							h = a.convert(u.type),
							d = M(u.internalFormat, c, h);
						if (r) {
							var f = te(n);
							e.renderbufferStorageMultisample(36161, f, d, n.width, n.height)
						} else e.renderbufferStorage(36161, d, n.width, n.height)
					}
					e.bindRenderbuffer(36161, null)
				}

				function te(e) {
					return c && e.isWebGLMultisampleRenderTarget ? Math.min(v, e.samples) :
						0
				}
				var ne = !1,
					re = !1;
				this.allocateTextureUnit = function() {
					var e = j;
					return e >= h && console.warn(
							"THREE.WebGLTextures: Trying to use " + e +
							" texture units while this GPU supports only " + h), j += 1,
						e
				}, this.resetTextureUnits = function() {
					j = 0
				}, this.setTexture2D = q, this.setTexture2DArray = function(e, t) {
					var i = r.get(e);
					e.version > 0 && i.__version !== e.version ? Q(i, e, t) : (n
						.activeTexture(33984 + t), n.bindTexture(35866, i
							.__webglTexture))
				}, this.setTexture3D = function(e, t) {
					var i = r.get(e);
					e.version > 0 && i.__version !== e.version ? Q(i, e, t) : (n
						.activeTexture(33984 + t), n.bindTexture(32879, i
							.__webglTexture))
				}, this.setTextureCube = X, this.setupRenderTarget = function(t) {
					var s = t.texture,
						l = r.get(t),
						u = r.get(s);
					t.addEventListener("dispose", W), !0 !== t
						.isWebGLMultipleRenderTargets && (u.__webglTexture = e
							.createTexture(), u.__version = s.version, o.memory
							.textures++);
					var h = !0 === t.isWebGLCubeRenderTarget,
						d = !0 === t.isWebGLMultipleRenderTargets,
						f = !0 === t.isWebGLMultisampleRenderTarget,
						p = s.isDataTexture3D || s.isDataTexture2DArray,
						v = _(t) || c;
					if (!c || s.format !== H || s.type !== B && s.type !== z || (s
							.format = U, console.warn(
								"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
								)), h) {
						l.__webglFramebuffer = [];
						for (var m = 0; m < 6; m++) l.__webglFramebuffer[m] = e
							.createFramebuffer()
					} else if (l.__webglFramebuffer = e.createFramebuffer(), d)
						if (i.drawBuffers)
							for (var g = t.texture, y = 0, x = g.length; y < x; y++) {
								var S = r.get(g[y]);
								void 0 === S.__webglTexture && (S.__webglTexture = e
									.createTexture(), o.memory.textures++)
							} else console.warn(
								"THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
								);
						else if (f)
						if (c) {
							l.__webglMultisampledFramebuffer = e.createFramebuffer(), l
								.__webglColorRenderbuffer = e.createRenderbuffer(), e
								.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
							var T = a.convert(s.format),
								E = a.convert(s.type),
								A = M(s.internalFormat, T, E),
								L = te(t);
							e.renderbufferStorageMultisample(36161, L, A, t.width, t
									.height), n.bindFramebuffer(36160, l
									.__webglMultisampledFramebuffer), e
								.framebufferRenderbuffer(36160, 36064, 36161, l
									.__webglColorRenderbuffer), e.bindRenderbuffer(
									36161, null), t.depthBuffer && (l
									.__webglDepthRenderbuffer = e.createRenderbuffer(),
									ee(l.__webglDepthRenderbuffer, t, !0)), n
								.bindFramebuffer(36160, null)
						} else console.warn(
							"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
							);
					if (h) {
						n.bindTexture(34067, u.__webglTexture), Z(34067, s, v);
						for (var k = 0; k < 6; k++) K(l.__webglFramebuffer[k], t, s,
							36064, 34069 + k);
						b(s, v) && w(34067, s, t.width, t.height), n.bindTexture(34067,
							null)
					} else if (d) {
						for (var R = t.texture, C = 0, P = R.length; C < P; C++) {
							var I = R[C],
								D = r.get(I);
							n.bindTexture(3553, D.__webglTexture), Z(3553, I, v), K(l
									.__webglFramebuffer, t, I, 36064 + C, 3553), b(I,
								v) && w(3553, I, t.width, t.height)
						}
						n.bindTexture(3553, null)
					} else {
						var N = 3553;
						p && (c ? N = s.isDataTexture3D ? 32879 : 35866 : console.warn(
							"THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
							)), n.bindTexture(N, u.__webglTexture), Z(N, s, v), K(l
							.__webglFramebuffer, t, s, 36064, N), b(s, v) && w(3553,
							s, t.width, t.height), n.bindTexture(3553, null)
					}
					t.depthBuffer && function(t) {
						var i = r.get(t),
							a = !0 === t.isWebGLCubeRenderTarget;
						if (t.depthTexture) {
							if (a) throw new Error(
								"target.depthTexture not supported in Cube render targets"
								);
							! function(t, i) {
								if (i && i.isWebGLCubeRenderTarget) throw new Error(
									"Depth Texture with cube render targets is not supported"
									);
								if (n.bindFramebuffer(36160, t), !i.depthTexture ||
									!i.depthTexture.isDepthTexture) throw new Error(
									"renderTarget.depthTexture must be an instance of THREE.DepthTexture"
									);
								r.get(i.depthTexture).__webglTexture && i
									.depthTexture.image.width === i.width && i
									.depthTexture.image.height === i.height || (i
										.depthTexture.image.width = i.width, i
										.depthTexture.image.height = i.height, i
										.depthTexture.needsUpdate = !0), q(i
										.depthTexture, 0);
								var a = r.get(i.depthTexture).__webglTexture;
								if (i.depthTexture.format === G) e
									.framebufferTexture2D(36160, 36096, 3553, a, 0);
								else {
									if (i.depthTexture.format !== V)
									throw new Error(
											"Unknown depthTexture format");
									e.framebufferTexture2D(36160, 33306, 3553, a, 0)
								}
							}(i.__webglFramebuffer, t)
						} else if (a) {
							i.__webglDepthbuffer = [];
							for (var o = 0; o < 6; o++) n.bindFramebuffer(36160, i
									.__webglFramebuffer[o]), i.__webglDepthbuffer[
								o] = e.createRenderbuffer(), ee(i
									.__webglDepthbuffer[o], t, !1)
						} else n.bindFramebuffer(36160, i.__webglFramebuffer), i
							.__webglDepthbuffer = e.createRenderbuffer(), ee(i
								.__webglDepthbuffer, t, !1);
						n.bindFramebuffer(36160, null)
					}(t)
				}, this.updateRenderTargetMipmap = function(e) {
					for (var t = _(e) || c, i = !0 === e.isWebGLMultipleRenderTargets ?
							e.texture : [e.texture], a = 0, o = i.length; a < o; a++) {
						var s = i[a];
						if (b(s, t)) {
							var l = e.isWebGLCubeRenderTarget ? 34067 : 3553,
								u = r.get(s).__webglTexture;
							n.bindTexture(l, u), w(l, s, e.width, e.height), n
								.bindTexture(l, null)
						}
					}
				}, this.updateMultisampleRenderTarget = function(t) {
					if (t.isWebGLMultisampleRenderTarget)
						if (c) {
							var i = t.width,
								a = t.height,
								o = 16384;
							t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024);
							var s = r.get(t);
							n.bindFramebuffer(36008, s.__webglMultisampledFramebuffer),
								n.bindFramebuffer(36009, s.__webglFramebuffer), e
								.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728), n
								.bindFramebuffer(36008, null), n.bindFramebuffer(36009,
									s.__webglMultisampledFramebuffer)
						} else console.warn(
							"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
							)
				}, this.safeSetTexture2D = function(e, t) {
					e && e.isWebGLRenderTarget && (!1 === ne && (console.warn(
						"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
						), ne = !0), e = e.texture), q(e, t)
				}, this.safeSetTextureCube = function(e, t) {
					e && e.isWebGLCubeRenderTarget && (!1 === re && (console.warn(
						"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
						), re = !0), e = e.texture), X(e, t)
				}
			}

			function Ra(e, t, n) {
				var r = n.isWebGL2;
				return {
					convert: function(e) {
						var n;
						if (e === D) return 5121;
						if (1017 === e) return 32819;
						if (1018 === e) return 32820;
						if (1019 === e) return 33635;
						if (1010 === e) return 5120;
						if (1011 === e) return 5122;
						if (e === N) return 5123;
						if (1013 === e) return 5124;
						if (e === O) return 5125;
						if (e === B) return 5126;
						if (e === z) return r ? 5131 : null !== (n = t.get(
							"OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
						if (1021 === e) return 6406;
						if (e === H) return 6407;
						if (e === U) return 6408;
						if (1024 === e) return 6409;
						if (1025 === e) return 6410;
						if (e === G) return 6402;
						if (e === V) return 34041;
						if (1028 === e) return 6403;
						if (1029 === e) return 36244;
						if (1030 === e) return 33319;
						if (1031 === e) return 33320;
						if (1032 === e) return 36248;
						if (1033 === e) return 36249;
						if (e === W || e === j || e === q || e === X) {
							if (null === (n = t.get("WEBGL_compressed_texture_s3tc")))
								return null;
							if (e === W) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
							if (e === j) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							if (e === q) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							if (e === X) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if (e === Y || e === $ || e === Z || e === J) {
							if (null === (n = t.get("WEBGL_compressed_texture_pvrtc")))
								return null;
							if (e === Y) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (e === $) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (e === Z) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (e === J) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (36196 === e) return null !== (n = t.get(
								"WEBGL_compressed_texture_etc1")) ? n
							.COMPRESSED_RGB_ETC1_WEBGL : null;
						if ((e === Q || e === K) && null !== (n = t.get(
								"WEBGL_compressed_texture_etc"))) {
							if (e === Q) return n.COMPRESSED_RGB8_ETC2;
							if (e === K) return n.COMPRESSED_RGBA8_ETC2_EAC
						}
						return 37808 === e || 37809 === e || 37810 === e || 37811 ===
							e || 37812 === e || 37813 === e || 37814 === e || 37815 ===
							e || 37816 === e || 37817 === e || 37818 === e || 37819 ===
							e || 37820 === e || 37821 === e || 37840 === e || 37841 ===
							e || 37842 === e || 37843 === e || 37844 === e || 37845 ===
							e || 37846 === e || 37847 === e || 37848 === e || 37849 ===
							e || 37850 === e || 37851 === e || 37852 === e || 37853 ===
							e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ?
							e : null : 36492 === e ? null !== (n = t.get(
								"EXT_texture_compression_bptc")) ? e : null : e === F ?
							r ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n
							.UNSIGNED_INT_24_8_WEBGL : null : void 0
					}
				}
			}
			Ea.prototype.isMeshDistanceMaterial = !0;
			var Ca = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : [];
					return (0, g.default)(this, n), (e = t.call(this)).cameras = r, e
				}
				return n
			}(vr);
			Ca.prototype.isArrayCamera = !0;
			var Pa = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e;
					return (0, g.default)(this, n), (e = t.call(this)).type = "Group", e
				}
				return n
			}(Xt);
			Pa.prototype.isGroup = !0;
			var Ia = {
					type: "move"
				},
				Da = function() {
					function e() {
						(0, g.default)(this, e), this._targetRay = null, this._grip = null,
							this._hand = null
					}
					return (0, y.default)(e, [{
						key: "getHandSpace",
						value: function() {
							return null === this._hand && (this._hand =
								new Pa, this._hand.matrixAutoUpdate = !
								1, this._hand.visible = !1, this._hand
								.joints = {}, this._hand.inputState = {
									pinching: !1
								}), this._hand
						}
					}, {
						key: "getTargetRaySpace",
						value: function() {
							return null === this._targetRay && (this
								._targetRay = new Pa, this._targetRay
								.matrixAutoUpdate = !1, this._targetRay
								.visible = !1, this._targetRay
								.hasLinearVelocity = !1, this._targetRay
								.linearVelocity = new je, this
								._targetRay.hasAngularVelocity = !1,
								this._targetRay.angularVelocity = new je
								), this._targetRay
						}
					}, {
						key: "getGripSpace",
						value: function() {
							return null === this._grip && (this._grip =
								new Pa, this._grip.matrixAutoUpdate = !
								1, this._grip.visible = !1, this._grip
								.hasLinearVelocity = !1, this._grip
								.linearVelocity = new je, this._grip
								.hasAngularVelocity = !1, this._grip
								.angularVelocity = new je), this._grip
						}
					}, {
						key: "dispatchEvent",
						value: function(e) {
							return null !== this._targetRay && this
								._targetRay.dispatchEvent(e), null !== this
								._grip && this._grip.dispatchEvent(e),
								null !== this._hand && this._hand
								.dispatchEvent(e), this
						}
					}, {
						key: "disconnect",
						value: function(e) {
							return this.dispatchEvent({
									type: "disconnected",
									data: e
								}), null !== this._targetRay && (this
									._targetRay.visible = !1), null !== this
								._grip && (this._grip.visible = !1),
								null !== this._hand && (this._hand
									.visible = !1), this
						}
					}, {
						key: "update",
						value: function(e, t, n) {
							var r = null,
								i = null,
								a = null,
								o = this._targetRay,
								s = this._grip,
								l = this._hand;
							if (e && "visible-blurred" !== t.session
								.visibilityState)
								if (null !== o && null !== (r = t.getPose(e
										.targetRaySpace, n)) && (o.matrix
										.fromArray(r.transform.matrix), o
										.matrix.decompose(o.position, o
											.rotation, o.scale), r
										.linearVelocity ? (o
											.hasLinearVelocity = !0, o
											.linearVelocity.copy(r
												.linearVelocity)) : o
										.hasLinearVelocity = !1, r
										.angularVelocity ? (o
											.hasAngularVelocity = !0, o
											.angularVelocity.copy(r
												.angularVelocity)) : o
										.hasAngularVelocity = !1, this
										.dispatchEvent(Ia)), l && e.hand) {
									a = !0;
									var u, c = _(e.hand.values());
									try {
										for (c.s(); !(u = c.n()).done;) {
											var h = u.value,
												d = t.getJointPose(h, n);
											if (void 0 === l.joints[h
													.jointName]) {
												var f = new Pa;
												f.matrixAutoUpdate = !1, f
													.visible = !1, l.joints[
														h.jointName] = f, l
													.add(f)
											}
											var p = l.joints[h.jointName];
											null !== d && (p.matrix
													.fromArray(d.transform
														.matrix), p.matrix
													.decompose(p.position, p
														.rotation, p.scale),
													p.jointRadius = d.radius
													), p.visible = null !==
												d
										}
									} catch (e) {
										c.e(e)
									} finally {
										c.f()
									}
									var v = l.joints["index-finger-tip"],
										m = l.joints["thumb-tip"],
										g = v.position.distanceTo(m
											.position);
									l.inputState.pinching && g > .025 ? (l
											.inputState.pinching = !1, this
											.dispatchEvent({
												type: "pinchend",
												handedness: e
													.handedness,
												target: this
											})) : !l.inputState.pinching &&
										g <= .015 && (l.inputState
											.pinching = !0, this
											.dispatchEvent({
												type: "pinchstart",
												handedness: e
													.handedness,
												target: this
											}))
								} else null !== s && e.gripSpace && null !==
									(i = t.getPose(e.gripSpace, n)) && (s
										.matrix.fromArray(i.transform
											.matrix), s.matrix.decompose(s
											.position, s.rotation, s.scale),
										i.linearVelocity ? (s
											.hasLinearVelocity = !0, s
											.linearVelocity.copy(i
												.linearVelocity)) : s
										.hasLinearVelocity = !1, i
										.angularVelocity ? (s
											.hasAngularVelocity = !0, s
											.angularVelocity.copy(i
												.angularVelocity)) : s
										.hasAngularVelocity = !1);
							return null !== o && (o.visible = null !== r),
								null !== s && (s.visible = null !== i),
								null !== l && (l.visible = null !== a), this
						}
					}]), e
				}(),
				Na = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						(0, g.default)(this, n), i = t.call(this);
						var a = (0, f.default)(i),
							o = e.state,
							s = null,
							c = 1,
							h = null,
							d = "local-floor",
							p = null,
							v = [],
							m = new Map,
							y = new vr;
						y.layers.enable(1), y.viewport = new He;
						var x = new vr;
						x.layers.enable(2), x.viewport = new He;
						var _ = [y, x],
							b = new Ca;
						b.layers.enable(1), b.layers.enable(2);
						var w = null,
							M = null;

						function S(e) {
							var t = m.get(e.inputSource);
							t && t.dispatchEvent({
								type: e.type,
								data: e.inputSource
							})
						}

						function T() {
							m.forEach((function(e, t) {
									e.disconnect(t)
								})), m.clear(), w = null, M = null, o.bindXRFramebuffer(
									null), e.setRenderTarget(e.getRenderTarget()), C.stop(),
								a.isPresenting = !1, a.dispatchEvent({
									type: "sessionend"
								})
						}

						function E(e) {
							for (var t = s.inputSources, n = 0; n < v.length; n++) m.set(t[
								n], v[n]);
							for (var r = 0; r < e.removed.length; r++) {
								var i = e.removed[r],
									a = m.get(i);
								a && (a.dispatchEvent({
									type: "disconnected",
									data: i
								}), m.delete(i))
							}
							for (var o = 0; o < e.added.length; o++) {
								var l = e.added[o],
									u = m.get(l);
								u && u.dispatchEvent({
									type: "connected",
									data: l
								})
							}
						}
						i.cameraAutoUpdate = !0, i.enabled = !1, i.isPresenting = !1, i
							.getController = function(e) {
								var t = v[e];
								return void 0 === t && (t = new Da, v[e] = t), t
									.getTargetRaySpace()
							}, i.getControllerGrip = function(e) {
								var t = v[e];
								return void 0 === t && (t = new Da, v[e] = t), t
									.getGripSpace()
							}, i.getHand = function(e) {
								var t = v[e];
								return void 0 === t && (t = new Da, v[e] = t), t
									.getHandSpace()
							}, i.setFramebufferScaleFactor = function(e) {
								c = e, !0 === a.isPresenting && console.warn(
									"THREE.WebXRManager: Cannot change framebuffer scale while presenting."
									)
							}, i.setReferenceSpaceType = function(e) {
								d = e, !0 === a.isPresenting && console.warn(
									"THREE.WebXRManager: Cannot change reference space type while presenting."
									)
							}, i.getReferenceSpace = function() {
								return h
							}, i.getSession = function() {
								return s
							}, i.setSession = function() {
								var e = (0, u.default)(l.default.mark((function e(t) {
									var n, i, o;
									return l.default.wrap((function(e) {
										for (;;) switch (e
											.prev = e.next
											) {
											case 0:
												if (null ===
													(s = t)
													) {
													e.next =
														16;
													break
												}
												if (s
													.addEventListener(
														"select",
														S),
													s
													.addEventListener(
														"selectstart",
														S),
													s
													.addEventListener(
														"selectend",
														S),
													s
													.addEventListener(
														"squeeze",
														S),
													s
													.addEventListener(
														"squeezestart",
														S),
													s
													.addEventListener(
														"squeezeend",
														S),
													s
													.addEventListener(
														"end",
														T),
													s
													.addEventListener(
														"inputsourceschange",
														E),
													n = r
													.getContextAttributes(),
													e.t0 = !
													0 !== n
													.xrCompatible,
													!e.t0) {
													e.next =
														7;
													break
												}
												return e
													.next =
													7, r
													.makeXRCompatible();
											case 7:
												return i = {
														antialias: n
															.antialias,
														alpha: n
															.alpha,
														depth: n
															.depth,
														stencil: n
															.stencil,
														framebufferScaleFactor: c
													}, o =
													new XRWebGLLayer(
														s,
														r, i
														), s
													.updateRenderState({
														baseLayer: o
													}), e
													.next =
													11, s
													.requestReferenceSpace(
														d);
											case 11:
												h = e.sent,
													C
													.setContext(
														s),
													C
													.start(),
													a
													.isPresenting = !
													0, a
													.dispatchEvent({
														type: "sessionstart"
													});
											case 16:
											case "end":
												return e
													.stop()
										}
									}), e)
								})));
								return function(t) {
									return e.apply(this, arguments)
								}
							}();
						var A = new je,
							L = new je;

						function k(e, t) {
							null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld
								.multiplyMatrices(t.matrixWorld, e.matrix), e
								.matrixWorldInverse.copy(e.matrixWorld).invert()
						}
						i.updateCamera = function(e) {
							if (null !== s) {
								b.near = x.near = y.near = e.near, b.far = x.far = y
									.far = e.far, w === b.near && M === b.far || (s
										.updateRenderState({
											depthNear: b.near,
											depthFar: b.far
										}), w = b.near, M = b.far);
								var t = e.parent,
									n = b.cameras;
								k(b, t);
								for (var r = 0; r < n.length; r++) k(n[r], t);
								e.matrixWorld.copy(b.matrixWorld), e.matrix.copy(b
									.matrix), e.matrix.decompose(e.position, e
									.quaternion, e.scale);
								for (var i = e.children, a = 0, o = i.length; a <
									o; a++) i[a].updateMatrixWorld(!0);
								2 === n.length ? function(e, t, n) {
									A.setFromMatrixPosition(t.matrixWorld), L
										.setFromMatrixPosition(n.matrixWorld);
									var r = A.distanceTo(L),
										i = t.projectionMatrix.elements,
										a = n.projectionMatrix.elements,
										o = i[14] / (i[10] - 1),
										s = i[14] / (i[10] + 1),
										l = (i[9] + 1) / i[5],
										u = (i[9] - 1) / i[5],
										c = (i[8] - 1) / i[0],
										h = (a[8] + 1) / a[0],
										d = o * c,
										f = o * h,
										p = r / (-c + h),
										v = p * -c;
									t.matrixWorld.decompose(e.position, e
											.quaternion, e.scale), e.translateX(v),
										e.translateZ(p), e.matrixWorld.compose(e
											.position, e.quaternion, e.scale), e
										.matrixWorldInverse.copy(e.matrixWorld)
										.invert();
									var m = o + p,
										g = s + p,
										y = d - v,
										x = f + (r - v),
										_ = l * s / g * m,
										b = u * s / g * m;
									e.projectionMatrix.makePerspective(y, x, _, b,
										m, g)
								}(b, y, x) : b.projectionMatrix.copy(y
									.projectionMatrix)
							}
						}, i.getCamera = function() {
							return b
						};
						var R = null,
							C = new Mr;
						return C.setAnimationLoop((function(e, t) {
							if (null !== (p = t.getViewerPose(h))) {
								var n = p.views,
									r = s.renderState.baseLayer;
								o.bindXRFramebuffer(r.framebuffer);
								var i = !1;
								n.length !== b.cameras.length && (b.cameras
									.length = 0, i = !0);
								for (var a = 0; a < n.length; a++) {
									var l = n[a],
										u = r.getViewport(l),
										c = _[a];
									c.matrix.fromArray(l.transform.matrix), c
										.projectionMatrix.fromArray(l
											.projectionMatrix), c.viewport.set(u
											.x, u.y, u.width, u.height), 0 ===
										a && b.matrix.copy(c.matrix), !0 ===
										i && b.cameras.push(c)
								}
							}
							for (var d = s.inputSources, f = 0; f < v
								.length; f++) {
								var m = v[f],
									g = d[f];
								m.update(g, t, h)
							}
							R && R(e, t)
						})), i.setAnimationLoop = function(e) {
							R = e
						}, i.dispose = function() {}, i
					}
					return n
				}(xe);

			function Oa(e) {
				function t(t, n) {
					t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n
						.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n
							.emissiveIntensity), n.map && (t.map.value = n.map), n
						.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t
							.specularMap.value = n.specularMap);
					var r, i, a = e.get(n).envMap;
					if (a) {
						t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture && a
							._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = n
							.reflectivity, t.refractionRatio.value = n.refractionRatio;
						var o = e.get(a).__maxMipLevel;
						void 0 !== o && (t.maxMipLevel.value = o)
					}
					n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity
							.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n
							.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r =
						n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r =
						n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r =
						n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ?
						r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ?
						r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n
						.clearcoatNormalMap ? r = n.clearcoatNormalMap : n
						.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !==
						r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r
							.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(
								r.matrix)), n.aoMap ? i = n.aoMap : n.lightMap && (i = n
							.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i
								.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t
							.uv2Transform.value.copy(i.matrix))
				}

				function n(t, n) {
					t.roughness.value = n.roughness, t.metalness.value = n.metalness, n
						.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n
						.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n
						.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap &&
						(t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 ===
							n.side && (t.bumpScale.value *= -1)), n.normalMap && (t
							.normalMap.value = n.normalMap, t.normalScale.value.copy(n
								.normalScale), 1 === n.side && t.normalScale.value.negate()
							), n.displacementMap && (t.displacementMap.value = n
							.displacementMap, t.displacementScale.value = n
							.displacementScale, t.displacementBias.value = n
							.displacementBias), e.get(n).envMap && (t.envMapIntensity
							.value = n.envMapIntensity)
				}
				return {
					refreshFogUniforms: function(e, t) {
						e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t
							.near, e.fogFar.value = t.far) : t.isFogExp2 && (e
							.fogDensity.value = t.density)
					},
					refreshMaterialUniforms: function(e, r, i, a, o) {
						r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(
							e, r), function(e, t) {
							t.emissiveMap && (e.emissiveMap.value = t
								.emissiveMap)
						}(e, r)) : r.isMeshToonMaterial ? (t(e, r), function(e, t) {
							t.gradientMap && (e.gradientMap.value = t
									.gradientMap), t.emissiveMap && (e
									.emissiveMap.value = t.emissiveMap), t
								.bumpMap && (e.bumpMap.value = t.bumpMap, e
									.bumpScale.value = t.bumpScale, 1 === t
									.side && (e.bumpScale.value *= -1)), t
								.normalMap && (e.normalMap.value = t.normalMap,
									e.normalScale.value.copy(t.normalScale),
									1 === t.side && e.normalScale.value.negate()
									), t.displacementMap && (e.displacementMap
									.value = t.displacementMap, e
									.displacementScale.value = t
									.displacementScale, e.displacementBias
									.value = t.displacementBias)
						}(e, r)) : r.isMeshPhongMaterial ? (t(e, r), function(e,
						t) {
							e.specular.value.copy(t.specular), e.shininess
								.value = Math.max(t.shininess, 1e-4), t
								.emissiveMap && (e.emissiveMap.value = t
									.emissiveMap), t.bumpMap && (e.bumpMap
									.value = t.bumpMap, e.bumpScale.value = t
									.bumpScale, 1 === t.side && (e.bumpScale
										.value *= -1)), t.normalMap && (e
									.normalMap.value = t.normalMap, e
									.normalScale.value.copy(t.normalScale),
									1 === t.side && e.normalScale.value.negate()
									), t.displacementMap && (e.displacementMap
									.value = t.displacementMap, e
									.displacementScale.value = t
									.displacementScale, e.displacementBias
									.value = t.displacementBias)
						}(e, r)) : r.isMeshStandardMaterial ? (t(e, r), r
							.isMeshPhysicalMaterial ? function(e, t, r) {
								n(e, t), e.reflectivity.value = t.reflectivity, e
									.clearcoat.value = t.clearcoat, e
									.clearcoatRoughness.value = t
									.clearcoatRoughness, t.sheen && e.sheen.value
									.copy(t.sheen), t.clearcoatMap && (e
										.clearcoatMap.value = t.clearcoatMap), t
									.clearcoatRoughnessMap && (e
										.clearcoatRoughnessMap.value = t
										.clearcoatRoughnessMap), t
									.clearcoatNormalMap && (e.clearcoatNormalScale
										.value.copy(t.clearcoatNormalScale), e
										.clearcoatNormalMap.value = t
										.clearcoatNormalMap, 1 === t.side && e
										.clearcoatNormalScale.value.negate()), e
									.transmission.value = t.transmission, t
									.transmissionMap && (e.transmissionMap.value = t
										.transmissionMap), t.transmission > 0 && (e
										.transmissionSamplerMap.value = r.texture, e
										.transmissionSamplerSize.value.set(r.width,
											r.height)), e.thickness.value = t
									.thickness, t.thicknessMap && (e.thicknessMap
										.value = t.thicknessMap), e
									.attenuationDistance.value = t
									.attenuationDistance, e.attenuationColor.value
									.copy(t.attenuationColor)
							}(e, r, o) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e,
							r), function(e, t) {
							t.matcap && (e.matcap.value = t.matcap), t
								.bumpMap && (e.bumpMap.value = t.bumpMap, e
									.bumpScale.value = t.bumpScale, 1 === t
									.side && (e.bumpScale.value *= -1)), t
								.normalMap && (e.normalMap.value = t.normalMap,
									e.normalScale.value.copy(t.normalScale),
									1 === t.side && e.normalScale.value.negate()
									), t.displacementMap && (e.displacementMap
									.value = t.displacementMap, e
									.displacementScale.value = t
									.displacementScale, e.displacementBias
									.value = t.displacementBias)
						}(e, r)) : r.isMeshDepthMaterial ? (t(e, r), function(e,
						t) {
							t.displacementMap && (e.displacementMap.value = t
								.displacementMap, e.displacementScale
								.value = t.displacementScale, e
								.displacementBias.value = t.displacementBias
								)
						}(e, r)) : r.isMeshDistanceMaterial ? (t(e, r), function(e,
							t) {
							t.displacementMap && (e.displacementMap.value = t
									.displacementMap, e.displacementScale
									.value = t.displacementScale, e
									.displacementBias.value = t.displacementBias
									), e.referencePosition.value.copy(t
									.referencePosition), e.nearDistance.value =
								t.nearDistance, e.farDistance.value = t
								.farDistance
						}(e, r)) : r.isMeshNormalMaterial ? (t(e, r), function(e,
						t) {
							t.bumpMap && (e.bumpMap.value = t.bumpMap, e
									.bumpScale.value = t.bumpScale, 1 === t
									.side && (e.bumpScale.value *= -1)), t
								.normalMap && (e.normalMap.value = t.normalMap,
									e.normalScale.value.copy(t.normalScale),
									1 === t.side && e.normalScale.value.negate()
									), t.displacementMap && (e.displacementMap
									.value = t.displacementMap, e
									.displacementScale.value = t
									.displacementScale, e.displacementBias
									.value = t.displacementBias)
						}(e, r)) : r.isLineBasicMaterial ? (function(e, t) {
							e.diffuse.value.copy(t.color), e.opacity.value = t
								.opacity
						}(e, r), r.isLineDashedMaterial && function(e, t) {
							e.dashSize.value = t.dashSize, e.totalSize.value = t
								.dashSize + t.gapSize, e.scale.value = t.scale
						}(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
							var i;
							e.diffuse.value.copy(t.color), e.opacity.value = t
								.opacity, e.size.value = t.size * n, e.scale.value =
								.5 * r, t.map && (e.map.value = t.map), t
								.alphaMap && (e.alphaMap.value = t.alphaMap), t
								.map ? i = t.map : t.alphaMap && (i = t.alphaMap),
								void 0 !== i && (!0 === i.matrixAutoUpdate && i
									.updateMatrix(), e.uvTransform.value.copy(i
										.matrix))
						}(e, r, i, a) : r.isSpriteMaterial ? function(e, t) {
							var n;
							e.diffuse.value.copy(t.color), e.opacity.value = t
								.opacity, e.rotation.value = t.rotation, t.map && (e
									.map.value = t.map), t.alphaMap && (e.alphaMap
									.value = t.alphaMap), t.map ? n = t.map : t
								.alphaMap && (n = t.alphaMap), void 0 !== n && (!
									0 === n.matrixAutoUpdate && n.updateMatrix(), e
									.uvTransform.value.copy(n.matrix))
						}(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
							e.opacity.value = r.opacity) : r.isShaderMaterial && (r
							.uniformsNeedUpdate = !1)
					}
				}
			}

			function Ba(e) {
				var t = void 0 !== (e = e || {}).canvas ? e.canvas : function() {
						var e = document.createElementNS("http://www.w3.org/1999/xhtml",
							"canvas");
						return e.style.display = "block", e
					}(),
					n = void 0 !== e.context ? e.context : null,
					r = void 0 !== e.alpha && e.alpha,
					i = void 0 === e.depth || e.depth,
					a = void 0 === e.stencil || e.stencil,
					o = void 0 !== e.antialias && e.antialias,
					s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
					l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
					u = void 0 !== e.powerPreference ? e.powerPreference : "default",
					c = void 0 !== e.failIfMajorPerformanceCaveat && e
					.failIfMajorPerformanceCaveat,
					h = null,
					d = null,
					f = [],
					p = [];
				this.domElement = t, this.debug = {
						checkShaderErrors: !0
					}, this.autoClear = !0, this.autoClearColor = !0, this
					.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0,
					this.clippingPlanes = [], this.localClippingEnabled = !1, this
					.gammaFactor = 2, this.outputEncoding = le, this
					.physicallyCorrectLights = !1, this.toneMapping = 0, this
					.toneMappingExposure = 1;
				var v = this,
					m = !1,
					g = 0,
					y = 0,
					x = null,
					_ = -1,
					b = null,
					w = new He,
					M = new He,
					S = null,
					T = t.width,
					A = t.height,
					k = 1,
					R = null,
					C = null,
					P = new He(0, 0, T, A),
					N = new He(0, 0, T, A),
					O = !1,
					F = [],
					H = new wr,
					G = !1,
					V = !1,
					W = null,
					j = new wt,
					q = new je,
					X = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: !0
					};

				function Y() {
					return null === x ? k : 1
				}
				var $, Z, J, Q, K, ee, te, ne, re, ie, ae, oe, se, ue, ce, he, de, fe, pe,
					ve, me, ge, ye = n;

				function xe(e, n) {
					for (var r = 0; r < e.length; r++) {
						var i = e[r],
							a = t.getContext(i, n);
						if (null !== a) return a
					}
					return null
				}
				try {
					var _e = {
						alpha: r,
						depth: i,
						stencil: a,
						antialias: o,
						premultipliedAlpha: s,
						preserveDrawingBuffer: l,
						powerPreference: u,
						failIfMajorPerformanceCaveat: c
					};
					if (t.addEventListener("webglcontextlost", Se, !1), t.addEventListener(
							"webglcontextrestored", Te, !1), null === ye) {
						var be = ["webgl2", "webgl", "experimental-webgl"];
					}
					void 0 === ye
				} catch (e) {
					throw console.error("THREE.WebGLRenderer: ")
				}

				var Me = new Na(v, ye);

				function Se(e) {
					e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."),
						m = !0
				}

				function Te() {
					console.log("THREE.WebGLRenderer: Context Restored."), m = !1;
					var e = Q.autoReset,
						t = he.enabled,
						n = he.autoUpdate,
						r = he.needsUpdate,
						i = he.type;
					we(), Q.autoReset = e, he.enabled = t, he.autoUpdate = n, he
						.needsUpdate = r, he.type = i
				}
				this.compile = function(e, t) {
					(d = ue.get(e)).init(), e.traverseVisible((function(e) {
						e.isLight && e.layers.test(t.layers) && (d
							.pushLight(e), e.castShadow && d.pushShadow(
								e))
					})), d.setupLights(), e.traverse((function(t) {
						var n = t.material;
						if (n)
							if (Array.isArray(n))
								for (var r = 0; r < n.length; r++) Ne(n[r],
									e, t);
							else Ne(n, e, t)
					}))
				};
				var Ae = null;

				function Le() {
					Re.stop()
				}

				function ke() {
					Re.start()
				}
				var Re = new Mr;

				function Ce(e, t, n, r) {
					if (!1 !== e.visible) {
						if (e.layers.test(t.layers))
							if (e.isGroup) n = e.renderOrder;
							else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
						else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
						else if (e.isSprite) {
							if (!e.frustumCulled || H.intersectsSprite(e)) {
								r && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
								var i = ie.update(e),
									a = e.material;
								a.visible && h.push(e, i, a, n, q.z, null)
							}
						} else if (e.isImmediateRenderObject) r && q.setFromMatrixPosition(e
							.matrixWorld).applyMatrix4(j), h.push(e, null, e.material,
							n, q.z, null);
						else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh &&
								e.skeleton.frame !== Q.render.frame && (e.skeleton.update(),
									e.skeleton.frame = Q.render.frame), !e.frustumCulled ||
								H.intersectsObject(e))) {
							r && q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
							var o = ie.update(e),
								s = e.material;
							if (Array.isArray(s))
								for (var l = o.groups, u = 0, c = l.length; u < c; u++) {
									var f = l[u],
										p = s[f.materialIndex];
									p && p.visible && h.push(e, o, p, n, q.z, f)
								} else s.visible && h.push(e, o, s, n, q.z, null)
						}
						for (var v = e.children, m = 0, g = v.length; m < g; m++) Ce(v[m],
							t, n, r)
					}
				}

				function Pe(e, t, n) {
					for (var r = !0 === t.isScene ? t.overrideMaterial : null, i = 0, a = e
							.length; i < a; i++) {
						var o = e[i],
							s = o.object,
							l = o.geometry,
							u = null === r ? o.material : r,
							c = o.group;
						if (n.isArrayCamera)
							for (var h = n.cameras, f = 0, p = h.length; f < p; f++) {
								var v = h[f];
								s.layers.test(v.layers) && (J.viewport(w.copy(v.viewport)),
									d.setupLightsView(v), De(s, t, v, l, u, c))
							} else De(s, t, n, l, u, c)
					}
				}

				function De(e, t, n, r, i, a) {
					if (e.onBeforeRender(v, t, n, r, i, a), e.modelViewMatrix
						.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e
						.normalMatrix.getNormalMatrix(e.modelViewMatrix), e
						.isImmediateRenderObject) {
						var o = Be(n, t, i, e);
						J.setMaterial(i), ge.reset(),
							function(e, t) {
								e.render((function(e) {
									v.renderBufferImmediate(e, t)
								}))
							}(e, o)
					} else v.renderBufferDirect(n, t, r, i, e, a);
					e.onAfterRender(v, t, n, r, i, a)
				}

				function Ne(e, t, n) {
					!0 !== t.isScene && (t = X);
					var r = K.get(e),
						i = d.state.lights,
						a = d.state.shadowsArray,
						o = i.state.version,
						s = ae.getParameters(e, i.state, a, t, n),
						l = ae.getProgramCacheKey(s),
						u = r.programs;
					r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog =
						t.fog, r.envMap = te.get(e.envMap || r.environment), void 0 === u &&
						(e.addEventListener("dispose", Ee), u = new Map, r.programs = u);
					var c = u.get(l);
					if (void 0 !== c) {
						if (r.currentProgram === c && r.lightsStateVersion === o) return Oe(
							e, s), c
					} else s.uniforms = ae.getUniforms(e), e.onBuild(s, v), e
						.onBeforeCompile(s, v), c = ae.acquireProgram(s, l), u.set(l, c), r
						.uniforms = s.uniforms;
					var h = r.uniforms;
					(e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h
							.clippingPlanes = ce.uniform), Oe(e, s), r.needsLights =
						function(e) {
							return e.isMeshLambertMaterial || e.isMeshToonMaterial || e
								.isMeshPhongMaterial || e.isMeshStandardMaterial || e
								.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
						}(e), r.lightsStateVersion = o, r.needsLights && (h
							.ambientLightColor.value = i.state.ambient, h.lightProbe.value =
							i.state.probe, h.directionalLights.value = i.state.directional,
							h.directionalLightShadows.value = i.state.directionalShadow, h
							.spotLights.value = i.state.spot, h.spotLightShadows.value = i
							.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h
							.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state
							.rectAreaLTC2, h.pointLights.value = i.state.point, h
							.pointLightShadows.value = i.state.pointShadow, h
							.hemisphereLights.value = i.state.hemi, h.directionalShadowMap
							.value = i.state.directionalShadowMap, h.directionalShadowMatrix
							.value = i.state.directionalShadowMatrix, h.spotShadowMap
							.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i
							.state.spotShadowMatrix, h.pointShadowMap.value = i.state
							.pointShadowMap, h.pointShadowMatrix.value = i.state
							.pointShadowMatrix);
					var f = {},
						p = qi.seqWithValue(f.seq, h);
					return r.currentProgram = c, r.uniformsList = p, c
				}

				function Oe(e, t) {
					var n = K.get(e);
					n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n
						.skinning = t.skinning, n.numClippingPlanes = t.numClippingPlanes, n
						.numIntersection = t.numClipIntersection, n.vertexAlphas = t
						.vertexAlphas
				}

				function Be(e, t, n, r) {
					!0 !== t.isScene && (t = X), ee.resetTextureUnits();
					var i = t.fog,
						a = n.isMeshStandardMaterial ? t.environment : null,
						o = null === x ? v.outputEncoding : x.texture.encoding,
						s = te.get(n.envMap || a),
						l = !0 === n.vertexColors && r.geometry && r.geometry.attributes
						.color && 4 === r.geometry.attributes.color.itemSize,
						u = K.get(n),
						c = d.state.lights;
					if (!0 === G && (!0 === V || e !== b)) {
						var h = e === b && n.id === _;
						ce.setState(n, e, h)
					}
					var f = !1;
					n.version === u.__version ? u.needsLights && u.lightsStateVersion !== c
						.state.version || u.outputEncoding !== o || r.isInstancedMesh && !
						1 === u.instancing ? f = !0 : r.isInstancedMesh || !0 !== u
						.instancing ? r.isSkinnedMesh && !1 === u.skinning ? f = !0 : r
						.isSkinnedMesh || !0 !== u.skinning ? u.envMap !== s || n.fog && u
						.fog !== i ? f = !0 : void 0 === u.numClippingPlanes || u
						.numClippingPlanes === ce.numPlanes && u.numIntersection === ce
						.numIntersection ? u.vertexAlphas !== l && (f = !0) : f = !0 : f = !
						0 : f = !0 : (f = !0, u.__version = n.version);
					var p = u.currentProgram;
					!0 === f && (p = Ne(n, t, r));
					var m, g, y = !1,
						w = !1,
						M = !1,
						S = {},
						T = u.uniforms;
					if (r.isSkinnedMesh) {
						S.setOptional(ye, r, "bindMatrix"), S.setOptional(ye, r,
							"bindMatrixInverse");
						var L = r.skeleton;
						L && (Z.floatVertexTextures ? (null === L.boneTexture && L
							.computeBoneTexture(), S.setValue(ye, "boneTexture", L
								.boneTexture, ee), S.setValue(ye, "boneTextureSize",
								L.boneTextureSize)) : S.setOptional(ye, L,
							"boneMatrices"))
					}
					return (w || u.receiveShadow !== r.receiveShadow), w && (S.setValue(ye,
								"toneMappingExposure", v.toneMappingExposure), u
							.needsLights && (g = M, (m = T).ambientLightColor.needsUpdate =
								g, m.lightProbe.needsUpdate = g, m.directionalLights
								.needsUpdate = g, m.directionalLightShadows.needsUpdate = g,
								m.pointLights.needsUpdate = g, m.pointLightShadows
								.needsUpdate = g, m.spotLights.needsUpdate = g, m
								.spotLightShadows.needsUpdate = g, m.rectAreaLights
								.needsUpdate = g, m.hemisphereLights.needsUpdate = g), i &&
							n.fog && oe.refreshFogUniforms(T, i), oe
							.refreshMaterialUniforms(T, n, k, A, W), qi.upload(ye, u
								.uniformsList, T, ee)), n.isShaderMaterial && !0 === n
						.uniformsNeedUpdate && (qi.upload(ye, u.uniformsList, T, ee), n
							.uniformsNeedUpdate = !1), n.isSpriteMaterial && S.setValue(ye,
							"center", r.center), p
				}
				Re.setAnimationLoop((function(e) {
						Ae && Ae(e)
					})), "undefined" != typeof window && Re.setContext(window), this
					.setAnimationLoop = function(e) {
						Ae = e, Me.setAnimationLoop(e), null === e ? Re.stop() : Re.start()
					}, Me.addEventListener("sessionstart", Le), Me.addEventListener(
						"sessionend", ke), this.render = function(e, t) {
						if (void 0 === t || !0 === t.isCamera) {
							if (!0 !== m) {
								!0 === e.autoUpdate && e.updateMatrixWorld(), null === t
									.parent && t.updateMatrixWorld(), !0 === Me.enabled && !
									0 === Me.isPresenting && (!0 === Me.cameraAutoUpdate &&
										Me.updateCamera(t), t = Me.getCamera()), !0 === e
									.isScene && e.onBeforeRender(v, e, t, x), (d = ue.get(e,
										p.length)).init(), p.push(d), j.multiplyMatrices(t
										.projectionMatrix, t.matrixWorldInverse), H
									.setFromProjectionMatrix(j), V = this
									.localClippingEnabled, G = ce.init(this.clippingPlanes,
										V, t), (h = se.get(e, f.length)).init(), f.push(h),
									Ce(e, t, 0, v.sortObjects), h.finish(), !0 === v
									.sortObjects && h.sort(R, C), !0 === G && ce
									.beginShadows();
								var n = d.state.shadowsArray;
								he.render(n, e, t), d.setupLights(), d.setupLightsView(t), !
									0 === G && ce.endShadows(), !0 === this.info
									.autoReset && this.info.reset(), de.render(h, e);
								var r = h.opaque,
									i = h.transmissive,
									a = h.transparent;
								r.length > 0 && Pe(r, e, t), i.length > 0 && function(e, t,
										n, r) {
										null === W && (W = new Ue(1024, 1024, {
											generateMipmaps: !0,
											minFilter: I,
											magFilter: L,
											wrapS: E,
											wrapT: E
										}));
										var i = v.getRenderTarget();
										v.setRenderTarget(W), v.clear(), Pe(e, n, r), ee
											.updateRenderTargetMipmap(W), v.setRenderTarget(
												i), Pe(t, n, r)
									}(r, i, e, t), a.length > 0 && Pe(a, e, t), null !==
									x && (ee.updateRenderTargetMipmap(x), ee
										.updateMultisampleRenderTarget(x)), !0 === e
									.isScene && e.onAfterRender(v, e, t), J.buffers.depth
									.setTest(!0), J.buffers.depth.setMask(!0), J.buffers
									.color.setMask(!0), J.setPolygonOffset(!1), ge
									.resetDefaultState(), _ = -1, b = null, p.pop(), d = p
									.length > 0 ? p[p.length - 1] : null, f.pop(), h = f
									.length > 0 ? f[f.length - 1] : null
							}
						} else console.error(
							"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
							)
					}, this.getActiveCubeFace = function() {
						return g
					}, this.getActiveMipmapLevel = function() {
						return y
					}, this.getRenderTarget = function() {
						return x
					}, this.setRenderTarget = function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0,
							n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0;
						x = e, g = t, y = n, e && void 0 === K.get(e).__webglFramebuffer &&
							ee.setupRenderTarget(e);
						var r = null,
							i = !1,
							a = !1;
						if (e) {
							var o = e.texture;
							(o.isDataTexture3D || o.isDataTexture2DArray) && (a = !0);
							var s = K.get(e).__webglFramebuffer;
							e.isWebGLCubeRenderTarget ? (r = s[t], i = !0) : r = e
								.isWebGLMultisampleRenderTarget ? K.get(e)
								.__webglMultisampledFramebuffer : s, w.copy(e.viewport), M
								.copy(e.scissor), S = e.scissorTest
						} else w.copy(P).multiplyScalar(k).floor(), M.copy(N)
							.multiplyScalar(k).floor(), S = O;
						if (J.bindFramebuffer(36160, r) && Z.drawBuffers) {
							var l = !1;
							if (e)
								if (e.isWebGLMultipleRenderTargets) {
									var u = e.texture;
									if (F.length !== u.length || 36064 !== F[0]) {
										for (var c = 0, h = u.length; c < h; c++) F[c] =
											36064 + c;
										F.length = u.length, l = !0
									}
								} else 1 === F.length && 36064 === F[0] || (F[0] = 36064, F
									.length = 1, l = !0);
							else 1 === F.length && 1029 === F[0] || (F[0] = 1029, F.length =
								1, l = !0);
							l && (Z.isWebGL2 ? ye.drawBuffers(F) : $.get(
								"WEBGL_draw_buffers").drawBuffersWEBGL(F))
						}
						if (J.viewport(w), J.scissor(M), J.setScissorTest(S), i) {
							var d = K.get(e.texture);
							ye.framebufferTexture2D(36160, 36064, 34069 + t, d
								.__webglTexture, n)
						} else if (a) {
							var f = K.get(e.texture),
								p = t || 0;
							ye.framebufferTextureLayer(36160, 36064, f.__webglTexture, n ||
								0, p)
						}
					}, this.readRenderTargetPixels = function(e, t, n, r, i, a, o) {
						if (e && e.isWebGLRenderTarget) {
							var s = K.get(e).__webglFramebuffer;
							if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]),
								s) {
								J.bindFramebuffer(36160, s);
								try {
									var l = e.texture,
										u = l.format,
										c = l.type;
									if (u !== U && me.convert(u) !== ye.getParameter(35739))
										return void console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
											);
									var h = c === z && ($.has(
										"EXT_color_buffer_half_float") || Z.isWebGL2 &&
										$.has("EXT_color_buffer_float"));
									if (!(c === D || me.convert(c) === ye.getParameter(
											35738) || c === B && (Z.isWebGL2 || $.has(
											"OES_texture_float") || $.has(
											"WEBGL_color_buffer_float")) || h))
									return void console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
											);
									36053 === ye.checkFramebufferStatus(36160) ? t >= 0 &&
										t <= e.width - r && n >= 0 && n <= e.height - i &&
										ye.readPixels(t, n, r, i, me.convert(u), me.convert(
											c), a) : console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
											)
								} finally {
									var d = null !== x ? K.get(x).__webglFramebuffer : null;
									J.bindFramebuffer(36160, d)
								}
							}
						} else console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
							)
					}, this.copyFramebufferToTexture = function(e, t) {
						var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0,
							r = Math.pow(2, -n),
							i = Math.floor(t.image.width * r),
							a = Math.floor(t.image.height * r),
							o = me.convert(t.format);
						Z.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o =
							32856)), ee.setTexture2D(t, 0), ye.copyTexImage2D(3553, n, o, e
								.x, e.y, i, a, 0), J.unbindTexture()
					}, this.copyTextureToTexture = function(e, t, n) {
						var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 0,
							i = t.image.width,
							a = t.image.height,
							o = me.convert(n.format),
							s = me.convert(n.type);
						ee.setTexture2D(n, 0), ye.pixelStorei(37440, n.flipY), ye
							.pixelStorei(37441, n.premultiplyAlpha), ye.pixelStorei(3317, n
								.unpackAlignment), t.isDataTexture ? ye.texSubImage2D(3553,
								r, e.x, e.y, i, a, o, s, t.image.data) : t
							.isCompressedTexture ? ye.compressedTexSubImage2D(3553, r, e.x,
								e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[
									0].data) : ye.texSubImage2D(3553, r, e.x, e.y, o, s, t
								.image), 0 === r && n.generateMipmaps && ye.generateMipmap(
								3553), J.unbindTexture()
					}, this.copyTextureToTexture3D = function(e, t, n, r) {
						var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
							4] : 0;
						if (v.isWebGL1Renderer) console.warn(
							"THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
							);
						else {
							var a, o = n.image,
								s = o.width,
								l = o.height,
								u = o.data,
								c = me.convert(r.format),
								h = me.convert(r.type);
							if (r.isDataTexture3D) ee.setTexture3D(r, 0), a = 32879;
							else {
								if (!r.isDataTexture2DArray) return void console.warn(
									"THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
									);
								ee.setTexture2DArray(r, 0), a = 35866
							}
							ye.pixelStorei(37440, r.flipY), ye.pixelStorei(37441, r
								.premultiplyAlpha), ye.pixelStorei(3317, r
								.unpackAlignment);
							var d = ye.getParameter(3314),
								f = ye.getParameter(32878),
								p = ye.getParameter(3316),
								m = ye.getParameter(3315),
								g = ye.getParameter(32877);
							ye.pixelStorei(3314, s), ye.pixelStorei(32878, l), ye
								.pixelStorei(3316, e.min.x), ye.pixelStorei(3315, e.min.y),
								ye.pixelStorei(32877, e.min.z), ye.texSubImage3D(a, i, t.x,
									t.y, t.z, e.max.x - e.min.x + 1, e.max.y - e.min.y + 1,
									e.max.z - e.min.z + 1, c, h, u), ye.pixelStorei(3314,
								d), ye.pixelStorei(32878, f), ye.pixelStorei(3316, p), ye
								.pixelStorei(3315, m), ye.pixelStorei(32877, g), 0 === i &&
								r.generateMipmaps && ye.generateMipmap(a), J.unbindTexture()
						}
					}, this.initTexture = function(e) {
						ee.setTexture2D(e, 0), J.unbindTexture()
					}, this.resetState = function() {
						g = 0, y = 0, x = null, J.reset(), ge.reset()
					}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__
					.dispatchEvent(new CustomEvent("observe", {
						detail: this
					}))
			}
			var za = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(Ba);
			za.prototype.isWebGL1Renderer = !0;
			var Fa = function() {
				function e(t) {
					var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
						1] : 25e-5;
					(0, g.default)(this, e), this.name = "", this.color = new yn(t),
						this.density = n
				}
				return (0, y.default)(e, [{
					key: "clone",
					value: function() {
						return new e(this.color, this.density)
					}
				}, {
					key: "toJSON",
					value: function() {
						return {
							type: "FogExp2",
							color: this.color.getHex(),
							density: this.density
						}
					}
				}]), e
			}();
			Fa.prototype.isFogExp2 = !0;
			var Ha = function() {
				function e(t) {
					var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 1e3;
					(0, g.default)(this, e), this.name = "", this.color = new yn(t),
						this.near = n, this.far = r
				}
				return (0, y.default)(e, [{
					key: "clone",
					value: function() {
						return new e(this.color, this.near, this.far)
					}
				}, {
					key: "toJSON",
					value: function() {
						return {
							type: "Fog",
							color: this.color.getHex(),
							near: this.near,
							far: this.far
						}
					}
				}]), e
			}();
			Ha.prototype.isFog = !0;
			var Ua = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e;
					return (0, g.default)(this, n), (e = t.call(this)).type = "Scene", e
						.background = null, e.environment = null, e.fog = null, e
						.overrideMaterial = null, e.autoUpdate = !0, "undefined" !=
						typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(
							new CustomEvent("observe", {
								detail: (0, f.default)(e)
							})), e
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e, t) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this, e,
								t), null !== e.background && (this
								.background = e.background.clone()),
							null !== e.environment && (this
								.environment = e.environment.clone()),
							null !== e.fog && (this.fog = e.fog
						.clone()), null !== e.overrideMaterial && (this
								.overrideMaterial = e.overrideMaterial
								.clone()), this.autoUpdate = e
							.autoUpdate, this.matrixAutoUpdate = e
							.matrixAutoUpdate, this
					}
				}, {
					key: "toJSON",
					value: function(e) {
						var t = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this,
							e);
						return null !== this.background && (t.object
								.background = this.background.toJSON(e)
								), null !== this.environment && (t
								.object.environment = this.environment
								.toJSON(e)), null !== this.fog && (t
								.object.fog = this.fog.toJSON()), t
					}
				}]), n
			}(Xt);
			Ua.prototype.isScene = !0;
			var Ga = function() {
				function e(t, n) {
					(0, g.default)(this, e), this.array = t, this.stride = n, this
						.count = void 0 !== t ? t.length / n : 0, this.usage = me, this
						.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0, this.uuid = Te()
				}
				return (0, y.default)(e, [{
					key: "onUploadCallback",
					value: function() {}
				}, {
					key: "needsUpdate",
					set: function(e) {
						!0 === e && this.version++
					}
				}, {
					key: "setUsage",
					value: function(e) {
						return this.usage = e, this
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.array = new e.array.constructor(e
								.array), this.count = e.count, this
							.stride = e.stride, this.usage = e.usage,
							this
					}
				}, {
					key: "copyAt",
					value: function(e, t, n) {
						e *= this.stride, n *= t.stride;
						for (var r = 0, i = this.stride; r < i; r++)
							this.array[e + r] = t.array[n + r];
						return this
					}
				}, {
					key: "set",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : 0;
						return this.array.set(e, t), this
					}
				}, {
					key: "clone",
					value: function(e) {
						void 0 === e.arrayBuffers && (e
								.arrayBuffers = {}), void 0 === this
							.array.buffer._uuid && (this.array.buffer
								._uuid = Te()), void 0 === e
							.arrayBuffers[this.array.buffer._uuid] && (e
								.arrayBuffers[this.array.buffer._uuid] =
								this.array.slice(0).buffer);
						var t = new this.array.constructor(e
								.arrayBuffers[this.array.buffer._uuid]),
							n = new this.constructor(t, this.stride);
						return n.setUsage(this.usage), n
					}
				}, {
					key: "onUpload",
					value: function(e) {
						return this.onUploadCallback = e, this
					}
				}, {
					key: "toJSON",
					value: function(e) {
						return void 0 === e.arrayBuffers && (e
								.arrayBuffers = {}), void 0 === this
							.array.buffer._uuid && (this.array.buffer
								._uuid = Te()), void 0 === e
							.arrayBuffers[this.array.buffer._uuid] && (e
								.arrayBuffers[this.array.buffer._uuid] =
								Array.prototype.slice.call(
									new Uint32Array(this.array.buffer))
								), {
								uuid: this.uuid,
								buffer: this.array.buffer._uuid,
								type: this.array.constructor.name,
								stride: this.stride
							}
					}
				}]), e
			}();
			Ga.prototype.isInterleavedBuffer = !0;
			var Va = new je,
				Wa = function() {
					function e(t, n, r, i) {
						(0, g.default)(this, e), this.name = "", this.data = t, this
							.itemSize = n, this.offset = r, this.normalized = !0 === i
					}
					return (0, y.default)(e, [{
						key: "count",
						get: function() {
							return this.data.count
						}
					}, {
						key: "array",
						get: function() {
							return this.data.array
						}
					}, {
						key: "needsUpdate",
						set: function(e) {
							this.data.needsUpdate = e
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							for (var t = 0, n = this.data.count; t < n; t++)
								Va.x = this.getX(t), Va.y = this.getY(t), Va
								.z = this.getZ(t), Va.applyMatrix4(e), this
								.setXYZ(t, Va.x, Va.y, Va.z);
							return this
						}
					}, {
						key: "applyNormalMatrix",
						value: function(e) {
							for (var t = 0, n = this.count; t < n; t++) Va
								.x = this.getX(t), Va.y = this.getY(t), Va
								.z = this.getZ(t), Va.applyNormalMatrix(e),
								this.setXYZ(t, Va.x, Va.y, Va.z);
							return this
						}
					}, {
						key: "transformDirection",
						value: function(e) {
							for (var t = 0, n = this.count; t < n; t++) Va
								.x = this.getX(t), Va.y = this.getY(t), Va
								.z = this.getZ(t), Va.transformDirection(e),
								this.setXYZ(t, Va.x, Va.y, Va.z);
							return this
						}
					}, {
						key: "setX",
						value: function(e, t) {
							return this.data.array[e * this.data.stride +
								this.offset] = t, this
						}
					}, {
						key: "setY",
						value: function(e, t) {
							return this.data.array[e * this.data.stride +
								this.offset + 1] = t, this
						}
					}, {
						key: "setZ",
						value: function(e, t) {
							return this.data.array[e * this.data.stride +
								this.offset + 2] = t, this
						}
					}, {
						key: "setW",
						value: function(e, t) {
							return this.data.array[e * this.data.stride +
								this.offset + 3] = t, this
						}
					}, {
						key: "getX",
						value: function(e) {
							return this.data.array[e * this.data.stride +
								this.offset]
						}
					}, {
						key: "getY",
						value: function(e) {
							return this.data.array[e * this.data.stride +
								this.offset + 1]
						}
					}, {
						key: "getZ",
						value: function(e) {
							return this.data.array[e * this.data.stride +
								this.offset + 2]
						}
					}, {
						key: "getW",
						value: function(e) {
							return this.data.array[e * this.data.stride +
								this.offset + 3]
						}
					}, {
						key: "setXY",
						value: function(e, t, n) {
							return e = e * this.data.stride + this.offset,
								this.data.array[e + 0] = t, this.data.array[
									e + 1] = n, this
						}
					}, {
						key: "setXYZ",
						value: function(e, t, n, r) {
							return e = e * this.data.stride + this.offset,
								this.data.array[e + 0] = t, this.data.array[
									e + 1] = n, this.data.array[e + 2] = r,
								this
						}
					}, {
						key: "setXYZW",
						value: function(e, t, n, r, i) {
							return e = e * this.data.stride + this.offset,
								this.data.array[e + 0] = t, this.data.array[
									e + 1] = n, this.data.array[e + 2] = r,
								this.data.array[e + 3] = i, this
						}
					}, {
						key: "clone",
						value: function(t) {
							if (void 0 === t) {
								console.log(
									"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
									);
								for (var n = [], r = 0; r < this.count; r++)
									for (var i = r * this.data.stride + this
											.offset, a = 0; a < this
										.itemSize; a++) n.push(this.data
										.array[i + a]);
								return new wn(new this.array.constructor(n),
									this.itemSize, this.normalized)
							}
							return void 0 === t.interleavedBuffers && (t
									.interleavedBuffers = {}), void 0 === t
								.interleavedBuffers[this.data.uuid] && (t
									.interleavedBuffers[this.data.uuid] =
									this.data.clone(t)), new e(t
									.interleavedBuffers[this.data.uuid],
									this.itemSize, this.offset, this
									.normalized)
						}
					}, {
						key: "toJSON",
						value: function(e) {
							if (void 0 === e) {
								console.log(
									"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
									);
								for (var t = [], n = 0; n < this.count; n++)
									for (var r = n * this.data.stride + this
											.offset, i = 0; i < this
										.itemSize; i++) t.push(this.data
										.array[r + i]);
								return {
									itemSize: this.itemSize,
									type: this.array.constructor.name,
									array: t,
									normalized: this.normalized
								}
							}
							return void 0 === e.interleavedBuffers && (e
									.interleavedBuffers = {}), void 0 === e
								.interleavedBuffers[this.data.uuid] && (e
									.interleavedBuffers[this.data.uuid] =
									this.data.toJSON(e)), {
									isInterleavedBufferAttribute: !0,
									itemSize: this.itemSize,
									data: this.data.uuid,
									offset: this.offset,
									normalized: this.normalized
								}
						}
					}]), e
				}();
			Wa.prototype.isInterleavedBufferAttribute = !0;
			var ja, qa = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"SpriteMaterial", r.color = new yn(16777215), r.map = null, r
						.alphaMap = null, r.rotation = 0, r.sizeAttenuation = !0, r
						.transparent = !0, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.map = e
							.map, this.alphaMap = e.alphaMap, this
							.rotation = e.rotation, this
							.sizeAttenuation = e.sizeAttenuation, this
					}
				}]), n
			}(hn);
			qa.prototype.isSpriteMaterial = !0;
			var Xa = new je,
				Ya = new je,
				$a = new je,
				Za = new Ie,
				Ja = new Ie,
				Qa = new wt,
				Ka = new je,
				eo = new je,
				to = new je,
				no = new Ie,
				ro = new Ie,
				io = new Ie,
				ao = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						if ((0, g.default)(this, n), (r = t.call(this)).type = "Sprite",
							void 0 === ja) {
							ja = new Vn;
							var i = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0,
									.5, .5, 0, 1, 1, -.5, .5, 0, 0, 1
								]),
								a = new Ga(i, 5);
							ja.setIndex([0, 1, 2, 0, 2, 3]), ja.setAttribute("position",
								new Wa(a, 3, 0, !1)), ja.setAttribute("uv", new Wa(a, 2,
								3, !1))
						}
						return r.geometry = ja, r.material = void 0 !== e ? e : new qa, r
							.center = new Ie(.5, .5), (0, v.default)(r)
					}
					return (0, y.default)(n, [{
						key: "raycast",
						value: function(e, t) {
							null === e.camera && console.error(
									'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
									), Ya.setFromMatrixScale(this
									.matrixWorld), Qa.copy(e.camera
									.matrixWorld), this.modelViewMatrix
								.multiplyMatrices(e.camera
									.matrixWorldInverse, this.matrixWorld),
								$a.setFromMatrixPosition(this
									.modelViewMatrix), e.camera
								.isPerspectiveCamera && !1 === this.material
								.sizeAttenuation && Ya.multiplyScalar(-$a
								.z);
							var n, r, i = this.material.rotation;
							0 !== i && (r = Math.cos(i), n = Math.sin(i));
							var a = this.center;
							oo(Ka.set(-.5, -.5, 0), $a, a, Ya, n, r), oo(eo
									.set(.5, -.5, 0), $a, a, Ya, n, r), oo(
									to.set(.5, .5, 0), $a, a, Ya, n, r), no
								.set(0, 0), ro.set(1, 0), io.set(1, 1);
							var o = e.ray.intersectTriangle(Ka, eo, to, !1,
								Xa);
							if (null !== o || (oo(eo.set(-.5, .5, 0), $a, a,
									Ya, n, r), ro.set(0, 1), null !== (
									o = e.ray.intersectTriangle(Ka, to,
										eo, !1, Xa)))) {
								var s = e.ray.origin.distanceTo(Xa);
								s < e.near || s > e.far || t.push({
									distance: s,
									point: Xa.clone(),
									uv: un.getUV(Xa, Ka, eo, to, no,
										ro, io, new Ie),
									face: null,
									object: this
								})
							}
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), void 0 !== e.center && this.center.copy(
									e.center), this.material = e.material,
								this
						}
					}]), n
				}(Xt);

			function oo(e, t, n, r, i, a) {
				Za.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Ja.x = a * Za
						.x - i * Za.y, Ja.y = i * Za.x + a * Za.y) : Ja.copy(Za), e.copy(t),
					e.x += Ja.x, e.y += Ja.y, e.applyMatrix4(Qa)
			}
			ao.prototype.isSprite = !0;
			var so = new je,
				lo = new je,
				uo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this))._currentLevel =
							0, e.type = "LOD", Object.defineProperties((0, f.default)(e), {
								levels: {
									enumerable: !0,
									value: []
								},
								isLOD: {
									value: !0
								}
							}), e.autoUpdate = !0, e
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"copy", this).call(this, e, !1);
							for (var t = e.levels, r = 0, i = t.length; r <
								i; r++) {
								var a = t[r];
								this.addLevel(a.object.clone(), a.distance)
							}
							return this.autoUpdate = e.autoUpdate, this
						}
					}, {
						key: "addLevel",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0;
							t = Math.abs(t);
							var n, r = this.levels;
							for (n = 0; n < r.length && !(t < r[n]
								.distance); n++);
							return r.splice(n, 0, {
								distance: t,
								object: e
							}), this.add(e), this
						}
					}, {
						key: "getCurrentLevel",
						value: function() {
							return this._currentLevel
						}
					}, {
						key: "getObjectForDistance",
						value: function(e) {
							var t = this.levels;
							if (t.length > 0) {
								var n, r;
								for (n = 1, r = t.length; n < r && !(e < t[
										n].distance); n++);
								return t[n - 1].object
							}
							return null
						}
					}, {
						key: "raycast",
						value: function(e, t) {
							if (this.levels.length > 0) {
								so.setFromMatrixPosition(this.matrixWorld);
								var n = e.ray.origin.distanceTo(so);
								this.getObjectForDistance(n).raycast(e, t)
							}
						}
					}, {
						key: "update",
						value: function(e) {
							var t = this.levels;
							if (t.length > 1) {
								so.setFromMatrixPosition(e.matrixWorld), lo
									.setFromMatrixPosition(this
									.matrixWorld);
								var n, r, i = so.distanceTo(lo) / e.zoom;
								for (t[0].object.visible = !0, n = 1, r = t
									.length; n < r && i >= t[n]
									.distance; n++) t[n - 1].object
									.visible = !1, t[n].object.visible = !0;
								for (this._currentLevel = n - 1; n < r; n++)
									t[n].object.visible = !1
							}
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this,
								e);
							!1 === this.autoUpdate && (t.object
								.autoUpdate = !1), t.object.levels = [];
							for (var r = this.levels, i = 0, a = r
								.length; i < a; i++) {
								var o = r[i];
								t.object.levels.push({
									object: o.object.uuid,
									distance: o.distance
								})
							}
							return t
						}
					}]), n
				}(Xt),
				co = new je,
				ho = new He,
				fo = new He,
				po = new je,
				vo = new wt,
				mo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
							"SkinnedMesh", i.bindMode = "attached", i.bindMatrix = new wt, i
							.bindMatrixInverse = new wt, i
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.bindMode = e.bindMode, this
								.bindMatrix.copy(e.bindMatrix), this
								.bindMatrixInverse.copy(e
								.bindMatrixInverse), this.skeleton = e
								.skeleton, this
						}
					}, {
						key: "bind",
						value: function(e, t) {
							this.skeleton = e, void 0 === t && (this
									.updateMatrixWorld(!0), this.skeleton
									.calculateInverses(), t = this
									.matrixWorld), this.bindMatrix.copy(t),
								this.bindMatrixInverse.copy(t).invert()
						}
					}, {
						key: "pose",
						value: function() {
							this.skeleton.pose()
						}
					}, {
						key: "normalizeSkinWeights",
						value: function() {
							for (var e = new He, t = this.geometry
									.attributes.skinWeight, n = 0, r = t
									.count; n < r; n++) {
								e.x = t.getX(n), e.y = t.getY(n), e.z = t
									.getZ(n), e.w = t.getW(n);
								var i = 1 / e.manhattanLength();
								i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1,
									0, 0, 0), t.setXYZW(n, e.x, e.y, e
									.z, e.w)
							}
						}
					}, {
						key: "updateMatrixWorld",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"updateMatrixWorld", this).call(this, e),
								"attached" === this.bindMode ? this
								.bindMatrixInverse.copy(this.matrixWorld)
								.invert() : "detached" === this.bindMode ?
								this.bindMatrixInverse.copy(this.bindMatrix)
								.invert() : console.warn(
									"THREE.SkinnedMesh: Unrecognized bindMode: " +
									this.bindMode)
						}
					}, {
						key: "boneTransform",
						value: function(e, t) {
							var n = this.skeleton,
								r = this.geometry;
							ho.fromBufferAttribute(r.attributes.skinIndex,
								e), fo.fromBufferAttribute(r.attributes
								.skinWeight, e), co.fromBufferAttribute(
								r.attributes.position, e).applyMatrix4(
								this.bindMatrix), t.set(0, 0, 0);
							for (var i = 0; i < 4; i++) {
								var a = fo.getComponent(i);
								if (0 !== a) {
									var o = ho.getComponent(i);
									vo.multiplyMatrices(n.bones[o]
											.matrixWorld, n.boneInverses[o]
											), t.addScaledVector(po.copy(co)
											.applyMatrix4(vo), a)
								}
							}
							return t.applyMatrix4(this.bindMatrixInverse)
						}
					}]), n
				}(sr);
			mo.prototype.isSkinnedMesh = !0;
			var go = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e;
					return (0, g.default)(this, n), (e = t.call(this)).type = "Bone", e
				}
				return n
			}(Xt);
			go.prototype.isBone = !0;
			var yo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s, l, u, c, h, d, f) {
					var p;
					return (0, g.default)(this, n), (p = t.call(this, null, s, l, u, c,
							h, a, o, d, f)).image = {
							data: e || null,
							width: r || 1,
							height: i || 1
						}, p.magFilter = void 0 !== c ? c : L, p.minFilter = void 0 !==
						h ? h : L, p.generateMipmaps = !1, p.flipY = !1, p
						.unpackAlignment = 1, p.needsUpdate = !0, p
				}
				return n
			}(ze);
			yo.prototype.isDataTexture = !0;
			var xo = new wt,
				_o = new wt,
				bo = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : [],
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : [];
						(0, g.default)(this, e), this.uuid = Te(), this.bones = t.slice(0),
							this.boneInverses = n, this.boneMatrices = null, this
							.boneTexture = null, this.boneTextureSize = 0, this.frame = -1,
							this.init()
					}
					return (0, y.default)(e, [{
						key: "init",
						value: function() {
							var e = this.bones,
								t = this.boneInverses;
							if (this.boneMatrices = new Float32Array(16 * e
									.length), 0 === t.length) this
								.calculateInverses();
							else if (e.length !== t.length) {
								console.warn(
									"THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
									), this.boneInverses = [];
								for (var n = 0, r = this.bones.length; n <
									r; n++) this.boneInverses.push(new wt)
							}
						}
					}, {
						key: "calculateInverses",
						value: function() {
							this.boneInverses.length = 0;
							for (var e = 0, t = this.bones.length; e <
								t; e++) {
								var n = new wt;
								this.bones[e] && n.copy(this.bones[e]
										.matrixWorld).invert(), this
									.boneInverses.push(n)
							}
						}
					}, {
						key: "pose",
						value: function() {
							for (var e = 0, t = this.bones.length; e <
								t; e++) {
								var n = this.bones[e];
								n && n.matrixWorld.copy(this.boneInverses[
									e]).invert()
							}
							for (var r = 0, i = this.bones.length; r <
								i; r++) {
								var a = this.bones[r];
								a && (a.parent && a.parent.isBone ? (a
										.matrix.copy(a.parent
											.matrixWorld).invert(), a
										.matrix.multiply(a.matrixWorld)
										) : a.matrix.copy(a
									.matrixWorld), a.matrix.decompose(a
										.position, a.quaternion, a.scale
										))
							}
						}
					}, {
						key: "update",
						value: function() {
							for (var e = this.bones, t = this.boneInverses,
									n = this.boneMatrices, r = this
									.boneTexture, i = 0, a = e.length; i <
								a; i++) {
								var o = e[i] ? e[i].matrixWorld : _o;
								xo.multiplyMatrices(o, t[i]), xo.toArray(n,
									16 * i)
							}
							null !== r && (r.needsUpdate = !0)
						}
					}, {
						key: "clone",
						value: function() {
							return new e(this.bones, this.boneInverses)
						}
					}, {
						key: "computeBoneTexture",
						value: function() {
							var e = Math.sqrt(4 * this.bones.length);
							e = Re(e), e = Math.max(e, 4);
							var t = new Float32Array(e * e * 4);
							t.set(this.boneMatrices);
							var n = new yo(t, e, e, U, B);
							return this.boneMatrices = t, this.boneTexture =
								n, this.boneTextureSize = e, this
						}
					}, {
						key: "getBoneByName",
						value: function(e) {
							for (var t = 0, n = this.bones.length; t <
								n; t++) {
								var r = this.bones[t];
								if (r.name === e) return r
							}
						}
					}, {
						key: "dispose",
						value: function() {
							null !== this.boneTexture && (this.boneTexture
								.dispose(), this.boneTexture = null)
						}
					}, {
						key: "fromJSON",
						value: function(e, t) {
							this.uuid = e.uuid;
							for (var n = 0, r = e.bones.length; n <
								r; n++) {
								var i = e.bones[n],
									a = t[i];
								void 0 === a && (console.warn(
										"THREE.Skeleton: No bone found with UUID:",
										i), a = new go), this.bones.push(a),
									this.boneInverses.push((new wt)
										.fromArray(e.boneInverses[n]))
							}
							return this.init(), this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = {
								metadata: {
									version: 4.5,
									type: "Skeleton",
									generator: "Skeleton.toJSON"
								},
								bones: [],
								boneInverses: []
							};
							e.uuid = this.uuid;
							for (var t = this.bones, n = this.boneInverses,
									r = 0, i = t.length; r < i; r++) {
								var a = t[r];
								e.bones.push(a.uuid);
								var o = n[r];
								e.boneInverses.push(o.toArray())
							}
							return e
						}
					}]), e
				}(),
				wo = new wt,
				Mo = new wt,
				So = [],
				To = new sr,
				Eo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						return (0, g.default)(this, n), (a = t.call(this, e, r))
							.instanceMatrix = new wn(new Float32Array(16 * i), 16), a
							.instanceColor = null, a.count = i, a.frustumCulled = !1, a
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.instanceMatrix.copy(e
									.instanceMatrix), null !== e
								.instanceColor && (this.instanceColor = e
									.instanceColor.clone()), this.count = e
								.count, this
						}
					}, {
						key: "getColorAt",
						value: function(e, t) {
							t.fromArray(this.instanceColor.array, 3 * e)
						}
					}, {
						key: "getMatrixAt",
						value: function(e, t) {
							t.fromArray(this.instanceMatrix.array, 16 * e)
						}
					}, {
						key: "raycast",
						value: function(e, t) {
							var n = this.matrixWorld,
								r = this.count;
							if (To.geometry = this.geometry, To.material =
								this.material, void 0 !== To.material)
								for (var i = 0; i < r; i++) {
									this.getMatrixAt(i, wo), Mo
										.multiplyMatrices(n, wo), To
										.matrixWorld = Mo, To.raycast(e,
										So);
									for (var a = 0, o = So.length; a <
										o; a++) {
										var s = So[a];
										s.instanceId = i, s.object = this, t
											.push(s)
									}
									So.length = 0
								}
						}
					}, {
						key: "setColorAt",
						value: function(e, t) {
							null === this.instanceColor && (this
								.instanceColor = new wn(
									new Float32Array(3 * this.count), 3)
								), t.toArray(this.instanceColor.array,
								3 * e)
						}
					}, {
						key: "setMatrixAt",
						value: function(e, t) {
							t.toArray(this.instanceMatrix.array, 16 * e)
						}
					}, {
						key: "updateMorphTargets",
						value: function() {}
					}, {
						key: "dispose",
						value: function() {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}]), n
				}(sr);
			Eo.prototype.isInstancedMesh = !0;
			var Ao = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"LineBasicMaterial", r.color = new yn(16777215), r.linewidth =
						1, r.linecap = "round", r.linejoin = "round", r.morphTargets = !
						1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this
							.linewidth = e.linewidth, this.linecap = e
							.linecap, this.linejoin = e.linejoin, this
							.morphTargets = e.morphTargets, this
					}
				}]), n
			}(hn);
			Ao.prototype.isLineBasicMaterial = !0;
			var Lo = new je,
				ko = new je,
				Ro = new wt,
				Co = new bt,
				Po = new ft,
				Io = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new Vn,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new Ao;
						return (0, g.default)(this, n), (e = t.call(this)).type = "Line", e
							.geometry = r, e.material = i, e.updateMorphTargets(), e
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.material = e.material, this
								.geometry = e.geometry, this
						}
					}, {
						key: "computeLineDistances",
						value: function() {
							var e = this.geometry;
							if (e.isBufferGeometry)
								if (null === e.index) {
									for (var t = e.attributes.position,
											n = [0], r = 1, i = t.count; r <
										i; r++) Lo.fromBufferAttribute(t,
											r - 1), ko.fromBufferAttribute(
											t, r), n[r] = n[r - 1], n[r] +=
										Lo.distanceTo(ko);
									e.setAttribute("lineDistance", new Cn(n,
										1))
								} else console.warn(
									"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else e.isGeometry && console.error(
								"THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
								);
							return this
						}
					}, {
						key: "raycast",
						value: function(e, t) {
							var n = this.geometry,
								r = this.matrixWorld,
								i = e.params.Line.threshold,
								a = n.drawRange;
							if (null === n.boundingSphere && n
								.computeBoundingSphere(), Po.copy(n
									.boundingSphere), Po.applyMatrix4(r), Po
								.radius += i, !1 !== e.ray.intersectsSphere(
									Po)) {
								Ro.copy(r).invert(), Co.copy(e.ray)
									.applyMatrix4(Ro);
								var o = i / ((this.scale.x + this.scale.y +
										this.scale.z) / 3),
									s = o * o,
									l = new je,
									u = new je,
									c = new je,
									h = new je,
									d = this.isLineSegments ? 2 : 1;
								if (n.isBufferGeometry) {
									var f = n.index,
										p = n.attributes.position;
									if (null !== f)
										for (var v = Math.max(0, a.start),
												m = Math.min(f.count, a
													.start + a.count) -
												1; v < m; v += d) {
											var g = f.getX(v),
												y = f.getX(v + 1);
											if (l.fromBufferAttribute(p, g),
												u.fromBufferAttribute(p, y),
												!(Co.distanceSqToSegment(l,
													u, h, c) > s)) {
												h.applyMatrix4(this
													.matrixWorld);
												var x = e.ray.origin
													.distanceTo(h);
												x < e.near || x > e.far || t
													.push({
														distance: x,
														point: c.clone()
															.applyMatrix4(
																this
																.matrixWorld
																),
														index: v,
														face: null,
														faceIndex: null,
														object: this
													})
											}
										} else
											for (var _ = Math.max(0, a
														.start), b = Math
													.min(p.count, a.start +
														a.count) - 1; _ <
												b; _ += d)
												if (l.fromBufferAttribute(p,
														_), u
													.fromBufferAttribute(p,
														_ + 1), !(Co
														.distanceSqToSegment(
															l, u, h, c) > s)
													) {
													h.applyMatrix4(this
														.matrixWorld);
													var w = e.ray.origin
														.distanceTo(h);
													w < e.near || w > e
														.far || t.push({
															distance: w,
															point: c
																.clone()
																.applyMatrix4(
																	this
																	.matrixWorld
																	),
															index: _,
															face: null,
															faceIndex: null,
															object: this
														})
												}
								} else n.isGeometry && console.error(
									"THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
							}
						}
					}, {
						key: "updateMorphTargets",
						value: function() {
							var e = this.geometry;
							if (e.isBufferGeometry) {
								var t = e.morphAttributes,
									n = Object.keys(t);
								if (n.length > 0) {
									var r = t[n[0]];
									if (void 0 !== r) {
										this.morphTargetInfluences = [],
											this.morphTargetDictionary = {};
										for (var i = 0, a = r.length; i <
											a; i++) {
											var o = r[i].name || String(i);
											this.morphTargetInfluences.push(
													0), this
												.morphTargetDictionary[o] =
												i
										}
									}
								}
							} else {
								var s = e.morphTargets;
								void 0 !== s && s.length > 0 && console
									.error(
										"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
										)
							}
						}
					}]), n
				}(Xt);
			Io.prototype.isLine = !0;
			var Do = new je,
				No = new je,
				Oo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
							"LineSegments", i
					}
					return (0, y.default)(n, [{
						key: "computeLineDistances",
						value: function() {
							var e = this.geometry;
							if (e.isBufferGeometry)
								if (null === e.index) {
									for (var t = e.attributes.position,
											n = [], r = 0, i = t.count; r <
										i; r += 2) Do.fromBufferAttribute(t,
											r), No.fromBufferAttribute(t,
											r + 1), n[r] = 0 === r ? 0 : n[
											r - 1], n[r + 1] = n[r] + Do
										.distanceTo(No);
									e.setAttribute("lineDistance", new Cn(n,
										1))
								} else console.warn(
									"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else e.isGeometry && console.error(
								"THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
								);
							return this
						}
					}]), n
				}(Io);
			Oo.prototype.isLineSegments = !0;
			var Bo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"LineLoop", i
				}
				return n
			}(Io);
			Bo.prototype.isLineLoop = !0;
			var zo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"PointsMaterial", r.color = new yn(16777215), r.map = null, r
						.alphaMap = null, r.size = 1, r.sizeAttenuation = !0, r
						.morphTargets = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.map = e
							.map, this.alphaMap = e.alphaMap, this
							.size = e.size, this.sizeAttenuation = e
							.sizeAttenuation, this.morphTargets = e
							.morphTargets, this
					}
				}]), n
			}(hn);
			zo.prototype.isPointsMaterial = !0;
			var Fo = new wt,
				Ho = new bt,
				Uo = new ft,
				Go = new je,
				Vo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new Vn,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new zo;
						return (0, g.default)(this, n), (e = t.call(this)).type = "Points",
							e.geometry = r, e.material = i, e.updateMorphTargets(), e
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.material = e.material, this
								.geometry = e.geometry, this
						}
					}, {
						key: "raycast",
						value: function(e, t) {
							var n = this.geometry,
								r = this.matrixWorld,
								i = e.params.Points.threshold,
								a = n.drawRange;
							if (null === n.boundingSphere && n
								.computeBoundingSphere(), Uo.copy(n
									.boundingSphere), Uo.applyMatrix4(r), Uo
								.radius += i, !1 !== e.ray.intersectsSphere(
									Uo)) {
								Fo.copy(r).invert(), Ho.copy(e.ray)
									.applyMatrix4(Fo);
								var o = i / ((this.scale.x + this.scale.y +
										this.scale.z) / 3),
									s = o * o;
								if (n.isBufferGeometry) {
									var l = n.index,
										u = n.attributes.position;
									if (null !== l)
										for (var c = Math.max(0, a.start),
												h = Math.min(l.count, a
													.start + a.count); c <
											h; c++) {
											var d = l.getX(c);
											Go.fromBufferAttribute(u, d),
												Wo(Go, d, s, r, e, t, this)
										} else
											for (var f = Math.max(0, a
														.start), p = Math
													.min(u.count, a.start +
														a.count); f <
												p; f++) Go
												.fromBufferAttribute(u, f),
												Wo(Go, f, s, r, e, t, this)
								} else console.error(
									"THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
							}
						}
					}, {
						key: "updateMorphTargets",
						value: function() {
							var e = this.geometry;
							if (e.isBufferGeometry) {
								var t = e.morphAttributes,
									n = Object.keys(t);
								if (n.length > 0) {
									var r = t[n[0]];
									if (void 0 !== r) {
										this.morphTargetInfluences = [],
											this.morphTargetDictionary = {};
										for (var i = 0, a = r.length; i <
											a; i++) {
											var o = r[i].name || String(i);
											this.morphTargetInfluences.push(
													0), this
												.morphTargetDictionary[o] =
												i
										}
									}
								}
							} else {
								var s = e.morphTargets;
								void 0 !== s && s.length > 0 && console
									.error(
										"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
										)
							}
						}
					}]), n
				}(Xt);

			function Wo(e, t, n, r, i, a, o) {
				var s = Ho.distanceSqToPoint(e);
				if (s < n) {
					var l = new je;
					Ho.closestPointToPoint(e, l), l.applyMatrix4(r);
					var u = i.ray.origin.distanceTo(l);
					if (u < i.near || u > i.far) return;
					a.push({
						distance: u,
						distanceToRay: Math.sqrt(s),
						point: l,
						index: t,
						face: null,
						object: o
					})
				}
			}
			Vo.prototype.isPoints = !0;
			var jo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s, l, u, c) {
					var h;
					(0, g.default)(this, n), (h = t.call(this, e, r, i, a, o, s, l, u,
						c)).format = void 0 !== l ? l : H, h.minFilter = void 0 !== s ?
						s : C, h.magFilter = void 0 !== o ? o : C, h.generateMipmaps = !
						1;
					var d = (0, f.default)(h);
					return "requestVideoFrameCallback" in e && e
						.requestVideoFrameCallback((function t() {
							d.needsUpdate = !0, e.requestVideoFrameCallback(t)
						})), h
				}
				return (0, y.default)(n, [{
					key: "clone",
					value: function() {
						return new this.constructor(this.image).copy(
							this)
					}
				}, {
					key: "update",
					value: function() {
						var e = this.image;
						0 == "requestVideoFrameCallback" in e && e
							.readyState >= e.HAVE_CURRENT_DATA && (this
								.needsUpdate = !0)
					}
				}]), n
			}(ze);
			jo.prototype.isVideoTexture = !0;
			var qo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s, l, u, c, h, d, f) {
					var p;
					return (0, g.default)(this, n), (p = t.call(this, null, s, l, u, c,
						h, a, o, d, f)).image = {
						width: r,
						height: i
					}, p.mipmaps = e, p.flipY = !1, p.generateMipmaps = !1, p
				}
				return n
			}(ze);
			qo.prototype.isCompressedTexture = !0;
			var Xo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s, l, u, c) {
					var h;
					return (0, g.default)(this, n), (h = t.call(this, e, r, i, a, o, s,
						l, u, c)).needsUpdate = !0, h
				}
				return n
			}(ze);
			Xo.prototype.isCanvasTexture = !0;
			var Yo = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s, l, u, c, h) {
					var d;
					if ((0, g.default)(this, n), (h = void 0 !== h ? h : G) !== G &&
						h !== V) throw new Error(
						"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
						);
					return void 0 === i && h === G && (i = N), void 0 === i && h ===
						V && (i = F), (d = t.call(this, null, a, o, s, l, u, h, i, c))
						.image = {
							width: e,
							height: r
						}, d.magFilter = void 0 !== l ? l : L, d.minFilter = void 0 !==
						u ? u : L, d.flipY = !1, d.generateMipmaps = !1, d
				}
				return n
			}(ze);
			Yo.prototype.isDepthTexture = !0;
			var $o = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 8,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 2 * Math.PI;
						(0, g.default)(this, n), (e = t.call(this)).type = "CircleGeometry",
							e.parameters = {
								radius: r,
								segments: i,
								thetaStart: a,
								thetaLength: o
							}, i = Math.max(3, i);
						var s = [],
							l = [],
							u = [],
							c = [],
							h = new je,
							d = new Ie;
						l.push(0, 0, 0), u.push(0, 0, 1), c.push(.5, .5);
						for (var f = 0, p = 3; f <= i; f++, p += 3) {
							var v = a + f / i * o;
							h.x = r * Math.cos(v), h.y = r * Math.sin(v), l.push(h.x, h.y, h
								.z), u.push(0, 0, 1), d.x = (l[p] / r + 1) / 2, d.y = (
								l[p + 1] / r + 1) / 2, c.push(d.x, d.y)
						}
						for (var m = 1; m <= i; m++) s.push(m, m + 1, 0);
						return e.setIndex(s), e.setAttribute("position", new Cn(l, 3)), e
							.setAttribute("normal", new Cn(u, 3)), e.setAttribute("uv",
								new Cn(c, 2)), e
					}
					return n
				}(Vn),
				Zo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 1,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 8,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 1,
							l = arguments.length > 5 && void 0 !== arguments[5] &&
							arguments[5],
							u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[
								6] : 0,
							c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[
								7] : 2 * Math.PI;
						(0, g.default)(this, n), (e = t.call(this)).type =
							"CylinderGeometry", e.parameters = {
								radiusTop: r,
								radiusBottom: i,
								height: a,
								radialSegments: o,
								heightSegments: s,
								openEnded: l,
								thetaStart: u,
								thetaLength: c
							};
						var h = (0, f.default)(e);
						o = Math.floor(o), s = Math.floor(s);
						var d = [],
							p = [],
							v = [],
							m = [],
							y = 0,
							x = [],
							_ = a / 2,
							b = 0;

						function w(e) {
							for (var t = y, n = new Ie, a = new je, s = 0, l = !0 === e ?
									r : i, f = !0 === e ? 1 : -1, g = 1; g <= o; g++) p
								.push(0, _ * f, 0), v.push(0, f, 0), m.push(.5, .5), y++;
							for (var x = y, w = 0; w <= o; w++) {
								var M = w / o * c + u,
									S = Math.cos(M),
									T = Math.sin(M);
								a.x = l * T, a.y = _ * f, a.z = l * S, p.push(a.x, a.y, a
									.z), v.push(0, f, 0), n.x = .5 * S + .5, n.y = .5 * T *
									f + .5, m.push(n.x, n.y), y++
							}
							for (var E = 0; E < o; E++) {
								var A = t + E,
									L = x + E;
								!0 === e ? d.push(L, L + 1, A) : d.push(L + 1, L, A), s += 3
							}
							h.addGroup(b, s, !0 === e ? 1 : 2), b += s
						}
						return function() {
								for (var e = new je, t = new je, n = 0, l = (i - r) / a, f =
										0; f <= s; f++) {
									for (var g = [], w = f / s, M = w * (i - r) + r, S =
										0; S <= o; S++) {
										var T = S / o,
											E = T * c + u,
											A = Math.sin(E),
											L = Math.cos(E);
										t.x = M * A, t.y = -w * a + _, t.z = M * L, p.push(t
												.x, t.y, t.z), e.set(A, l, L).normalize(), v
											.push(e.x, e.y, e.z), m.push(T, 1 - w), g.push(
												y++)
									}
									x.push(g)
								}
								for (var k = 0; k < o; k++)
									for (var R = 0; R < s; R++) {
										var C = x[R][k],
											P = x[R + 1][k],
											I = x[R + 1][k + 1],
											D = x[R][k + 1];
										d.push(C, P, D), d.push(P, I, D), n += 6
									}
								h.addGroup(b, n, 0), b += n
							}(), !1 === l && (r > 0 && w(!0), i > 0 && w(!1)), e.setIndex(
							d), e.setAttribute("position", new Cn(p, 3)), e.setAttribute(
								"normal", new Cn(v, 3)), e.setAttribute("uv", new Cn(m, 2)),
							e
					}
					return n
				}(Vn),
				Jo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 1,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 8,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1,
							s = arguments.length > 4 && void 0 !== arguments[4] &&
							arguments[4],
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 0,
							u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[
								6] : 2 * Math.PI;
						return (0, g.default)(this, n), (e = t.call(this, 0, r, i, a, o, s,
							l, u)).type = "ConeGeometry", e.parameters = {
							radius: r,
							height: i,
							radialSegments: a,
							heightSegments: o,
							openEnded: s,
							thetaStart: l,
							thetaLength: u
						}, e
					}
					return n
				}(Zo),
				Qo = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
							arguments[2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 0;
						(0, g.default)(this, n), (i = t.call(this)).type =
							"PolyhedronGeometry", i.parameters = {
								vertices: e,
								indices: r,
								radius: a,
								detail: o
							};
						var s = [],
							l = [];

						function u(e, t, n, r) {
							for (var i = r + 1, a = [], o = 0; o <= i; o++) {
								a[o] = [];
								for (var s = e.clone().lerp(n, o / i), l = t.clone().lerp(n,
										o / i), u = i - o, h = 0; h <= u; h++) a[o][h] =
									0 === h && o === i ? s : s.clone().lerp(l, h / u)
							}
							for (var d = 0; d < i; d++)
								for (var f = 0; f < 2 * (i - d) - 1; f++) {
									var p = Math.floor(f / 2);
									f % 2 == 0 ? (c(a[d][p + 1]), c(a[d + 1][p]), c(a[d][
										p])) : (c(a[d][p + 1]), c(a[d + 1][p + 1]), c(a[
										d + 1][p]))
								}
						}

						function c(e) {
							s.push(e.x, e.y, e.z)
						}

						function h(t, n) {
							var r = 3 * t;
							n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
						}

						function d(e, t, n, r) {
							r < 0 && 1 === e.x && (l[t] = e.x - 1), 0 === n.x && 0 === n
								.z && (l[t] = r / 2 / Math.PI + .5)
						}

						function f(e) {
							return Math.atan2(e.z, -e.x)
						}
						return function(e) {
								for (var t = new je, n = new je, i = new je, a = 0; a < r
									.length; a += 3) h(r[a + 0], t), h(r[a + 1], n), h(r[a +
									2], i), u(t, n, i, e)
							}(o),
							function(e) {
								for (var t = new je, n = 0; n < s.length; n += 3) t.x = s[
										n + 0], t.y = s[n + 1], t.z = s[n + 2], t
									.normalize().multiplyScalar(e), s[n + 0] = t.x, s[n +
									1] = t.y, s[n + 2] = t.z
							}(a),
							function() {
								for (var e, t = new je, n = 0; n < s.length; n += 3) {
									t.x = s[n + 0], t.y = s[n + 1], t.z = s[n + 2];
									var r = f(t) / 2 / Math.PI + .5,
										i = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e
											.z * e.z)) / Math.PI + .5);
									l.push(r, 1 - i)
								}(function() {
									for (var e = new je, t = new je, n = new je, r =
											new je, i = new Ie, a = new Ie, o = new Ie,
											u = 0, c = 0; u < s.length; u += 9, c +=
										6) {
										e.set(s[u + 0], s[u + 1], s[u + 2]), t.set(s[u +
												3], s[u + 4], s[u + 5]), n.set(s[u + 6],
												s[u + 7], s[u + 8]), i.set(l[c + 0], l[
												c + 1]), a.set(l[c + 2], l[c + 3]), o
											.set(l[c + 4], l[c + 5]), r.copy(e).add(t)
											.add(n).divideScalar(3);
										var h = f(r);
										d(i, c + 0, e, h), d(a, c + 2, t, h), d(o, c +
											4, n, h)
									}
								})(),
								function() {
									for (var e = 0; e < l.length; e += 6) {
										var t = l[e + 0],
											n = l[e + 2],
											r = l[e + 4],
											i = Math.max(t, n, r),
											a = Math.min(t, n, r);
										i > .9 && a < .1 && (t < .2 && (l[e + 0] += 1), n <
											.2 && (l[e + 2] += 1), r < .2 && (l[e +
												4] += 1))
									}
								}()
							}(), i.setAttribute("position", new Cn(s, 3)), i.setAttribute(
								"normal", new Cn(s.slice(), 3)), i.setAttribute("uv",
								new Cn(l, 2)), 0 === o ? i.computeVertexNormals() : i
							.normalizeNormals(), i
					}
					return n
				}(Vn),
				Ko = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						(0, g.default)(this, n);
						var a = (1 + Math.sqrt(5)) / 2,
							o = 1 / a;
						return (e = t.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1,
							1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -o, -
							a, 0, -o, a, 0, o, -a, 0, o, a, -o, -a, 0, -o, a, 0,
							o, -a, 0, o, a, 0, -a, 0, -o, a, 0, -o, -a, 0, o, a,
							0, o
						], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6,
							7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16,
							8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16,
							6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3,
							2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12,
							4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7,
							19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
							5, 1, 5, 9
						], r, i)).type = "DodecahedronGeometry", e.parameters = {
							radius: r,
							detail: i
						}, e
					}
					return n
				}(Qo),
				es = new je,
				ts = new je,
				ns = new je,
				rs = new un,
				is = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						if ((0, g.default)(this, n), (i = t.call(this)).type =
							"EdgesGeometry", i.parameters = {
								thresholdAngle: r
							}, r = void 0 !== r ? r : 1, !0 === e.isGeometry) return (0, v
							.default)(i, void console.error(
							"THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							));
						for (var a = Math.pow(10, 4), o = Math.cos(Me * r), s = e
							.getIndex(), l = e.getAttribute("position"), u = s ? s.count : l
								.count, c = [0, 0, 0], h = ["a", "b", "c"], d = new Array(
								3), f = {}, p = [], m = 0; m < u; m += 3) {
							s ? (c[0] = s.getX(m), c[1] = s.getX(m + 1), c[2] = s.getX(m +
								2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
							var y = rs.a,
								x = rs.b,
								_ = rs.c;
							if (y.fromBufferAttribute(l, c[0]), x.fromBufferAttribute(l, c[
									1]), _.fromBufferAttribute(l, c[2]), rs.getNormal(ns),
								d[0] = "".concat(Math.round(y.x * a), ",").concat(Math
									.round(y.y * a), ",").concat(Math.round(y.z * a)), d[
								1] = "".concat(Math.round(x.x * a), ",").concat(Math.round(x
									.y * a), ",").concat(Math.round(x.z * a)), d[2] = ""
								.concat(Math.round(_.x * a), ",").concat(Math.round(_.y *
									a), ",").concat(Math.round(_.z * a)), d[0] !== d[1] &&
								d[1] !== d[2] && d[2] !== d[0])
								for (var b = 0; b < 3; b++) {
									var w = (b + 1) % 3,
										M = d[b],
										S = d[w],
										T = rs[h[b]],
										E = rs[h[w]],
										A = "".concat(M, "_").concat(S),
										L = "".concat(S, "_").concat(M);
									L in f && f[L] ? (ns.dot(f[L].normal) <= o && (p.push(T
											.x, T.y, T.z), p.push(E.x, E.y, E.z)), f[
										L] = null) : A in f || (f[A] = {
										index0: c[b],
										index1: c[w],
										normal: ns.clone()
									})
								}
						}
						for (var k in f)
							if (f[k]) {
								var R = f[k],
									C = R.index0,
									P = R.index1;
								es.fromBufferAttribute(l, C), ts.fromBufferAttribute(l, P),
									p.push(es.x, es.y, es.z), p.push(ts.x, ts.y, ts.z)
							} return i.setAttribute("position", new Cn(p, 3)), (0, v
							.default)(i)
					}
					return n
				}(Vn);

			function as(e, t, n, r, i) {
				var a, o;
				if (i === function(e, t, n, r) {
						for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[
							a]) * (e[a + 1] + e[o + 1]), o = a;
						return i
					}(e, t, n, r) > 0)
					for (a = t; a < n; a += r) o = Es(a, e[a], e[a + 1], o);
				else
					for (a = n - r; a >= t; a -= r) o = Es(a, e[a], e[a + 1], o);
				return o && _s(o, o.next) && (As(o), o = o.next), o
			}

			function os(e, t) {
				if (!e) return e;
				t || (t = e);
				var n, r = e;
				do {
					if (n = !1, r.steiner || !_s(r, r.next) && 0 !== xs(r.prev, r, r.next))
						r = r.next;
					else {
						if (As(r), (r = t = r.prev) === r.next) break;
						n = !0
					}
				} while (n || r !== t);
				return t
			}

			function ss(e, t, n, r, i, a, o) {
				if (e) {
					!o && a && function(e, t, n, r) {
						var i = e;
						do {
							null === i.z && (i.z = vs(i.x, i.y, t, n, r)), i.prevZ = i
								.prev, i.nextZ = i.next, i = i.next
						} while (i !== e);
						i.prevZ.nextZ = null, i.prevZ = null,
							function(e) {
								var t, n, r, i, a, o, s, l, u = 1;
								do {
									for (n = e, e = null, a = null, o = 0; n;) {
										for (o++, r = n, s = 0, t = 0; t < u && (s++,
												r = r.nextZ); t++);
										for (l = u; s > 0 || l > 0 && r;) 0 !== s && (
												0 === l || !r || n.z <= r.z) ? (i = n,
												n = n.nextZ, s--) : (i = r, r = r.nextZ,
												l--), a ? a.nextZ = i : e = i, i.prevZ =
											a, a = i;
										n = r
									}
									a.nextZ = null, u *= 2
								} while (o > 1)
							}(i)
					}(e, r, i, a);
					for (var s, l, u = e; e.prev !== e.next;)
						if (s = e.prev, l = e.next, a ? us(e, r, i, a) : ls(e)) t.push(s.i /
								n), t.push(e.i / n), t.push(l.i / n), As(e), e = l.next, u =
							l.next;
						else if ((e = l) === u) {
						o ? 1 === o ? ss(e = cs(os(e), t, n), t, n, r, i, a, 2) : 2 === o &&
							hs(e, t, n, r, i, a) : ss(os(e), t, n, r, i, a, 1);
						break
					}
				}
			}

			function ls(e) {
				var t = e.prev,
					n = e,
					r = e.next;
				if (xs(t, n, r) >= 0) return !1;
				for (var i = e.next.next; i !== e.prev;) {
					if (gs(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && xs(i.prev, i, i
						.next) >= 0) return !1;
					i = i.next
				}
				return !0
			}

			function us(e, t, n, r) {
				var i = e.prev,
					a = e,
					o = e.next;
				if (xs(i, a, o) >= 0) return !1;
				for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, l =
						i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, u = i.x >
						a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, c = i.y > a.y ?
						i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, h = vs(s, l, t, n,
						r), d = vs(u, c, t, n, r), f = e.prevZ, p = e.nextZ; f && f.z >=
					h && p && p.z <= d;) {
					if (f !== e.prev && f !== e.next && gs(i.x, i.y, a.x, a.y, o.x, o.y, f
							.x, f.y) && xs(f.prev, f, f.next) >= 0) return !1;
					if (f = f.prevZ, p !== e.prev && p !== e.next && gs(i.x, i.y, a.x, a.y,
							o.x, o.y, p.x, p.y) && xs(p.prev, p, p.next) >= 0) return !1;
					p = p.nextZ
				}
				for (; f && f.z >= h;) {
					if (f !== e.prev && f !== e.next && gs(i.x, i.y, a.x, a.y, o.x, o.y, f
							.x, f.y) && xs(f.prev, f, f.next) >= 0) return !1;
					f = f.prevZ
				}
				for (; p && p.z <= d;) {
					if (p !== e.prev && p !== e.next && gs(i.x, i.y, a.x, a.y, o.x, o.y, p
							.x, p.y) && xs(p.prev, p, p.next) >= 0) return !1;
					p = p.nextZ
				}
				return !0
			}

			function cs(e, t, n) {
				var r = e;
				do {
					var i = r.prev,
						a = r.next.next;
					!_s(i, a) && bs(i, r, r.next, a) && Ss(i, a) && Ss(a, i) && (t.push(i
							.i / n), t.push(r.i / n), t.push(a.i / n), As(r), As(r
						.next), r = e = a), r = r.next
				} while (r !== e);
				return os(r)
			}

			function hs(e, t, n, r, i, a) {
				var o = e;
				do {
					for (var s = o.next.next; s !== o.prev;) {
						if (o.i !== s.i && ys(o, s)) {
							var l = Ts(o, s);
							return o = os(o, o.next), l = os(l, l.next), ss(o, t, n, r, i,
								a), void ss(l, t, n, r, i, a)
						}
						s = s.next
					}
					o = o.next
				} while (o !== e)
			}

			function ds(e, t) {
				return e.x - t.x
			}

			function fs(e, t) {
				if (t = function(e, t) {
						var n, r = t,
							i = e.x,
							a = e.y,
							o = -1 / 0;
						do {
							if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
								var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r
									.y);
								if (s <= i && s > o) {
									if (o = s, s === i) {
										if (a === r.y) return r;
										if (a === r.next.y) return r.next
									}
									n = r.x < r.next.x ? r : r.next
								}
							}
							r = r.next
						} while (r !== t);
						if (!n) return null;
						if (i === o) return n;
						var l, u = n,
							c = n.x,
							h = n.y,
							d = 1 / 0;
						r = n;
						do {
							i >= r.x && r.x >= c && i !== r.x && gs(a < h ? i : o, a, c, h,
									a < h ? o : i, a, r.x, r.y) && (l = Math.abs(a - r.y) /
									(i - r.x), Ss(r, e) && (l < d || l === d && (r.x > n
										.x || r.x === n.x && ps(n, r))) && (n = r, d = l)),
								r = r.next
						} while (r !== u);
						return n
					}(e, t)) {
					var n = Ts(t, e);
					os(t, t.next), os(n, n.next)
				}
			}

			function ps(e, t) {
				return xs(e.prev, e, t.prev) < 0 && xs(t.next, e, e.next) < 0
			}

			function vs(e, t, n, r, i) {
				return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e =
					16711935 & ((e = 32767 * (e - n) * i) | e <<
						8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t =
					858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 *
						(t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
			}

			function ms(e) {
				var t = e,
					n = e;
				do {
					(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
				} while (t !== e);
				return n
			}

			function gs(e, t, n, r, i, a, o, s) {
				return (i - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (
					n - o) * (t - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0
			}

			function ys(e, t) {
				return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
					var n = e;
					do {
						if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next
							.i !== t.i && bs(n, n.next, e, t)) return !0;
						n = n.next
					} while (n !== e);
					return !1
				}(e, t) && (Ss(e, t) && Ss(t, e) && function(e, t) {
						var n = e,
							r = !1,
							i = (e.x + t.x) / 2,
							a = (e.y + t.y) / 2;
						do {
							n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next
								.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (
								r = !r), n = n.next
						} while (n !== e);
						return r
					}(e, t) && (xs(e.prev, e, t.prev) || xs(e, t.prev, t)) || _s(e,
					t) && xs(e.prev, e, e.next) > 0 && xs(t.prev, t, t.next) > 0)
			}

			function xs(e, t, n) {
				return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
			}

			function _s(e, t) {
				return e.x === t.x && e.y === t.y
			}

			function bs(e, t, n, r) {
				var i = Ms(xs(e, t, n)),
					a = Ms(xs(e, t, r)),
					o = Ms(xs(n, r, e)),
					s = Ms(xs(n, r, t));
				return i !== a && o !== s || !(0 !== i || !ws(e, n, t)) || !(0 !== a || !ws(
					e, r, t)) || !(0 !== o || !ws(n, e, r)) || !(0 !== s || !ws(n, t,
					r))
			}

			function ws(e, t, n) {
				return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math
					.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
			}

			function Ms(e) {
				return e > 0 ? 1 : e < 0 ? -1 : 0
			}

			function Ss(e, t) {
				return xs(e.prev, e, e.next) < 0 ? xs(e, t, e.next) >= 0 && xs(e, e.prev,
					t) >= 0 : xs(e, t, e.prev) < 0 || xs(e, e.next, t) < 0
			}

			function Ts(e, t) {
				var n = new Ls(e.i, e.x, e.y),
					r = new Ls(t.i, t.x, t.y),
					i = e.next,
					a = t.prev;
				return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev =
					r, a.next = r, r.prev = a, r
			}

			function Es(e, t, n, r) {
				var i = new Ls(e, t, n);
				return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i
					.prev = i, i.next = i), i
			}

			function As(e) {
				e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e
					.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
			}

			function Ls(e, t, n) {
				this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this
					.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
			}
			var ks = function() {
				function e() {
					(0, g.default)(this, e)
				}
				return (0, y.default)(e, null, [{
					key: "area",
					value: function(e) {
						for (var t = e.length, n = 0, r = t - 1, i =
							0; i < t; r = i++) n += e[r].x * e[i].y - e[
							i].x * e[r].y;
						return .5 * n
					}
				}, {
					key: "isClockWise",
					value: function(t) {
						return e.area(t) < 0
					}
				}, {
					key: "triangulateShape",
					value: function(e, t) {
						var n = [],
							r = [],
							i = [];
						Rs(e), Cs(n, e);
						var a = e.length;
						t.forEach(Rs);
						for (var o = 0; o < t.length; o++) r.push(a),
							a += t[o].length, Cs(n, t[o]);
						for (var s = function(e, t, n) {
								n = n || 2;
								var r, i, a, o, s, l, u, c = t && t
									.length,
									h = c ? t[0] * n : e.length,
									d = as(e, 0, h, n, !0),
									f = [];
								if (!d || d.next === d.prev)
								return f;
								if (c && (d = function(e, t, n, r) {
										var i, a, o, s = [];
										for (i = 0, a = t
											.length; i < a; i++)
											(o = as(e, t[i] * r,
												i < a - 1 ?
												t[i + 1] *
												r : e
												.length, r,
												!1)) === o
											.next && (o
												.steiner = !0),
											s.push(ms(o));
										for (s.sort(ds), i =
											0; i < s.length; i++
											) fs(s[i], n), n =
											os(n, n.next);
										return n
									}(e, t, d, n)), e.length > 80 *
									n) {
									r = a = e[0], i = o = e[1];
									for (var p = n; p < h; p += n)(
											s = e[p]) < r && (r =
										s), (l = e[p + 1]) < i && (
											i = l), s > a && (a =
										s), l > o && (o = l);
									u = 0 !== (u = Math.max(a - r,
										o - i)) ? 1 / u : 0
								}
								return ss(d, f, n, r, i, u), f
							}(n, r), l = 0; l < s.length; l += 3) i
							.push(s.slice(l, l + 3));
						return i
					}
				}]), e
			}();

			function Rs(e) {
				var t = e.length;
				t > 2 && e[t - 1].equals(e[0]) && e.pop()
			}

			function Cs(e, t) {
				for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
			}
			var Ps = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						(0, g.default)(this, n), (i = t.call(this)).type =
							"ExtrudeGeometry", i.parameters = {
								shapes: e,
								options: r
							}, e = Array.isArray(e) ? e : [e];
						for (var a = (0, f.default)(i), o = [], s = [], l = 0, u = e
							.length; l < u; l++) c(e[l]);

						function c(e) {
							var t = [],
								n = void 0 !== r.curveSegments ? r.curveSegments : 12,
								i = void 0 !== r.steps ? r.steps : 1,
								l = void 0 !== r.depth ? r.depth : 100,
								u = void 0 === r.bevelEnabled || r.bevelEnabled,
								c = void 0 !== r.bevelThickness ? r.bevelThickness : 6,
								h = void 0 !== r.bevelSize ? r.bevelSize : c - 2,
								d = void 0 !== r.bevelOffset ? r.bevelOffset : 0,
								f = void 0 !== r.bevelSegments ? r.bevelSegments : 3,
								p = r.extrudePath,
								v = void 0 !== r.UVGenerator ? r.UVGenerator : Is;
							void 0 !== r.amount && (console.warn(
								"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
								), l = r.amount);
							var m, g, y, x, _, b = !1;
							p && (m = p.getSpacedPoints(i), b = !0, u = !1, g = p
								.computeFrenetFrames(i, !1), y = new je, x = new je, _ =
								new je), u || (f = 0, c = 0, h = 0, d = 0);
							var w = e.extractPoints(n),
								M = w.shape,
								S = w.holes;
							if (!ks.isClockWise(M)) {
								M = M.reverse();
								for (var T = 0, E = S.length; T < E; T++) {
									var A = S[T];
									ks.isClockWise(A) && (S[T] = A.reverse())
								}
							}
							for (var L = ks.triangulateShape(M, S), k = M, R = 0, C = S
									.length; R < C; R++) {
								var P = S[R];
								M = M.concat(P)
							}

							function I(e, t, n) {
								return t || console.error(
										"THREE.ExtrudeGeometry: vec does not exist"), t
									.clone().multiplyScalar(n).add(e)
							}
							var D = M.length,
								N = L.length;

							function O(e, t, n) {
								var r, i, a, o = e.x - t.x,
									s = e.y - t.y,
									l = n.x - e.x,
									u = n.y - e.y,
									c = o * o + s * s,
									h = o * u - s * l;
								if (Math.abs(h) > Number.EPSILON) {
									var d = Math.sqrt(c),
										f = Math.sqrt(l * l + u * u),
										p = t.x - s / d,
										v = t.y + o / d,
										m = ((n.x - u / f - p) * u - (n.y + l / f - v) *
										l) / (o * u - s * l),
										g = (r = p + o * m - e.x) * r + (i = v + s * m - e
											.y) * i;
									if (g <= 2) return new Ie(r, i);
									a = Math.sqrt(g / 2)
								} else {
									var y = !1;
									o > Number.EPSILON ? l > Number.EPSILON && (y = !0) :
										o < -Number.EPSILON ? l < -Number.EPSILON && (y = !
											0) : Math.sign(s) === Math.sign(u) && (y = !0),
										y ? (r = -s, i = o, a = Math.sqrt(c)) : (r = o, i =
											s, a = Math.sqrt(c / 2))
								}
								return new Ie(r / a, i / a)
							}
							for (var B = [], z = 0, F = k.length, H = F - 1, U = z + 1; z <
								F; z++, H++, U++) H === F && (H = 0), U === F && (U = 0), B[
								z] = O(k[z], k[H], k[U]);
							for (var G, V = [], W = B.concat(), j = 0, q = S.length; j <
								q; j++) {
								var X = S[j];
								G = [];
								for (var Y = 0, $ = X.length, Z = $ - 1, J = Y + 1; Y <
									$; Y++, Z++, J++) Z === $ && (Z = 0), J === $ && (J =
									0), G[Y] = O(X[Y], X[Z], X[J]);
								V.push(G), W = W.concat(G)
							}
							for (var Q = 0; Q < f; Q++) {
								for (var K = Q / f, ee = c * Math.cos(K * Math.PI / 2), te =
										h * Math.sin(K * Math.PI / 2) + d, ne = 0, re = k
										.length; ne < re; ne++) {
									var ie = I(k[ne], B[ne], te);
									Ce(ie.x, ie.y, -ee)
								}
								for (var ae = 0, oe = S.length; ae < oe; ae++) {
									var se = S[ae];
									G = V[ae];
									for (var le = 0, ue = se.length; le < ue; le++) {
										var ce = I(se[le], G[le], te);
										Ce(ce.x, ce.y, -ee)
									}
								}
							}
							for (var he = h + d, de = 0; de < D; de++) {
								var fe = u ? I(M[de], W[de], he) : M[de];
								b ? (x.copy(g.normals[0]).multiplyScalar(fe.x), y.copy(g
									.binormals[0]).multiplyScalar(fe.y), _.copy(m[
									0]).add(x).add(y), Ce(_.x, _.y, _.z)) : Ce(fe.x, fe
									.y, 0)
							}
							for (var pe = 1; pe <= i; pe++)
								for (var ve = 0; ve < D; ve++) {
									var me = u ? I(M[ve], W[ve], he) : M[ve];
									b ? (x.copy(g.normals[pe]).multiplyScalar(me.x), y.copy(
												g.binormals[pe]).multiplyScalar(me.y), _
											.copy(m[pe]).add(x).add(y), Ce(_.x, _.y, _.z)) :
										Ce(me.x, me.y, l / i * pe)
								}
							for (var ge = f - 1; ge >= 0; ge--) {
								for (var ye = ge / f, xe = c * Math.cos(ye * Math.PI / 2),
										_e = h * Math.sin(ye * Math.PI / 2) + d, be = 0,
										we = k.length; be < we; be++) {
									var Me = I(k[be], B[be], _e);
									Ce(Me.x, Me.y, l + xe)
								}
								for (var Se = 0, Te = S.length; Se < Te; Se++) {
									var Ee = S[Se];
									G = V[Se];
									for (var Ae = 0, Le = Ee.length; Ae < Le; Ae++) {
										var ke = I(Ee[Ae], G[Ae], _e);
										b ? Ce(ke.x, ke.y + m[i - 1].y, m[i - 1].x + xe) :
											Ce(ke.x, ke.y, l + xe)
									}
								}
							}

							function Re(e, t) {
								for (var n = e.length; --n >= 0;) {
									var r = n,
										a = n - 1;
									a < 0 && (a = e.length - 1);
									for (var o = 0, s = i + 2 * f; o < s; o++) {
										var l = D * o,
											u = D * (o + 1);
										De(t + r + l, t + a + l, t + a + u, t + r + u)
									}
								}
							}

							function Ce(e, n, r) {
								t.push(e), t.push(n), t.push(r)
							}

							function Pe(e, t, n) {
								Ne(e), Ne(t), Ne(n);
								var r = o.length / 3,
									i = v.generateTopUV(a, o, r - 3, r - 2, r - 1);
								Oe(i[0]), Oe(i[1]), Oe(i[2])
							}

							function De(e, t, n, r) {
								Ne(e), Ne(t), Ne(r), Ne(t), Ne(n), Ne(r);
								var i = o.length / 3,
									s = v.generateSideWallUV(a, o, i - 6, i - 3, i - 2, i -
										1);
								Oe(s[0]), Oe(s[1]), Oe(s[3]), Oe(s[1]), Oe(s[2]), Oe(s[3])
							}

							function Ne(e) {
								o.push(t[3 * e + 0]), o.push(t[3 * e + 1]), o.push(t[3 * e +
									2])
							}

							function Oe(e) {
								s.push(e.x), s.push(e.y)
							}! function() {
								var e = o.length / 3;
								if (u) {
									for (var t = 0, n = D * t, r = 0; r < N; r++) {
										var s = L[r];
										Pe(s[2] + n, s[1] + n, s[0] + n)
									}
									n = D * (t = i + 2 * f);
									for (var l = 0; l < N; l++) {
										var c = L[l];
										Pe(c[0] + n, c[1] + n, c[2] + n)
									}
								} else {
									for (var h = 0; h < N; h++) {
										var d = L[h];
										Pe(d[2], d[1], d[0])
									}
									for (var p = 0; p < N; p++) {
										var v = L[p];
										Pe(v[0] + D * i, v[1] + D * i, v[2] + D * i)
									}
								}
								a.addGroup(e, o.length / 3 - e, 0)
							}(),
							function() {
								var e = o.length / 3,
									t = 0;
								Re(k, t), t += k.length;
								for (var n = 0, r = S.length; n < r; n++) {
									var i = S[n];
									Re(i, t), t += i.length
								}
								a.addGroup(e, o.length / 3 - e, 1)
							}()
						}
						return i.setAttribute("position", new Cn(o, 3)), i.setAttribute(
							"uv", new Cn(s, 2)), i.computeVertexNormals(), i
					}
					return (0, y.default)(n, [{
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return function(e, t, n) {
								if (n.shapes = [], Array.isArray(e))
									for (var r = 0, i = e.length; r <
										i; r++) {
										var a = e[r];
										n.shapes.push(a.uuid)
									} else n.shapes.push(e.uuid);
								return void 0 !== t.extrudePath && (n
									.options.extrudePath = t
									.extrudePath.toJSON()), n
							}(this.parameters.shapes, this.parameters
								.options, e)
						}
					}]), n
				}(Vn),
				Is = {
					generateTopUV: function(e, t, n, r, i) {
						var a = t[3 * n],
							o = t[3 * n + 1],
							s = t[3 * r],
							l = t[3 * r + 1],
							u = t[3 * i],
							c = t[3 * i + 1];
						return [new Ie(a, o), new Ie(s, l), new Ie(u, c)]
					},
					generateSideWallUV: function(e, t, n, r, i, a) {
						var o = t[3 * n],
							s = t[3 * n + 1],
							l = t[3 * n + 2],
							u = t[3 * r],
							c = t[3 * r + 1],
							h = t[3 * r + 2],
							d = t[3 * i],
							f = t[3 * i + 1],
							p = t[3 * i + 2],
							v = t[3 * a],
							m = t[3 * a + 1],
							g = t[3 * a + 2];
						return Math.abs(s - c) < Math.abs(o - u) ? [new Ie(o, 1 - l),
							new Ie(u, 1 - h), new Ie(d, 1 - p), new Ie(v, 1 - g)
						] : [new Ie(s, 1 - l), new Ie(c, 1 - h), new Ie(f, 1 - p),
							new Ie(m, 1 - g)
						]
					}
				},
				Ds = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						(0, g.default)(this, n);
						var a = (1 + Math.sqrt(5)) / 2;
						return (e = t.call(this, [-1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, 0, 0,
							-1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, a, 0, -1, a, 0,
							1, -a, 0, -1, -a, 0, 1
						], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1,
							5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9,
							4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2,
							4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
						], r, i)).type = "IcosahedronGeometry", e.parameters = {
							radius: r,
							detail: i
						}, e
					}
					return n
				}(Qo),
				Ns = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 12,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 2 * Math.PI;
						(0, g.default)(this, n), (r = t.call(this)).type = "LatheGeometry",
							r.parameters = {
								points: e,
								segments: i,
								phiStart: a,
								phiLength: o
							}, i = Math.floor(i), o = Ee(o, 0, 2 * Math.PI);
						for (var s = [], l = [], u = [], c = 1 / i, h = new je, d = new Ie,
								f = 0; f <= i; f++)
							for (var p = a + f * c * o, v = Math.sin(p), m = Math.cos(p),
									y = 0; y <= e.length - 1; y++) h.x = e[y].x * v, h.y =
								e[y].y, h.z = e[y].x * m, l.push(h.x, h.y, h.z), d.x = f /
								i, d.y = y / (e.length - 1), u.push(d.x, d.y);
						for (var x = 0; x < i; x++)
							for (var _ = 0; _ < e.length - 1; _++) {
								var b = _ + x * e.length,
									w = b,
									M = b + e.length,
									S = b + e.length + 1,
									T = b + 1;
								s.push(w, M, T), s.push(M, S, T)
							}
						if (r.setIndex(s), r.setAttribute("position", new Cn(l, 3)), r
							.setAttribute("uv", new Cn(u, 2)), r.computeVertexNormals(),
							o === 2 * Math.PI)
							for (var E = r.attributes.normal.array, A = new je, L = new je,
									k = new je, R = i * e.length * 3, C = 0, P = 0; C < e
								.length; C++, P += 3) A.x = E[P + 0], A.y = E[P + 1], A.z =
								E[P + 2], L.x = E[R + P + 0], L.y = E[R + P + 1], L.z = E[
									R + P + 2], k.addVectors(A, L).normalize(), E[P + 0] =
								E[R + P + 0] = k.x, E[P + 1] = E[R + P + 1] = k.y, E[P +
								2] = E[R + P + 2] = k.z;
						return r
					}
					return n
				}(Vn),
				Os = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						return (0, g.default)(this, n), (e = t.call(this, [1, 0, 0, -1, 0,
							0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
						], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5,
							3, 1, 3, 4, 1, 4, 2
						], r, i)).type = "OctahedronGeometry", e.parameters = {
							radius: r,
							detail: i
						}, e
					}
					return n
				}(Qo),
				Bs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						(0, g.default)(this, n), (a = t.call(this)).type =
							"ParametricGeometry", a.parameters = {
								func: e,
								slices: r,
								stacks: i
							};
						var o = [],
							s = [],
							l = [],
							u = [],
							c = 1e-5,
							h = new je,
							d = new je,
							f = new je,
							p = new je,
							v = new je;
						e.length < 3 && console.error(
							"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
							);
						for (var m = r + 1, y = 0; y <= i; y++)
							for (var x = y / i, _ = 0; _ <= r; _++) {
								var b = _ / r;
								e(b, x, d), s.push(d.x, d.y, d.z), b - c >= 0 ? (e(b - c, x,
									f), p.subVectors(d, f)) : (e(b + c, x, f), p
									.subVectors(f, d)), x - c >= 0 ? (e(b, x - c, f), v
									.subVectors(d, f)) : (e(b, x + c, f), v.subVectors(
									f, d)), h.crossVectors(p, v).normalize(), l.push(h
									.x, h.y, h.z), u.push(b, x)
							}
						for (var w = 0; w < i; w++)
							for (var M = 0; M < r; M++) {
								var S = w * m + M,
									T = w * m + M + 1,
									E = (w + 1) * m + M + 1,
									A = (w + 1) * m + M;
								o.push(S, T, A), o.push(T, E, A)
							}
						return a.setIndex(o), a.setAttribute("position", new Cn(s, 3)), a
							.setAttribute("normal", new Cn(l, 3)), a.setAttribute("uv",
								new Cn(u, 2)), a
					}
					return n
				}(Vn),
				zs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : .5,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 1,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 8,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 0,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 2 * Math.PI;
						(0, g.default)(this, n), (e = t.call(this)).type = "RingGeometry", e
							.parameters = {
								innerRadius: r,
								outerRadius: i,
								thetaSegments: a,
								phiSegments: o,
								thetaStart: s,
								thetaLength: l
							}, a = Math.max(3, a);
						for (var u = [], c = [], h = [], d = [], f = r, p = (i - r) / (o =
								Math.max(1, o)), v = new je, m = new Ie, y = 0; y <=
							o; y++) {
							for (var x = 0; x <= a; x++) {
								var _ = s + x / a * l;
								v.x = f * Math.cos(_), v.y = f * Math.sin(_), c.push(v.x, v
										.y, v.z), h.push(0, 0, 1), m.x = (v.x / i + 1) / 2,
									m.y = (v.y / i + 1) / 2, d.push(m.x, m.y)
							}
							f += p
						}
						for (var b = 0; b < o; b++)
							for (var w = b * (a + 1), M = 0; M < a; M++) {
								var S = M + w,
									T = S,
									E = S + a + 1,
									A = S + a + 2,
									L = S + 1;
								u.push(T, E, L), u.push(E, A, L)
							}
						return e.setIndex(u), e.setAttribute("position", new Cn(c, 3)), e
							.setAttribute("normal", new Cn(h, 3)), e.setAttribute("uv",
								new Cn(d, 2)), e
					}
					return n
				}(Vn),
				Fs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 12;
						(0, g.default)(this, n), (r = t.call(this)).type = "ShapeGeometry",
							r.parameters = {
								shapes: e,
								curveSegments: i
							};
						var a = [],
							o = [],
							s = [],
							l = [],
							u = 0,
							c = 0;
						if (!1 === Array.isArray(e)) d(e);
						else
							for (var h = 0; h < e.length; h++) d(e[h]), r.addGroup(u, c, h),
								u += c, c = 0;

						function d(e) {
							var t = o.length / 3,
								n = e.extractPoints(i),
								r = n.shape,
								u = n.holes;
							!1 === ks.isClockWise(r) && (r = r.reverse());
							for (var h = 0, d = u.length; h < d; h++) {
								var f = u[h];
								!0 === ks.isClockWise(f) && (u[h] = f.reverse())
							}
							for (var p = ks.triangulateShape(r, u), v = 0, m = u.length; v <
								m; v++) {
								var g = u[v];
								r = r.concat(g)
							}
							for (var y = 0, x = r.length; y < x; y++) {
								var _ = r[y];
								o.push(_.x, _.y, 0), s.push(0, 0, 1), l.push(_.x, _.y)
							}
							for (var b = 0, w = p.length; b < w; b++) {
								var M = p[b],
									S = M[0] + t,
									T = M[1] + t,
									E = M[2] + t;
								a.push(S, T, E), c += 3
							}
						}
						return r.setIndex(a), r.setAttribute("position", new Cn(o, 3)), r
							.setAttribute("normal", new Cn(s, 3)), r.setAttribute("uv",
								new Cn(l, 2)), r
					}
					return (0, y.default)(n, [{
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return function(e, t) {
								if (t.shapes = [], Array.isArray(e))
									for (var n = 0, r = e.length; n <
										r; n++) {
										var i = e[n];
										t.shapes.push(i.uuid)
									} else t.shapes.push(e.uuid);
								return t
							}(this.parameters.shapes, e)
						}
					}]), n
				}(Vn),
				Hs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 8,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 6,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 0,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 2 * Math.PI,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 0,
							u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[
								6] : Math.PI;
						(0, g.default)(this, n), (e = t.call(this)).type = "SphereGeometry",
							e.parameters = {
								radius: r,
								widthSegments: i,
								heightSegments: a,
								phiStart: o,
								phiLength: s,
								thetaStart: l,
								thetaLength: u
							}, i = Math.max(3, Math.floor(i)), a = Math.max(2, Math.floor(
								a));
						for (var c = Math.min(l + u, Math.PI), h = 0, d = [], f = new je,
								p = new je, v = [], m = [], y = [], x = [], _ = 0; _ <=
							a; _++) {
							var b = [],
								w = _ / a,
								M = 0;
							0 == _ && 0 == l ? M = .5 / i : _ == a && c == Math.PI && (M = -
								.5 / i);
							for (var S = 0; S <= i; S++) {
								var T = S / i;
								f.x = -r * Math.cos(o + T * s) * Math.sin(l + w * u), f.y =
									r * Math.cos(l + w * u), f.z = r * Math.sin(o + T * s) *
									Math.sin(l + w * u), m.push(f.x, f.y, f.z), p.copy(f)
									.normalize(), y.push(p.x, p.y, p.z), x.push(T + M, 1 -
										w), b.push(h++)
							}
							d.push(b)
						}
						for (var E = 0; E < a; E++)
							for (var A = 0; A < i; A++) {
								var L = d[E][A + 1],
									k = d[E][A],
									R = d[E + 1][A],
									C = d[E + 1][A + 1];
								(0 !== E || l > 0) && v.push(L, k, C), (E !== a - 1 || c <
									Math.PI) && v.push(k, R, C)
							}
						return e.setIndex(v), e.setAttribute("position", new Cn(m, 3)), e
							.setAttribute("normal", new Cn(y, 3)), e.setAttribute("uv",
								new Cn(x, 2)), e
					}
					return n
				}(Vn),
				Us = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0;
						return (0, g.default)(this, n), (e = t.call(this, [1, 1, 1, -1, -1,
								1, -1, 1, -1, 1, -1, -1
							], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], r, i)).type =
							"TetrahedronGeometry", e.parameters = {
								radius: r,
								detail: i
							}, e
					}
					return n
				}(Qo),
				Gs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : {};
						(0, g.default)(this, n);
						var a = i.font;
						if (!a || !a.isFont) return (0, v.default)(r, (console.error(
							"THREE.TextGeometry: font parameter is not an instance of THREE.Font."
							), new Vn));
						var o = a.generateShapes(e, i.size);
						return i.depth = void 0 !== i.height ? i.height : 50, void 0 === i
							.bevelThickness && (i.bevelThickness = 10), void 0 === i
							.bevelSize && (i.bevelSize = 8), void 0 === i.bevelEnabled && (i
								.bevelEnabled = !1), (r = t.call(this, o, i)).type =
							"TextGeometry", r
					}
					return n
				}(Ps),
				Vs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : .4,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 8,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 6,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 2 * Math.PI;
						(0, g.default)(this, n), (e = t.call(this)).type = "TorusGeometry",
							e.parameters = {
								radius: r,
								tube: i,
								radialSegments: a,
								tubularSegments: o,
								arc: s
							}, a = Math.floor(a), o = Math.floor(o);
						for (var l = [], u = [], c = [], h = [], d = new je, f = new je, p =
								new je, v = 0; v <= a; v++)
							for (var m = 0; m <= o; m++) {
								var y = m / o * s,
									x = v / a * Math.PI * 2;
								f.x = (r + i * Math.cos(x)) * Math.cos(y), f.y = (r + i *
										Math.cos(x)) * Math.sin(y), f.z = i * Math.sin(x), u
									.push(f.x, f.y, f.z), d.x = r * Math.cos(y), d.y = r *
									Math.sin(y), p.subVectors(f, d).normalize(), c.push(p.x,
										p.y, p.z), h.push(m / o), h.push(v / a)
							}
						for (var _ = 1; _ <= a; _++)
							for (var b = 1; b <= o; b++) {
								var w = (o + 1) * _ + b - 1,
									M = (o + 1) * (_ - 1) + b - 1,
									S = (o + 1) * (_ - 1) + b,
									T = (o + 1) * _ + b;
								l.push(w, M, T), l.push(M, S, T)
							}
						return e.setIndex(l), e.setAttribute("position", new Cn(u, 3)), e
							.setAttribute("normal", new Cn(c, 3)), e.setAttribute("uv",
								new Cn(h, 2)), e
					}
					return n
				}(Vn),
				Ws = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : .4,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 64,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 8,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 2,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 3;
						(0, g.default)(this, n), (e = t.call(this)).type =
							"TorusKnotGeometry", e.parameters = {
								radius: r,
								tube: i,
								tubularSegments: a,
								radialSegments: o,
								p: s,
								q: l
							}, a = Math.floor(a), o = Math.floor(o);
						for (var u = [], c = [], h = [], d = [], f = new je, p = new je, v =
								new je, m = new je, y = new je, x = new je, _ = new je, b =
								0; b <= a; ++b) {
							var w = b / a * s * Math.PI * 2;
							I(w, s, l, r, v), I(w + .01, s, l, r, m), x.subVectors(m, v), _
								.addVectors(m, v), y.crossVectors(x, _), _.crossVectors(y,
									x), y.normalize(), _.normalize();
							for (var M = 0; M <= o; ++M) {
								var S = M / o * Math.PI * 2,
									T = -i * Math.cos(S),
									E = i * Math.sin(S);
								f.x = v.x + (T * _.x + E * y.x), f.y = v.y + (T * _.y + E *
									y.y), f.z = v.z + (T * _.z + E * y.z), c.push(f.x, f
									.y, f.z), p.subVectors(f, v).normalize(), h.push(p
									.x, p.y, p.z), d.push(b / a), d.push(M / o)
							}
						}
						for (var A = 1; A <= a; A++)
							for (var L = 1; L <= o; L++) {
								var k = (o + 1) * (A - 1) + (L - 1),
									R = (o + 1) * A + (L - 1),
									C = (o + 1) * A + L,
									P = (o + 1) * (A - 1) + L;
								u.push(k, R, P), u.push(R, C, P)
							}

						function I(e, t, n, r, i) {
							var a = Math.cos(e),
								o = Math.sin(e),
								s = n / t * e,
								l = Math.cos(s);
							i.x = r * (2 + l) * .5 * a, i.y = r * (2 + l) * o * .5, i.z =
								r * Math.sin(s) * .5
						}
						return e.setIndex(u), e.setAttribute("position", new Cn(c, 3)), e
							.setAttribute("normal", new Cn(h, 3)), e.setAttribute("uv",
								new Cn(d, 2)), e
					}
					return n
				}(Vn),
				js = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 64,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 8,
							s = arguments.length > 4 && void 0 !== arguments[4] &&
							arguments[4];
						(0, g.default)(this, n), (r = t.call(this)).type = "TubeGeometry", r
							.parameters = {
								path: e,
								tubularSegments: i,
								radius: a,
								radialSegments: o,
								closed: s
							};
						var l = e.computeFrenetFrames(i, s);
						r.tangents = l.tangents, r.normals = l.normals, r.binormals = l
							.binormals;
						var u = new je,
							c = new je,
							h = new Ie,
							d = new je,
							f = [],
							p = [],
							v = [],
							m = [];

						function y(t) {
							d = e.getPointAt(t / i, d);
							for (var n = l.normals[t], r = l.binormals[t], s = 0; s <=
								o; s++) {
								var h = s / o * Math.PI * 2,
									v = Math.sin(h),
									m = -Math.cos(h);
								c.x = m * n.x + v * r.x, c.y = m * n.y + v * r.y, c.z = m *
									n.z + v * r.z, c.normalize(), p.push(c.x, c.y, c.z), u
									.x = d.x + a * c.x, u.y = d.y + a * c.y, u.z = d.z + a *
									c.z, f.push(u.x, u.y, u.z)
							}
						}
						return function() {
								for (var e = 0; e < i; e++) y(e);
								y(!1 === s ? i : 0),
									function() {
										for (var e = 0; e <= i; e++)
											for (var t = 0; t <= o; t++) h.x = e / i, h.y =
												t / o, v.push(h.x, h.y)
									}(),
									function() {
										for (var e = 1; e <= i; e++)
											for (var t = 1; t <= o; t++) {
												var n = (o + 1) * (e - 1) + (t - 1),
													r = (o + 1) * e + (t - 1),
													a = (o + 1) * e + t,
													s = (o + 1) * (e - 1) + t;
												m.push(n, r, s), m.push(r, a, s)
											}
									}()
							}(), r.setIndex(m), r.setAttribute("position", new Cn(f, 3)), r
							.setAttribute("normal", new Cn(p, 3)), r.setAttribute("uv",
								new Cn(v, 2)), r
					}
					return (0, y.default)(n, [{
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return e.path = this.parameters.path.toJSON(), e
						}
					}]), n
				}(Vn),
				qs = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						if ((0, g.default)(this, n), (r = t.call(this)).type =
							"WireframeGeometry", !0 === e.isGeometry) return (0, v.default)(
							r, void console.error(
								"THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
								));
						var i = [],
							a = [0, 0],
							o = {},
							s = new je;
						if (null !== e.index) {
							var l = e.attributes.position,
								u = e.index,
								c = e.groups;
							0 === c.length && (c = [{
								start: 0,
								count: u.count,
								materialIndex: 0
							}]);
							for (var h = 0, d = c.length; h < d; ++h)
								for (var f = c[h], p = f.start, m = p, y = p + f.count; m <
									y; m += 3)
									for (var x = 0; x < 3; x++) {
										var _ = u.getX(m + x),
											b = u.getX(m + (x + 1) % 3);
										a[0] = Math.min(_, b), a[1] = Math.max(_, b);
										var w = a[0] + "," + a[1];
										void 0 === o[w] && (o[w] = {
											index1: a[0],
											index2: a[1]
										})
									}
							for (var M in o) {
								var S = o[M];
								s.fromBufferAttribute(l, S.index1), i.push(s.x, s.y, s.z), s
									.fromBufferAttribute(l, S.index2), i.push(s.x, s.y, s.z)
							}
						} else
							for (var T = e.attributes.position, E = 0, A = T.count / 3; E <
								A; E++)
								for (var L = 0; L < 3; L++) {
									var k = 3 * E + L;
									s.fromBufferAttribute(T, k), i.push(s.x, s.y, s.z);
									var R = 3 * E + (L + 1) % 3;
									s.fromBufferAttribute(T, R), i.push(s.x, s.y, s.z)
								}
						return r.setAttribute("position", new Cn(i, 3)), (0, v.default)(r)
					}
					return n
				}(Vn),
				Xs = Object.freeze({
					__proto__: null,
					BoxGeometry: ur,
					BoxBufferGeometry: ur,
					CircleGeometry: $o,
					CircleBufferGeometry: $o,
					ConeGeometry: Jo,
					ConeBufferGeometry: Jo,
					CylinderGeometry: Zo,
					CylinderBufferGeometry: Zo,
					DodecahedronGeometry: Ko,
					DodecahedronBufferGeometry: Ko,
					EdgesGeometry: is,
					ExtrudeGeometry: Ps,
					ExtrudeBufferGeometry: Ps,
					IcosahedronGeometry: Ds,
					IcosahedronBufferGeometry: Ds,
					LatheGeometry: Ns,
					LatheBufferGeometry: Ns,
					OctahedronGeometry: Os,
					OctahedronBufferGeometry: Os,
					ParametricGeometry: Bs,
					ParametricBufferGeometry: Bs,
					PlaneGeometry: Tr,
					PlaneBufferGeometry: Tr,
					PolyhedronGeometry: Qo,
					PolyhedronBufferGeometry: Qo,
					RingGeometry: zs,
					RingBufferGeometry: zs,
					ShapeGeometry: Fs,
					ShapeBufferGeometry: Fs,
					SphereGeometry: Hs,
					SphereBufferGeometry: Hs,
					TetrahedronGeometry: Us,
					TetrahedronBufferGeometry: Us,
					TextGeometry: Gs,
					TextBufferGeometry: Gs,
					TorusGeometry: Vs,
					TorusBufferGeometry: Vs,
					TorusKnotGeometry: Ws,
					TorusKnotBufferGeometry: Ws,
					TubeGeometry: js,
					TubeBufferGeometry: js,
					WireframeGeometry: qs
				}),
				Ys = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this)).type =
							"ShadowMaterial", r.color = new yn(0), r.transparent = !0, r
							.setValues(e), r
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.color.copy(e.color), this
						}
					}]), n
				}(hn);
			Ys.prototype.isShadowMaterial = !0;
			var $s = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this, e)).type =
						"RawShaderMaterial", r
				}
				return n
			}(fr);
			$s.prototype.isRawShaderMaterial = !0;
			var Zs = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).defines = {
							STANDARD: ""
						}, r.type = "MeshStandardMaterial", r.color = new yn(16777215),
						r.roughness = 1, r.metalness = 0, r.map = null, r.lightMap =
						null, r.lightMapIntensity = 1, r.aoMap = null, r
						.aoMapIntensity = 1, r.emissive = new yn(0), r
						.emissiveIntensity = 1, r.emissiveMap = null, r.bumpMap = null,
						r.bumpScale = 1, r.normalMap = null, r.normalMapType = 0, r
						.normalScale = new Ie(1, 1), r.displacementMap = null, r
						.displacementScale = 1, r.displacementBias = 0, r.roughnessMap =
						null, r.metalnessMap = null, r.alphaMap = null, r.envMap = null,
						r.envMapIntensity = 1, r.refractionRatio = .98, r.wireframe = !
						1, r.wireframeLinewidth = 1, r.wireframeLinecap = "round", r
						.wireframeLinejoin = "round", r.morphTargets = !1, r
						.morphNormals = !1, r.flatShading = !1, r.vertexTangents = !1, r
						.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.defines = {
								STANDARD: ""
							}, this.color.copy(e.color), this
							.roughness = e.roughness, this.metalness = e
							.metalness, this.map = e.map, this
							.lightMap = e.lightMap, this
							.lightMapIntensity = e.lightMapIntensity,
							this.aoMap = e.aoMap, this.aoMapIntensity =
							e.aoMapIntensity, this.emissive.copy(e
								.emissive), this.emissiveMap = e
							.emissiveMap, this.emissiveIntensity = e
							.emissiveIntensity, this.bumpMap = e
							.bumpMap, this.bumpScale = e.bumpScale, this
							.normalMap = e.normalMap, this
							.normalMapType = e.normalMapType, this
							.normalScale.copy(e.normalScale), this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this.roughnessMap = e.roughnessMap, this
							.metalnessMap = e.metalnessMap, this
							.alphaMap = e.alphaMap, this.envMap = e
							.envMap, this.envMapIntensity = e
							.envMapIntensity, this.refractionRatio = e
							.refractionRatio, this.wireframe = e
							.wireframe, this.wireframeLinewidth = e
							.wireframeLinewidth, this.wireframeLinecap =
							e.wireframeLinecap, this.wireframeLinejoin =
							e.wireframeLinejoin, this.morphTargets = e
							.morphTargets, this.morphNormals = e
							.morphNormals, this.flatShading = e
							.flatShading, this.vertexTangents = e
							.vertexTangents, this
					}
				}]), n
			}(hn);
			Zs.prototype.isMeshStandardMaterial = !0;
			var Js = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).defines = {
							STANDARD: "",
							PHYSICAL: ""
						}, r.type = "MeshPhysicalMaterial", r.clearcoat = 0, r
						.clearcoatMap = null, r.clearcoatRoughness = 0, r
						.clearcoatRoughnessMap = null, r.clearcoatNormalScale = new Ie(
							1, 1), r.clearcoatNormalMap = null, r.reflectivity = .5,
						Object.defineProperty((0, f.default)(r), "ior", {
							get: function() {
								return (1 + .4 * this.reflectivity) / (1 - .4 *
									this.reflectivity)
							},
							set: function(e) {
								this.reflectivity = Ee(2.5 * (e - 1) / (e + 1),
									0, 1)
							}
						}), r.sheen = null, r.transmission = 0, r.transmissionMap =
						null, r.thickness = .01, r.thicknessMap = null, r
						.attenuationDistance = 0, r.attenuationColor = new yn(1, 1, 1),
						r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.defines = {
								STANDARD: "",
								PHYSICAL: ""
							}, this.clearcoat = e.clearcoat, this
							.clearcoatMap = e.clearcoatMap, this
							.clearcoatRoughness = e.clearcoatRoughness,
							this.clearcoatRoughnessMap = e
							.clearcoatRoughnessMap, this
							.clearcoatNormalMap = e.clearcoatNormalMap,
							this.clearcoatNormalScale.copy(e
								.clearcoatNormalScale), this
							.reflectivity = e.reflectivity, e.sheen ?
							this.sheen = (this.sheen || new yn).copy(e
								.sheen) : this.sheen = null, this
							.transmission = e.transmission, this
							.transmissionMap = e.transmissionMap, this
							.thickness = e.thickness, this
							.thicknessMap = e.thicknessMap, this
							.attenuationDistance = e
							.attenuationDistance, this.attenuationColor
							.copy(e.attenuationColor), this
					}
				}]), n
			}(Zs);
			Js.prototype.isMeshPhysicalMaterial = !0;
			var Qs = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshPhongMaterial", r.color = new yn(16777215), r.specular =
						new yn(1118481), r.shininess = 30, r.map = null, r.lightMap =
						null, r.lightMapIntensity = 1, r.aoMap = null, r
						.aoMapIntensity = 1, r.emissive = new yn(0), r
						.emissiveIntensity = 1, r.emissiveMap = null, r.bumpMap = null,
						r.bumpScale = 1, r.normalMap = null, r.normalMapType = 0, r
						.normalScale = new Ie(1, 1), r.displacementMap = null, r
						.displacementScale = 1, r.displacementBias = 0, r.specularMap =
						null, r.alphaMap = null, r.envMap = null, r.combine = 0, r
						.reflectivity = 1, r.refractionRatio = .98, r.wireframe = !1, r
						.wireframeLinewidth = 1, r.wireframeLinecap = "round", r
						.wireframeLinejoin = "round", r.morphTargets = !1, r
						.morphNormals = !1, r.flatShading = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.specular
							.copy(e.specular), this.shininess = e
							.shininess, this.map = e.map, this
							.lightMap = e.lightMap, this
							.lightMapIntensity = e.lightMapIntensity,
							this.aoMap = e.aoMap, this.aoMapIntensity =
							e.aoMapIntensity, this.emissive.copy(e
								.emissive), this.emissiveMap = e
							.emissiveMap, this.emissiveIntensity = e
							.emissiveIntensity, this.bumpMap = e
							.bumpMap, this.bumpScale = e.bumpScale, this
							.normalMap = e.normalMap, this
							.normalMapType = e.normalMapType, this
							.normalScale.copy(e.normalScale), this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this.specularMap = e.specularMap, this
							.alphaMap = e.alphaMap, this.envMap = e
							.envMap, this.combine = e.combine, this
							.reflectivity = e.reflectivity, this
							.refractionRatio = e.refractionRatio, this
							.wireframe = e.wireframe, this
							.wireframeLinewidth = e.wireframeLinewidth,
							this.wireframeLinecap = e.wireframeLinecap,
							this.wireframeLinejoin = e
							.wireframeLinejoin, this.morphTargets = e
							.morphTargets, this.morphNormals = e
							.morphNormals, this.flatShading = e
							.flatShading, this
					}
				}]), n
			}(hn);
			Qs.prototype.isMeshPhongMaterial = !0;
			var Ks = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).defines = {
							TOON: ""
						}, r.type = "MeshToonMaterial", r.color = new yn(16777215), r
						.map = null, r.gradientMap = null, r.lightMap = null, r
						.lightMapIntensity = 1, r.aoMap = null, r.aoMapIntensity = 1, r
						.emissive = new yn(0), r.emissiveIntensity = 1, r.emissiveMap =
						null, r.bumpMap = null, r.bumpScale = 1, r.normalMap = null, r
						.normalMapType = 0, r.normalScale = new Ie(1, 1), r
						.displacementMap = null, r.displacementScale = 1, r
						.displacementBias = 0, r.alphaMap = null, r.wireframe = !1, r
						.wireframeLinewidth = 1, r.wireframeLinecap = "round", r
						.wireframeLinejoin = "round", r.morphTargets = !1, r
						.morphNormals = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.map = e
							.map, this.gradientMap = e.gradientMap, this
							.lightMap = e.lightMap, this
							.lightMapIntensity = e.lightMapIntensity,
							this.aoMap = e.aoMap, this.aoMapIntensity =
							e.aoMapIntensity, this.emissive.copy(e
								.emissive), this.emissiveMap = e
							.emissiveMap, this.emissiveIntensity = e
							.emissiveIntensity, this.bumpMap = e
							.bumpMap, this.bumpScale = e.bumpScale, this
							.normalMap = e.normalMap, this
							.normalMapType = e.normalMapType, this
							.normalScale.copy(e.normalScale), this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this.alphaMap = e.alphaMap, this.wireframe =
							e.wireframe, this.wireframeLinewidth = e
							.wireframeLinewidth, this.wireframeLinecap =
							e.wireframeLinecap, this.wireframeLinejoin =
							e.wireframeLinejoin, this.morphTargets = e
							.morphTargets, this.morphNormals = e
							.morphNormals, this
					}
				}]), n
			}(hn);
			Ks.prototype.isMeshToonMaterial = !0;
			var el = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshNormalMaterial", r.bumpMap = null, r.bumpScale = 1, r
						.normalMap = null, r.normalMapType = 0, r.normalScale = new Ie(
							1, 1), r.displacementMap = null, r.displacementScale = 1, r
						.displacementBias = 0, r.wireframe = !1, r.wireframeLinewidth =
						1, r.fog = !1, r.morphTargets = !1, r.morphNormals = !1, r
						.flatShading = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.bumpMap = e.bumpMap, this
							.bumpScale = e.bumpScale, this.normalMap = e
							.normalMap, this.normalMapType = e
							.normalMapType, this.normalScale.copy(e
								.normalScale), this.displacementMap = e
							.displacementMap, this.displacementScale = e
							.displacementScale, this.displacementBias =
							e.displacementBias, this.wireframe = e
							.wireframe, this.wireframeLinewidth = e
							.wireframeLinewidth, this.morphTargets = e
							.morphTargets, this.morphNormals = e
							.morphNormals, this.flatShading = e
							.flatShading, this
					}
				}]), n
			}(hn);
			el.prototype.isMeshNormalMaterial = !0;
			var tl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"MeshLambertMaterial", r.color = new yn(16777215), r.map = null,
						r.lightMap = null, r.lightMapIntensity = 1, r.aoMap = null, r
						.aoMapIntensity = 1, r.emissive = new yn(0), r
						.emissiveIntensity = 1, r.emissiveMap = null, r.specularMap =
						null, r.alphaMap = null, r.envMap = null, r.combine = 0, r
						.reflectivity = 1, r.refractionRatio = .98, r.wireframe = !1, r
						.wireframeLinewidth = 1, r.wireframeLinecap = "round", r
						.wireframeLinejoin = "round", r.morphTargets = !1, r
						.morphNormals = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.color.copy(e.color), this.map = e
							.map, this.lightMap = e.lightMap, this
							.lightMapIntensity = e.lightMapIntensity,
							this.aoMap = e.aoMap, this.aoMapIntensity =
							e.aoMapIntensity, this.emissive.copy(e
								.emissive), this.emissiveMap = e
							.emissiveMap, this.emissiveIntensity = e
							.emissiveIntensity, this.specularMap = e
							.specularMap, this.alphaMap = e.alphaMap,
							this.envMap = e.envMap, this.combine = e
							.combine, this.reflectivity = e
							.reflectivity, this.refractionRatio = e
							.refractionRatio, this.wireframe = e
							.wireframe, this.wireframeLinewidth = e
							.wireframeLinewidth, this.wireframeLinecap =
							e.wireframeLinecap, this.wireframeLinejoin =
							e.wireframeLinejoin, this.morphTargets = e
							.morphTargets, this.morphNormals = e
							.morphNormals, this
					}
				}]), n
			}(hn);
			tl.prototype.isMeshLambertMaterial = !0;
			var nl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).defines = {
							MATCAP: ""
						}, r.type = "MeshMatcapMaterial", r.color = new yn(16777215), r
						.matcap = null, r.map = null, r.bumpMap = null, r.bumpScale = 1,
						r.normalMap = null, r.normalMapType = 0, r.normalScale = new Ie(
							1, 1), r.displacementMap = null, r.displacementScale = 1, r
						.displacementBias = 0, r.alphaMap = null, r.morphTargets = !1, r
						.morphNormals = !1, r.flatShading = !1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.defines = {
								MATCAP: ""
							}, this.color.copy(e.color), this.matcap = e
							.matcap, this.map = e.map, this.bumpMap = e
							.bumpMap, this.bumpScale = e.bumpScale, this
							.normalMap = e.normalMap, this
							.normalMapType = e.normalMapType, this
							.normalScale.copy(e.normalScale), this
							.displacementMap = e.displacementMap, this
							.displacementScale = e.displacementScale,
							this.displacementBias = e.displacementBias,
							this.alphaMap = e.alphaMap, this
							.morphTargets = e.morphTargets, this
							.morphNormals = e.morphNormals, this
							.flatShading = e.flatShading, this
					}
				}]), n
			}(hn);
			nl.prototype.isMeshMatcapMaterial = !0;
			var rl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r;
					return (0, g.default)(this, n), (r = t.call(this)).type =
						"LineDashedMaterial", r.scale = 1, r.dashSize = 3, r.gapSize =
						1, r.setValues(e), r
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.scale = e.scale, this.dashSize = e
							.dashSize, this.gapSize = e.gapSize, this
					}
				}]), n
			}(Ao);
			rl.prototype.isLineDashedMaterial = !0;
			var il = Object.freeze({
					__proto__: null,
					ShadowMaterial: Ys,
					SpriteMaterial: qa,
					RawShaderMaterial: $s,
					ShaderMaterial: fr,
					PointsMaterial: zo,
					MeshPhysicalMaterial: Js,
					MeshStandardMaterial: Zs,
					MeshPhongMaterial: Qs,
					MeshToonMaterial: Ks,
					MeshNormalMaterial: el,
					MeshLambertMaterial: tl,
					MeshDepthMaterial: Ta,
					MeshDistanceMaterial: Ea,
					MeshBasicMaterial: xn,
					MeshMatcapMaterial: nl,
					LineDashedMaterial: rl,
					LineBasicMaterial: Ao,
					Material: hn
				}),
				al = {
					arraySlice: function(e, t, n) {
						return al.isTypedArray(e) ? new e.constructor(e.subarray(t,
							void 0 !== n ? n : e.length)) : e.slice(t, n)
					},
					convertArray: function(e, t, n) {
						return !e || !n && e.constructor === t ? e : "number" ==
							typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype
							.slice.call(e)
					},
					isTypedArray: function(e) {
						return ArrayBuffer.isView(e) && !(e instanceof DataView)
					},
					getKeyframeOrder: function(e) {
						for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r) n[
							r] = r;
						return n.sort((function(t, n) {
							return e[t] - e[n]
						})), n
					},
					sortedArray: function(e, t, n) {
						for (var r = e.length, i = new e.constructor(r), a = 0, o =
							0; o !== r; ++a)
							for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s +
								l];
						return i
					},
					flattenJSON: function(e, t, n, r) {
						for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a =
							e[i++];
						if (void 0 !== a) {
							var o = a[r];
							if (void 0 !== o)
								if (Array.isArray(o))
									do {
										void 0 !== (o = a[r]) && (t.push(a.time), n.push
											.apply(n, o)), a = e[i++]
									} while (void 0 !== a);
								else if (void 0 !== o.toArray)
								do {
									void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(
										n, n.length)), a = e[i++]
								} while (void 0 !== a);
							else
								do {
									void 0 !== (o = a[r]) && (t.push(a.time), n.push(
										o)), a = e[i++]
								} while (void 0 !== a)
						}
					},
					subclip: function(e, t, n, r) {
						var i = arguments.length > 4 && void 0 !== arguments[4] ?
							arguments[4] : 30,
							a = e.clone();
						a.name = t;
						for (var o = [], s = 0; s < a.tracks.length; ++s) {
							for (var l = a.tracks[s], u = l.getValueSize(), c = [],
									h = [], d = 0; d < l.times.length; ++d) {
								var f = l.times[d] * i;
								if (!(f < n || f >= r)) {
									c.push(l.times[d]);
									for (var p = 0; p < u; ++p) h.push(l.values[d * u +
										p])
								}
							}
							0 !== c.length && (l.times = al.convertArray(c, l.times
								.constructor), l.values = al.convertArray(h, l
								.values.constructor), o.push(l))
						}
						a.tracks = o;
						for (var v = 1 / 0, m = 0; m < a.tracks.length; ++m) v > a
							.tracks[m].times[0] && (v = a.tracks[m].times[0]);
						for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 *
							v);
						return a.resetDuration(), a
					},
					makeClipAdditive: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 0,
							n = arguments.length > 2 && void 0 !== arguments[2] ?
							arguments[2] : e,
							r = arguments.length > 3 && void 0 !== arguments[3] ?
							arguments[3] : 30;
						r <= 0 && (r = 30);
						for (var i = n.tracks.length, a = t / r, o = function(t) {
								var r = n.tracks[t],
									i = r.ValueTypeName;
								if ("bool" === i || "string" === i)
								return "continue";
								var o = e.tracks.find((function(e) {
									return e.name === r.name && e
										.ValueTypeName === i
								}));
								if (void 0 === o) return "continue";
								var s = 0,
									l = r.getValueSize();
								r.createInterpolant
									.isInterpolantFactoryMethodGLTFCubicSpline && (
										s = l / 3);
								var u = 0,
									c = o.getValueSize();
								o.createInterpolant
									.isInterpolantFactoryMethodGLTFCubicSpline && (
										u = c / 3);
								var h = r.times.length - 1,
									d = void 0;
								if (a <= r.times[0]) {
									var f = s,
										p = l - s;
									d = al.arraySlice(r.values, f, p)
								} else if (a >= r.times[h]) {
									var v = h * l + s,
										m = v + l - s;
									d = al.arraySlice(r.values, v, m)
								} else {
									var g = r.createInterpolant(),
										y = s,
										x = l - s;
									g.evaluate(a), d = al.arraySlice(g.resultBuffer,
										y, x)
								}
								"quaternion" === i && (new We).fromArray(d)
									.normalize().conjugate().toArray(d);
								for (var _ = o.times.length, b = 0; b < _; ++b) {
									var w = b * c + u;
									if ("quaternion" === i) We
										.multiplyQuaternionsFlat(o.values, w, d, 0,
											o.values, w);
									else
										for (var M = c - 2 * u, S = 0; S < M; ++S) o
											.values[w + S] -= d[S]
								}
							}, s = 0; s < i; ++s) o(s);
						return e.blendMode = se, e
					}
				},
				ol = function() {
					function e(t, n, r, i) {
						(0, g.default)(this, e), this.parameterPositions = t, this
							._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new n
							.constructor(r), this.sampleValues = n, this.valueSize = r, this
							.settings = null, this.DefaultSettings_ = {}
					}
					return (0, y.default)(e, [{
						key: "evaluate",
						value: function(e) {
							var t = this.parameterPositions,
								n = this._cachedIndex,
								r = t[n],
								i = t[n - 1];
							e: {
								t: {
									var a;n: {
										r: if (!(e < r)) {
											for (var o = n + 2;;) {
												if (void 0 === r) {
													if (e < i)
													break r;
													return n = t
														.length,
														this
														._cachedIndex =
														n, this
														.afterEnd_(
															n - 1,
															e, i)
												}
												if (n === o) break;
												if (i = r, e < (r =
														t[++n]))
													break t
											}
											a = t.length;
											break n
										}if (e >= i) break e;
										var s = t[1];e < s && (n = 2,
											i = s);
										for (var l = n - 2;;) {
											if (void 0 === i)
											return this
												._cachedIndex = 0,
												this.beforeStart_(0,
													e, r);
											if (n === l) break;
											if (r = i, e >= (i = t[--n -
													1])) break t
										}
										a = n,
										n = 0
									}
									for (; n < a;) {
										var u = n + a >>> 1;
										e < t[u] ? a = u : n = u + 1
									}
									if (r = t[n], void 0 === (i = t[n -
											1])) return this
										._cachedIndex = 0,
									this.beforeStart_(0, e, r);
									if (void 0 === r) return n = t
										.length,
									this._cachedIndex = n,
									this.afterEnd_(n - 1, i, e)
								}
								this._cachedIndex = n,
								this.intervalChanged_(n, i, r)
							}
							return this.interpolate_(n, i, e, r)
						}
					}, {
						key: "getSettings_",
						value: function() {
							return this.settings || this.DefaultSettings_
						}
					}, {
						key: "copySampleValue_",
						value: function(e) {
							for (var t = this.resultBuffer, n = this
									.sampleValues, r = this.valueSize, i =
									e * r, a = 0; a !== r; ++a) t[a] = n[i +
								a];
							return t
						}
					}, {
						key: "interpolate_",
						value: function() {
							throw new Error("call to abstract method")
						}
					}, {
						key: "intervalChanged_",
						value: function() {}
					}]), e
				}();
			ol.prototype.beforeStart_ = ol.prototype.copySampleValue_, ol.prototype
				.afterEnd_ = ol.prototype.copySampleValue_;
			var sl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i, a) {
						var o;
						return (0, g.default)(this, n), (o = t.call(this, e, r, i, a))
							._weightPrev = -0, o._offsetPrev = -0, o._weightNext = -0, o
							._offsetNext = -0, o.DefaultSettings_ = {
								endingStart: re,
								endingEnd: re
							}, o
					}
					return (0, y.default)(n, [{
						key: "intervalChanged_",
						value: function(e, t, n) {
							var r = this.parameterPositions,
								i = e - 2,
								a = e + 1,
								o = r[i],
								s = r[a];
							if (void 0 === o) switch (this.getSettings_()
								.endingStart) {
								case ie:
									i = e, o = 2 * t - n;
									break;
								case ae:
									o = t + r[i = r.length - 2] - r[i +
										1];
									break;
								default:
									i = e, o = n
							}
							if (void 0 === s) switch (this.getSettings_()
								.endingEnd) {
								case ie:
									a = e, s = 2 * n - t;
									break;
								case ae:
									a = 1, s = n + r[1] - r[0];
									break;
								default:
									a = e - 1, s = t
							}
							var l = .5 * (n - t),
								u = this.valueSize;
							this._weightPrev = l / (t - o), this
								._weightNext = l / (s - n), this
								._offsetPrev = i * u, this._offsetNext = a *
								u
						}
					}, {
						key: "interpolate_",
						value: function(e, t, n, r) {
							for (var i = this.resultBuffer, a = this
									.sampleValues, o = this.valueSize, s =
									e * o, l = s - o, u = this._offsetPrev,
									c = this._offsetNext, h = this
									._weightPrev, d = this._weightNext, f =
									(n - t) / (r - t), p = f * f, v = p * f,
									m = -h * v + 2 * h * p - h * f, g = (1 +
										h) * v + (-1.5 - 2 * h) * p + (-.5 +
										h) * f + 1, y = (-1 - d) * v + (
										1.5 + d) * p + .5 * f, x = d * v -
									d * p, _ = 0; _ !== o; ++_) i[_] = m *
								a[u + _] + g * a[l + _] + y * a[s + _] + x *
								a[c + _];
							return i
						}
					}]), n
				}(ol),
				ll = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i, a) {
						return (0, g.default)(this, n), t.call(this, e, r, i, a)
					}
					return (0, y.default)(n, [{
						key: "interpolate_",
						value: function(e, t, n, r) {
							for (var i = this.resultBuffer, a = this
									.sampleValues, o = this.valueSize, s =
									e * o, l = s - o, u = (n - t) / (r - t),
									c = 1 - u, h = 0; h !== o; ++h) i[h] =
								a[l + h] * c + a[s + h] * u;
							return i
						}
					}]), n
				}(ol),
				ul = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i, a) {
						return (0, g.default)(this, n), t.call(this, e, r, i, a)
					}
					return (0, y.default)(n, [{
						key: "interpolate_",
						value: function(e) {
							return this.copySampleValue_(e - 1)
						}
					}]), n
				}(ol),
				cl = function() {
					function e(t, n, r, i) {
						if ((0, g.default)(this, e), void 0 === t) throw new Error(
							"THREE.KeyframeTrack: track name is undefined");
						if (void 0 === n || 0 === n.length) throw new Error(
							"THREE.KeyframeTrack: no keyframes in track named " + t);
						this.name = t, this.times = al.convertArray(n, this.TimeBufferType),
							this.values = al.convertArray(r, this.ValueBufferType), this
							.setInterpolation(i || this.DefaultInterpolation)
					}
					return (0, y.default)(e, [{
						key: "InterpolantFactoryMethodDiscrete",
						value: function(e) {
							return new ul(this.times, this.values, this
								.getValueSize(), e)
						}
					}, {
						key: "InterpolantFactoryMethodLinear",
						value: function(e) {
							return new ll(this.times, this.values, this
								.getValueSize(), e)
						}
					}, {
						key: "InterpolantFactoryMethodSmooth",
						value: function(e) {
							return new sl(this.times, this.values, this
								.getValueSize(), e)
						}
					}, {
						key: "setInterpolation",
						value: function(e) {
							var t;
							switch (e) {
								case ee:
									t = this
										.InterpolantFactoryMethodDiscrete;
									break;
								case te:
									t = this.InterpolantFactoryMethodLinear;
									break;
								case ne:
									t = this.InterpolantFactoryMethodSmooth
							}
							if (void 0 === t) {
								var n = "unsupported interpolation for " +
									this.ValueTypeName +
									" keyframe track named " + this.name;
								if (void 0 === this.createInterpolant) {
									if (e === this.DefaultInterpolation)
										throw new Error(n);
									this.setInterpolation(this
										.DefaultInterpolation)
								}
								return console.warn("THREE.KeyframeTrack:",
									n), this
							}
							return this.createInterpolant = t, this
						}
					}, {
						key: "getInterpolation",
						value: function() {
							switch (this.createInterpolant) {
								case this.InterpolantFactoryMethodDiscrete:
									return ee;
								case this.InterpolantFactoryMethodLinear:
									return te;
								case this.InterpolantFactoryMethodSmooth:
									return ne
							}
						}
					}, {
						key: "getValueSize",
						value: function() {
							return this.values.length / this.times.length
						}
					}, {
						key: "shift",
						value: function(e) {
							if (0 !== e)
								for (var t = this.times, n = 0, r = t
									.length; n !== r; ++n) t[n] += e;
							return this
						}
					}, {
						key: "scale",
						value: function(e) {
							if (1 !== e)
								for (var t = this.times, n = 0, r = t
									.length; n !== r; ++n) t[n] *= e;
							return this
						}
					}, {
						key: "trim",
						value: function(e, t) {
							for (var n = this.times, r = n.length, i = 0,
									a = r - 1; i !== r && n[i] < e;) ++i;
							for (; - 1 !== a && n[a] > t;) --a;
							if (++a, 0 !== i || a !== r) {
								i >= a && (i = (a = Math.max(a, 1)) - 1);
								var o = this.getValueSize();
								this.times = al.arraySlice(n, i, a), this
									.values = al.arraySlice(this.values, i *
										o, a * o)
							}
							return this
						}
					}, {
						key: "validate",
						value: function() {
							var e = !0,
								t = this.getValueSize();
							t - Math.floor(t) != 0 && (console.error(
								"THREE.KeyframeTrack: Invalid value size in track.",
								this), e = !1);
							var n = this.times,
								r = this.values,
								i = n.length;
							0 === i && (console.error(
								"THREE.KeyframeTrack: Track is empty.",
								this), e = !1);
							for (var a = null, o = 0; o !== i; o++) {
								var s = n[o];
								if ("number" == typeof s && isNaN(s)) {
									console.error(
										"THREE.KeyframeTrack: Time is not a valid number.",
										this, o, s), e = !1;
									break
								}
								if (null !== a && a > s) {
									console.error(
										"THREE.KeyframeTrack: Out of order keys.",
										this, o, s, a), e = !1;
									break
								}
								a = s
							}
							if (void 0 !== r && al.isTypedArray(r))
								for (var l = 0, u = r.length; l !== u; ++
									l) {
									var c = r[l];
									if (isNaN(c)) {
										console.error(
											"THREE.KeyframeTrack: Value is not a valid number.",
											this, l, c), e = !1;
										break
									}
								}
							return e
						}
					}, {
						key: "optimize",
						value: function() {
							for (var e = al.arraySlice(this.times), t = al
									.arraySlice(this.values), n = this
									.getValueSize(), r = this
									.getInterpolation() === ne, i = e
									.length - 1, a = 1, o = 1; o < i; ++o) {
								var s = !1,
									l = e[o];
								if (l !== e[o + 1] && (1 !== o || l !== e[
										0]))
									if (r) s = !0;
									else
										for (var u = o * n, c = u - n, h =
												u + n, d = 0; d !== n; ++
											d) {
											var f = t[u + d];
											if (f !== t[c + d] || f !== t[
													h + d]) {
												s = !0;
												break
											}
										}
								if (s) {
									if (o !== a) {
										e[a] = e[o];
										for (var p = o * n, v = a * n, m =
											0; m !== n; ++m) t[v + m] = t[
											p + m]
									}++a
								}
							}
							if (i > 0) {
								e[a] = e[i];
								for (var g = i * n, y = a * n, x = 0; x !==
									n; ++x) t[y + x] = t[g + x];
								++a
							}
							return a !== e.length ? (this.times = al
								.arraySlice(e, 0, a), this.values = al
								.arraySlice(t, 0, a * n)) : (this
								.times = e, this.values = t), this
						}
					}, {
						key: "clone",
						value: function() {
							var e = al.arraySlice(this.times, 0),
								t = al.arraySlice(this.values, 0),
								n = new(0, this.constructor)(this.name, e,
									t);
							return n.createInterpolant = this
								.createInterpolant, n
						}
					}], [{
						key: "toJSON",
						value: function(e) {
							var t, n = e.constructor;
							if (n.toJSON !== this.toJSON) t = n.toJSON(e);
							else {
								t = {
									name: e.name,
									times: al.convertArray(e.times,
										Array),
									values: al.convertArray(e.values,
										Array)
								};
								var r = e.getInterpolation();
								r !== e.DefaultInterpolation && (t
									.interpolation = r)
							}
							return t.type = e.ValueTypeName, t
						}
					}]), e
				}();
			cl.prototype.TimeBufferType = Float32Array, cl.prototype.ValueBufferType =
				Float32Array, cl.prototype.DefaultInterpolation = te;
			var hl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(cl);
			hl.prototype.ValueTypeName = "bool", hl.prototype.ValueBufferType = Array, hl
				.prototype.DefaultInterpolation = ee, hl.prototype
				.InterpolantFactoryMethodLinear = void 0, hl.prototype
				.InterpolantFactoryMethodSmooth = void 0;
			var dl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(cl);
			dl.prototype.ValueTypeName = "color";
			var fl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(cl);
			fl.prototype.ValueTypeName = "number";
			var pl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i, a) {
						return (0, g.default)(this, n), t.call(this, e, r, i, a)
					}
					return (0, y.default)(n, [{
						key: "interpolate_",
						value: function(e, t, n, r) {
							for (var i = this.resultBuffer, a = this
									.sampleValues, o = this.valueSize, s = (
										n - t) / (r - t), l = e * o, u = l +
									o; l !== u; l += 4) We.slerpFlat(i, 0,
								a, l - o, a, l, s);
							return i
						}
					}]), n
				}(ol),
				vl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						return (0, g.default)(this, n), t.apply(this, arguments)
					}
					return (0, y.default)(n, [{
						key: "InterpolantFactoryMethodLinear",
						value: function(e) {
							return new pl(this.times, this.values, this
								.getValueSize(), e)
						}
					}]), n
				}(cl);
			vl.prototype.ValueTypeName = "quaternion", vl.prototype.DefaultInterpolation =
				te, vl.prototype.InterpolantFactoryMethodSmooth = void 0;
			var ml = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(cl);
			ml.prototype.ValueTypeName = "string", ml.prototype.ValueBufferType = Array, ml
				.prototype.DefaultInterpolation = ee, ml.prototype
				.InterpolantFactoryMethodLinear = void 0, ml.prototype
				.InterpolantFactoryMethodSmooth = void 0;
			var gl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.apply(this, arguments)
				}
				return n
			}(cl);
			gl.prototype.ValueTypeName = "vector";
			var yl = function() {
				function e(t) {
					var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : -1,
						r = arguments.length > 2 ? arguments[2] : void 0,
						i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 2500;
					(0, g.default)(this, e), this.name = t, this.tracks = r, this
						.duration = n, this.blendMode = i, this.uuid = Te(), this
						.duration < 0 && this.resetDuration()
				}
				return (0, y.default)(e, [{
					key: "resetDuration",
					value: function() {
						for (var e = 0, t = 0, n = this.tracks
							.length; t !== n; ++t) {
							var r = this.tracks[t];
							e = Math.max(e, r.times[r.times.length - 1])
						}
						return this.duration = e, this
					}
				}, {
					key: "trim",
					value: function() {
						for (var e = 0; e < this.tracks.length; e++)
							this.tracks[e].trim(0, this.duration);
						return this
					}
				}, {
					key: "validate",
					value: function() {
						for (var e = !0, t = 0; t < this.tracks
							.length; t++) e = e && this.tracks[t]
							.validate();
						return e
					}
				}, {
					key: "optimize",
					value: function() {
						for (var e = 0; e < this.tracks.length; e++)
							this.tracks[e].optimize();
						return this
					}
				}, {
					key: "clone",
					value: function() {
						for (var e = [], t = 0; t < this.tracks
							.length; t++) e.push(this.tracks[t]
					.clone());
						return new this.constructor(this.name, this
							.duration, e, this.blendMode)
					}
				}, {
					key: "toJSON",
					value: function() {
						return this.constructor.toJSON(this)
					}
				}], [{
					key: "parse",
					value: function(e) {
						for (var t = [], n = e.tracks, r = 1 / (e.fps ||
								1), i = 0, a = n.length; i !== a; ++i) t
							.push(xl(n[i]).scale(r));
						var o = new this(e.name, e.duration, t, e
							.blendMode);
						return o.uuid = e.uuid, o
					}
				}, {
					key: "toJSON",
					value: function(e) {
						for (var t = [], n = e.tracks, r = {
								name: e.name,
								duration: e.duration,
								tracks: t,
								uuid: e.uuid,
								blendMode: e.blendMode
							}, i = 0, a = n.length; i !== a; ++i) t
							.push(cl.toJSON(n[i]));
						return r
					}
				}, {
					key: "CreateFromMorphTargetSequence",
					value: function(e, t, n, r) {
						for (var i = t.length, a = [], o = 0; o <
							i; o++) {
							var s = [],
								l = [];
							s.push((o + i - 1) % i, o, (o + 1) % i), l
								.push(0, 1, 0);
							var u = al.getKeyframeOrder(s);
							s = al.sortedArray(s, 1, u), l = al
								.sortedArray(l, 1, u), r || 0 !== s[
								0] || (s.push(i), l.push(l[0])), a.push(
									new fl(".morphTargetInfluences[" +
										t[o].name + "]", s, l).scale(1 /
										n))
						}
						return new this(e, -1, a)
					}
				}, {
					key: "findByName",
					value: function(e, t) {
						var n = e;
						if (!Array.isArray(e)) {
							var r = e;
							n = r.geometry && r.geometry.animations || r
								.animations
						}
						for (var i = 0; i < n.length; i++)
							if (n[i].name === t) return n[i];
						return null
					}
				}, {
					key: "CreateClipsFromMorphTargetSequences",
					value: function(e, t, n) {
						for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a =
								0, o = e.length; a < o; a++) {
							var s = e[a],
								l = s.name.match(i);
							if (l && l.length > 1) {
								var u = l[1],
									c = r[u];
								c || (r[u] = c = []), c.push(s)
							}
						}
						var h = [];
						for (var d in r) h.push(this
							.CreateFromMorphTargetSequence(d, r[d],
								t, n));
						return h
					}
				}, {
					key: "parseAnimation",
					value: function(e, t) {
						if (!e) return console.error(
							"THREE.AnimationClip: No animation in JSONLoader data."
							), null;
						for (var n = function(e, t, n, r, i) {
									if (0 !== n.length) {
										var a = [],
											o = [];
										al.flattenJSON(n, a, o, r),
											0 !== a.length && i.push(
												new e(t, a, o))
									}
								}, r = [], i = e.name || "default", a =
								e.fps || 30, o = e.blendMode, s = e
								.length || -1, l = e.hierarchy || [],
								u = 0; u < l.length; u++) {
							var c = l[u].keys;
							if (c && 0 !== c.length)
								if (c[0].morphTargets) {
									var h = {},
										d = void 0;
									for (d = 0; d < c.length; d++)
										if (c[d].morphTargets)
											for (var f = 0; f < c[d]
												.morphTargets
												.length; f++) h[c[d]
													.morphTargets[f]
													] = -1;
									for (var p in h) {
										for (var v = [], m = [], g =
											0; g !== c[d].morphTargets
											.length; ++g) {
											var y = c[d];
											v.push(y.time), m.push(y
												.morphTarget === p ?
												1 : 0)
										}
										r.push(new fl(
											".morphTargetInfluence[" +
											p + "]", v, m))
									}
									s = h.length * (a || 1)
								} else {
									var x = ".bones[" + t[u].name + "]";
									n(gl, x + ".position", c, "pos", r),
										n(vl, x + ".quaternion", c,
											"rot", r), n(gl, x +
											".scale", c, "scl", r)
								}
						}
						return 0 === r.length ? null : new this(i, s, r,
							o)
					}
				}]), e
			}();

			function xl(e) {
				if (void 0 === e.type) throw new Error(
					"THREE.KeyframeTrack: track type undefined, can not parse");
				var t = function(e) {
					switch (e.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return fl;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return gl;
						case "color":
							return dl;
						case "quaternion":
							return vl;
						case "bool":
						case "boolean":
							return hl;
						case "string":
							return ml
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
				}(e.type);
				if (void 0 === e.times) {
					var n = [],
						r = [];
					al.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
				}
				return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e
					.interpolation)
			}
			var _l = {
					enabled: !1,
					files: {},
					add: function(e, t) {
						!1 !== this.enabled && (this.files[e] = t)
					},
					get: function(e) {
						if (!1 !== this.enabled) return this.files[e]
					},
					remove: function(e) {
						delete this.files[e]
					},
					clear: function() {
						this.files = {}
					}
				},
				bl = function e(t, n, r) {
					(0, g.default)(this, e);
					var i, a = this,
						o = !1,
						s = 0,
						l = 0,
						u = [];
					this.onStart = void 0, this.onLoad = t, this.onProgress = n, this
						.onError = r, this.itemStart = function(e) {
							l++, !1 === o && void 0 !== a.onStart && a.onStart(e, s, l),
								o = !0
						}, this.itemEnd = function(e) {
							s++, void 0 !== a.onProgress && a.onProgress(e, s, l), s ===
								l && (o = !1, void 0 !== a.onLoad && a.onLoad())
						}, this.itemError = function(e) {
							void 0 !== a.onError && a.onError(e)
						}, this.resolveURL = function(e) {
							return i ? i(e) : e
						}, this.setURLModifier = function(e) {
							return i = e, this
						}, this.addHandler = function(e, t) {
							return u.push(e, t), this
						}, this.removeHandler = function(e) {
							var t = u.indexOf(e);
							return -1 !== t && u.splice(t, 2), this
						}, this.getHandler = function(e) {
							for (var t = 0, n = u.length; t < n; t += 2) {
								var r = u[t],
									i = u[t + 1];
								if (r.global && (r.lastIndex = 0), r.test(e)) return i
							}
							return null
						}
				},
				wl = new bl,
				Ml = function() {
					function e(t) {
						(0, g.default)(this, e), this.manager = void 0 !== t ? t : wl, this
							.crossOrigin = "anonymous", this.withCredentials = !1, this
							.path = "", this.resourcePath = "", this.requestHeader = {}
					}
					return (0, y.default)(e, [{
						key: "load",
						value: function() {}
					}, {
						key: "loadAsync",
						value: function(e, t) {
							var n = this;
							return new Promise((function(r, i) {
								n.load(e, r, t, i)
							}))
						}
					}, {
						key: "parse",
						value: function() {}
					}, {
						key: "setCrossOrigin",
						value: function(e) {
							return this.crossOrigin = e, this
						}
					}, {
						key: "setWithCredentials",
						value: function(e) {
							return this.withCredentials = e, this
						}
					}, {
						key: "setPath",
						value: function(e) {
							return this.path = e, this
						}
					}, {
						key: "setResourcePath",
						value: function(e) {
							return this.resourcePath = e, this
						}
					}, {
						key: "setRequestHeader",
						value: function(e) {
							return this.requestHeader = e, this
						}
					}]), e
				}(),
				Sl = {},
				Tl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							void 0 === e && (e = ""), void 0 !== this
								.path && (e = this.path + e), e = this
								.manager.resolveURL(e);
							var i = this,
								a = _l.get(e);
							if (void 0 !== a) return i.manager.itemStart(e),
								setTimeout((function() {
									t && t(a), i.manager
										.itemEnd(e)
								}), 0), a;
							if (void 0 === Sl[e]) {
								var o, s = e.match(
									/^data:(.*?)(;base64)?,(.*)$/);
								if (s) {
									var l = s[1],
										u = !!s[2],
										c = s[3];
									c = decodeURIComponent(c), u && (c =
										atob(c));
									try {
										var h, d = (this.responseType || "")
											.toLowerCase();
										switch (d) {
											case "arraybuffer":
											case "blob":
												for (var f = new Uint8Array(
														c.length), p =
													0; p < c.length; p++) f[p] =
													c.charCodeAt(p);
												h = "blob" === d ? new Blob(
													[f.buffer], {
														type: l
													}) : f.buffer;
												break;
											case "document":
												var v = new DOMParser;
												h = v.parseFromString(c, l);
												break;
											case "json":
												h = JSON.parse(c);
												break;
											default:
												h = c
										}
										setTimeout((function() {
											t && t(h), i.manager
												.itemEnd(e)
										}), 0)
									} catch (t) {
										setTimeout((function() {
											r && r(t), i.manager
												.itemError(e), i
												.manager
												.itemEnd(e)
										}), 0)
									}
								} else {
									for (var m in Sl[e] = [], Sl[e].push({
												onLoad: t,
												onProgress: n,
												onError: r
											}), (o = new XMLHttpRequest)
											.open("GET", e, !0), o
											.addEventListener("load", (
												function(t) {
													var n = this
														.response,
														r = Sl[e];
													if (delete Sl[e],
														200 === this
														.status || 0 ===
														this.status) {
														0 === this
															.status &&
															console
															.warn(
																"THREE.FileLoader: HTTP Status 0 received."
																), _l
															.add(e, n);
														for (var a = 0,
																o = r
																.length; a <
															o; a++) {
															var s = r[
															a];
															s.onLoad &&
																s
																.onLoad(
																	n)
														}
														i.manager
															.itemEnd(e)
													} else {
														for (var l = 0,
																u = r
																.length; l <
															u; l++) {
															var c = r[
															l];
															c.onError &&
																c
																.onError(
																	t)
														}
														i.manager
															.itemError(
																e), i
															.manager
															.itemEnd(e)
													}
												}), !1), o.addEventListener(
												"progress", (function(t) {
													for (var n = Sl[e],
															r = 0, i = n
															.length; r <
														i; r++) {
														var a = n[r];
														a.onProgress &&
															a
															.onProgress(
																t)
													}
												}), !1), o.addEventListener(
												"error", (function(t) {
													var n = Sl[e];
													delete Sl[e];
													for (var r = 0, a =
															n
															.length; r <
														a; r++) {
														var o = n[r];
														o.onError && o
															.onError(t)
													}
													i.manager.itemError(
															e), i
														.manager
														.itemEnd(e)
												}), !1), o.addEventListener(
												"abort", (function(t) {
													var n = Sl[e];
													delete Sl[e];
													for (var r = 0, a =
															n
															.length; r <
														a; r++) {
														var o = n[r];
														o.onError && o
															.onError(t)
													}
													i.manager.itemError(
															e), i
														.manager
														.itemEnd(e)
												}), !1), void 0 !== this
											.responseType && (o
												.responseType = this
												.responseType), void 0 !==
											this.withCredentials && (o
												.withCredentials = this
												.withCredentials), o
											.overrideMimeType && o
											.overrideMimeType(void 0 !==
												this.mimeType ? this
												.mimeType : "text/plain"),
											this.requestHeader) o
										.setRequestHeader(m, this
											.requestHeader[m]);
									o.send(null)
								}
								return i.manager.itemStart(e), o
							}
							Sl[e].push({
								onLoad: t,
								onProgress: n,
								onError: r
							})
						}
					}, {
						key: "setResponseType",
						value: function(e) {
							return this.responseType = e, this
						}
					}, {
						key: "setMimeType",
						value: function(e) {
							return this.mimeType = e, this
						}
					}]), n
				}(Ml),
				El = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							void 0 !== this.path && (e = this.path + e), e =
								this.manager.resolveURL(e);
							var i = this,
								a = _l.get(e);
							if (void 0 !== a) return i.manager.itemStart(e),
								setTimeout((function() {
									t && t(a), i.manager
										.itemEnd(e)
								}), 0), a;
							var o = document.createElementNS(
								"http://www.w3.org/1999/xhtml", "img");

							function s() {
								o.removeEventListener("load", s, !1), o
									.removeEventListener("error", l, !1), _l
									.add(e, this), t && t(this), i.manager
									.itemEnd(e)
							}

							function l(t) {
								o.removeEventListener("load", s, !1), o
									.removeEventListener("error", l, !1),
									r && r(t), i.manager.itemError(e), i
									.manager.itemEnd(e)
							}
							return o.addEventListener("load", s, !1), o
								.addEventListener("error", l, !1),
								"data:" !== e.substr(0, 5) && void 0 !==
								this.crossOrigin && (o.crossOrigin = this
									.crossOrigin), i.manager.itemStart(e), o
								.src = e, o
						}
					}]), n
				}(Ml),
				Al = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = new yr,
								a = new El(this.manager);
							a.setCrossOrigin(this.crossOrigin), a.setPath(
								this.path);
							var o = 0;

							function s(n) {
								a.load(e[n], (function(e) {
									i.images[n] = e, 6 == ++o &&
										(i.needsUpdate = !0,
											t && t(i))
								}), void 0, r)
							}
							for (var l = 0; l < e.length; ++l) s(l);
							return i
						}
					}]), n
				}(Ml),
				Ll = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new yo,
								o = new Tl(this.manager);
							return o.setResponseType("arraybuffer"), o
								.setRequestHeader(this.requestHeader), o
								.setPath(this.path), o.setWithCredentials(i
									.withCredentials), o.load(e, (function(
									e) {
									var n = i.parse(e);
									n && (void 0 !== n.image ? a
										.image = n.image :
										void 0 !== n.data && (a
											.image.width = n
											.width, a.image
											.height = n.height,
											a.image.data = n
											.data), a.wrapS =
										void 0 !== n.wrapS ? n
										.wrapS : E, a.wrapT =
										void 0 !== n.wrapT ? n
										.wrapT : E, a
										.magFilter = void 0 !==
										n.magFilter ? n
										.magFilter : C, a
										.minFilter = void 0 !==
										n.minFilter ? n
										.minFilter : C, a
										.anisotropy = void 0 !==
										n.anisotropy ? n
										.anisotropy : 1,
										void 0 !== n.encoding &&
										(a.encoding = n
											.encoding),
										void 0 !== n.flipY && (a
											.flipY = n.flipY),
										void 0 !== n.format && (
											a.format = n.format
											), void 0 !== n
										.type && (a.type = n
											.type), void 0 !== n
										.mipmaps && (a.mipmaps =
											n.mipmaps, a
											.minFilter = I),
										1 === n.mipmapCount && (
											a.minFilter = C),
										void 0 !== n
										.generateMipmaps && (a
											.generateMipmaps = n
											.generateMipmaps), a
										.needsUpdate = !0, t &&
										t(a, n))
								}), n, r), a
						}
					}]), n
				}(Ml),
				kl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = new ze,
								a = new El(this.manager);
							return a.setCrossOrigin(this.crossOrigin), a
								.setPath(this.path), a.load(e, (function(
								n) {
									i.image = n;
									var r = e.search(
											/\.jpe?g($|\?)/i) > 0 ||
										0 === e.search(
											/^data\:image\/jpeg/);
									i.format = r ? H : U, i
										.needsUpdate = !0,
										void 0 !== t && t(i)
								}), n, r), i
						}
					}]), n
				}(Ml),
				Rl = function() {
					function e() {
						(0, g.default)(this, e), this.type = "Curve", this
							.arcLengthDivisions = 200
					}
					return (0, y.default)(e, [{
						key: "getPoint",
						value: function() {
							return console.warn(
								"THREE.Curve: .getPoint() not implemented."
								), null
						}
					}, {
						key: "getPointAt",
						value: function(e, t) {
							var n = this.getUtoTmapping(e);
							return this.getPoint(n, t)
						}
					}, {
						key: "getPoints",
						value: function() {
							for (var e = arguments.length > 0 && void 0 !==
									arguments[0] ? arguments[0] : 5, t = [],
									n = 0; n <= e; n++) t.push(this
								.getPoint(n / e));
							return t
						}
					}, {
						key: "getSpacedPoints",
						value: function() {
							for (var e = arguments.length > 0 && void 0 !==
									arguments[0] ? arguments[0] : 5, t = [],
									n = 0; n <= e; n++) t.push(this
								.getPointAt(n / e));
							return t
						}
					}, {
						key: "getLength",
						value: function() {
							var e = this.getLengths();
							return e[e.length - 1]
						}
					}, {
						key: "getLengths",
						value: function() {
							var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : this
								.arcLengthDivisions;
							if (this.cacheArcLengths && this.cacheArcLengths
								.length === e + 1 && !this.needsUpdate)
								return this.cacheArcLengths;
							this.needsUpdate = !1;
							var t, n = [],
								r = this.getPoint(0),
								i = 0;
							n.push(0);
							for (var a = 1; a <= e; a++) i += (t = this
								.getPoint(a / e)).distanceTo(r), n.push(
								i), r = t;
							return this.cacheArcLengths = n, n
						}
					}, {
						key: "updateArcLengths",
						value: function() {
							this.needsUpdate = !0, this.getLengths()
						}
					}, {
						key: "getUtoTmapping",
						value: function(e, t) {
							var n, r = this.getLengths(),
								i = 0,
								a = r.length;
							n = t || e * r[a - 1];
							for (var o, s = 0, l = a - 1; s <= l;)
								if ((o = r[i = Math.floor(s + (l - s) /
										2)] - n) < 0) s = i + 1;
								else {
									if (!(o > 0)) {
										l = i;
										break
									}
									l = i - 1
								} if (r[i = l] === n) return i / (a - 1);
							var u = r[i];
							return (i + (n - u) / (r[i + 1] - u)) / (a - 1)
						}
					}, {
						key: "getTangent",
						value: function(e, t) {
							var n = 1e-4,
								r = e - n,
								i = e + n;
							r < 0 && (r = 0), i > 1 && (i = 1);
							var a = this.getPoint(r),
								o = this.getPoint(i),
								s = t || (a.isVector2 ? new Ie : new je);
							return s.copy(o).sub(a).normalize(), s
						}
					}, {
						key: "getTangentAt",
						value: function(e, t) {
							var n = this.getUtoTmapping(e);
							return this.getTangent(n, t)
						}
					}, {
						key: "computeFrenetFrames",
						value: function(e, t) {
							for (var n = new je, r = [], i = [], a = [], o =
									new je, s = new wt, l = 0; l <=
								e; l++) {
								var u = l / e;
								r[l] = this.getTangentAt(u, new je), r[l]
									.normalize()
							}
							i[0] = new je, a[0] = new je;
							var c = Number.MAX_VALUE,
								h = Math.abs(r[0].x),
								d = Math.abs(r[0].y),
								f = Math.abs(r[0].z);
							h <= c && (c = h, n.set(1, 0, 0)), d <= c && (
									c = d, n.set(0, 1, 0)), f <= c && n.set(
									0, 0, 1), o.crossVectors(r[0], n)
								.normalize(), i[0].crossVectors(r[0], o), a[
									0].crossVectors(r[0], i[0]);
							for (var p = 1; p <= e; p++) {
								if (i[p] = i[p - 1].clone(), a[p] = a[p - 1]
									.clone(), o.crossVectors(r[p - 1], r[
									p]), o.length() > Number.EPSILON) {
									o.normalize();
									var v = Math.acos(Ee(r[p - 1].dot(r[p]),
										-1, 1));
									i[p].applyMatrix4(s.makeRotationAxis(o,
										v))
								}
								a[p].crossVectors(r[p], i[p])
							}
							if (!0 === t) {
								var m = Math.acos(Ee(i[0].dot(i[e]), -1,
								1));
								m /= e, r[0].dot(o.crossVectors(i[0], i[
									e])) > 0 && (m = -m);
								for (var g = 1; g <= e; g++) i[g]
									.applyMatrix4(s.makeRotationAxis(r[g],
										m * g)), a[g].crossVectors(r[g], i[
										g])
							}
							return {
								tangents: r,
								normals: i,
								binormals: a
							}
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.arcLengthDivisions = e
								.arcLengthDivisions, this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = {
								metadata: {
									version: 4.5,
									type: "Curve",
									generator: "Curve.toJSON"
								}
							};
							return e.arcLengthDivisions = this
								.arcLengthDivisions, e.type = this.type, e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							return this.arcLengthDivisions = e
								.arcLengthDivisions, this
						}
					}]), e
				}(),
				Cl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 0,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 0,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 2 * Math.PI,
							u = arguments.length > 6 && void 0 !== arguments[6] &&
							arguments[6],
							c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[
								7] : 0;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"EllipseCurve", e.aX = r, e.aY = i, e.xRadius = a, e.yRadius =
							o, e.aStartAngle = s, e.aEndAngle = l, e.aClockwise = u, e
							.aRotation = c, e
					}
					return (0, y.default)(n, [{
						key: "getPoint",
						value: function(e, t) {
							for (var n = t || new Ie, r = 2 * Math.PI, i =
									this.aEndAngle - this.aStartAngle, a =
									Math.abs(i) < Number.EPSILON; i < 0;)
								i += r;
							for (; i > r;) i -= r;
							i < Number.EPSILON && (i = a ? 0 : r), !0 !==
								this.aClockwise || a || (i === r ? i = -r :
									i -= r);
							var o = this.aStartAngle + e * i,
								s = this.aX + this.xRadius * Math.cos(o),
								l = this.aY + this.yRadius * Math.sin(o);
							if (0 !== this.aRotation) {
								var u = Math.cos(this.aRotation),
									c = Math.sin(this.aRotation),
									h = s - this.aX,
									d = l - this.aY;
								s = h * u - d * c + this.aX, l = h * c + d *
									u + this.aY
							}
							return n.set(s, l)
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.aX = e.aX, this.aY = e.aY, this
								.xRadius = e.xRadius, this.yRadius = e
								.yRadius, this.aStartAngle = e.aStartAngle,
								this.aEndAngle = e.aEndAngle, this
								.aClockwise = e.aClockwise, this.aRotation =
								e.aRotation, this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return e.aX = this.aX, e.aY = this.aY, e
								.xRadius = this.xRadius, e.yRadius = this
								.yRadius, e.aStartAngle = this.aStartAngle,
								e.aEndAngle = this.aEndAngle, e.aClockwise =
								this.aClockwise, e.aRotation = this
								.aRotation, e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "fromJSON", this).call(
									this, e), this.aX = e.aX, this.aY = e
								.aY, this.xRadius = e.xRadius, this
								.yRadius = e.yRadius, this.aStartAngle = e
								.aStartAngle, this.aEndAngle = e.aEndAngle,
								this.aClockwise = e.aClockwise, this
								.aRotation = e.aRotation, this
						}
					}]), n
				}(Rl);
			Cl.prototype.isEllipseCurve = !0;
			var Pl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a, o, s) {
					var l;
					return (0, g.default)(this, n), (l = t.call(this, e, r, i, i, a, o,
						s)).type = "ArcCurve", l
				}
				return n
			}(Cl);

			function Il() {
				var e = 0,
					t = 0,
					n = 0,
					r = 0;

				function i(i, a, o, s) {
					e = i, t = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s
				}
				return {
					initCatmullRom: function(e, t, n, r, a) {
						i(t, n, a * (n - e), a * (r - t))
					},
					initNonuniformCatmullRom: function(e, t, n, r, a, o, s) {
						var l = (t - e) / a - (n - e) / (a + o) + (n - t) / o,
							u = (n - t) / o - (r - t) / (o + s) + (r - n) / s;
						i(t, n, l *= o, u *= o)
					},
					calc: function(i) {
						var a = i * i;
						return e + t * i + n * a + r * (a * i)
					}
				}
			}
			Pl.prototype.isArcCurve = !0;
			var Dl = new je,
				Nl = new Il,
				Ol = new Il,
				Bl = new Il,
				zl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : [],
							i = arguments.length > 1 && void 0 !== arguments[1] &&
							arguments[1],
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : "centripetal",
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : .5;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"CatmullRomCurve3", e.points = r, e.closed = i, e.curveType = a,
							e.tension = o, e
					}
					return (0, y.default)(n, [{
						key: "getPoint",
						value: function(e) {
							var t, n, r = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : new je,
								i = r,
								a = this.points,
								o = a.length,
								s = (o - (this.closed ? 0 : 1)) * e,
								l = Math.floor(s),
								u = s - l;
							this.closed ? l += l > 0 ? 0 : (Math.floor(Math
									.abs(l) / o) + 1) * o : 0 === u && l ===
								o - 1 && (l = o - 2, u = 1), this.closed ||
								l > 0 ? t = a[(l - 1) % o] : (Dl.subVectors(
									a[0], a[1]).add(a[0]), t = Dl);
							var c = a[l % o],
								h = a[(l + 1) % o];
							if (this.closed || l + 2 < o ? n = a[(l + 2) %
									o] : (Dl.subVectors(a[o - 1], a[o - 2])
									.add(a[o - 1]), n = Dl),
								"centripetal" === this.curveType ||
								"chordal" === this.curveType) {
								var d = "chordal" === this.curveType ? .5 :
									.25,
									f = Math.pow(t.distanceToSquared(c), d),
									p = Math.pow(c.distanceToSquared(h), d),
									v = Math.pow(h.distanceToSquared(n), d);
								p < 1e-4 && (p = 1), f < 1e-4 && (f = p),
									v < 1e-4 && (v = p), Nl
									.initNonuniformCatmullRom(t.x, c.x, h.x,
										n.x, f, p, v), Ol
									.initNonuniformCatmullRom(t.y, c.y, h.y,
										n.y, f, p, v), Bl
									.initNonuniformCatmullRom(t.z, c.z, h.z,
										n.z, f, p, v)
							} else "catmullrom" === this.curveType && (Nl
								.initCatmullRom(t.x, c.x, h.x, n.x, this
									.tension), Ol.initCatmullRom(t.y, c
									.y, h.y, n.y, this.tension), Bl
								.initCatmullRom(t.z, c.z, h.z, n.z, this
									.tension));
							return i.set(Nl.calc(u), Ol.calc(u), Bl.calc(
								u)), i
						}
					}, {
						key: "copy",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"copy", this).call(this, e), this
							.points = [];
							for (var t = 0, r = e.points.length; t <
								r; t++) {
								var i = e.points[t];
								this.points.push(i.clone())
							}
							return this.closed = e.closed, this.curveType =
								e.curveType, this.tension = e.tension, this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							e.points = [];
							for (var t = 0, r = this.points.length; t <
								r; t++) {
								var i = this.points[t];
								e.points.push(i.toArray())
							}
							return e.closed = this.closed, e.curveType =
								this.curveType, e.tension = this.tension, e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"fromJSON", this).call(this, e), this
								.points = [];
							for (var t = 0, r = e.points.length; t <
								r; t++) {
								var i = e.points[t];
								this.points.push((new je).fromArray(i))
							}
							return this.closed = e.closed, this.curveType =
								e.curveType, this.tension = e.tension, this
						}
					}]), n
				}(Rl);

			function Fl(e, t, n, r, i) {
				var a = .5 * (r - t),
					o = .5 * (i - n),
					s = e * e;
				return (2 * n - 2 * r + a + o) * (e * s) + (-3 * n + 3 * r - 2 * a - o) *
					s + a * e + n
			}

			function Hl(e, t, n, r) {
				return function(e, t) {
					var n = 1 - e;
					return n * n * t
				}(e, t) + function(e, t) {
					return 2 * (1 - e) * e * t
				}(e, n) + function(e, t) {
					return e * e * t
				}(e, r)
			}

			function Ul(e, t, n, r, i) {
				return function(e, t) {
					var n = 1 - e;
					return n * n * n * t
				}(e, t) + function(e, t) {
					var n = 1 - e;
					return 3 * n * n * e * t
				}(e, n) + function(e, t) {
					return 3 * (1 - e) * e * e * t
				}(e, r) + function(e, t) {
					return e * e * e * t
				}(e, i)
			}
			zl.prototype.isCatmullRomCurve3 = !0;
			var Gl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : new Ie,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : new Ie,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : new Ie,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : new Ie;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"CubicBezierCurve", e.v0 = r, e.v1 = i, e.v2 = a, e.v3 = o, e
				}
				return (0, y.default)(n, [{
					key: "getPoint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : new Ie,
							n = t,
							r = this.v0,
							i = this.v1,
							a = this.v2,
							o = this.v3;
						return n.set(Ul(e, r.x, i.x, a.x, o.x), Ul(e, r
							.y, i.y, a.y, o.y)), n
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.v0.copy(e.v0), this.v1.copy(e.v1),
							this.v2.copy(e.v2), this.v3.copy(e.v3), this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						return e.v0 = this.v0.toArray(), e.v1 = this.v1
							.toArray(), e.v2 = this.v2.toArray(), e.v3 =
							this.v3.toArray(), e
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "fromJSON", this).call(
								this, e), this.v0.fromArray(e.v0), this
							.v1.fromArray(e.v1), this.v2.fromArray(e
							.v2), this.v3.fromArray(e.v3), this
					}
				}]), n
			}(Rl);
			Gl.prototype.isCubicBezierCurve = !0;
			var Vl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : new je,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : new je,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : new je,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : new je;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"CubicBezierCurve3", e.v0 = r, e.v1 = i, e.v2 = a, e.v3 = o, e
				}
				return (0, y.default)(n, [{
					key: "getPoint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : new je,
							n = t,
							r = this.v0,
							i = this.v1,
							a = this.v2,
							o = this.v3;
						return n.set(Ul(e, r.x, i.x, a.x, o.x), Ul(e, r
							.y, i.y, a.y, o.y), Ul(e, r.z, i.z,
							a.z, o.z)), n
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.v0.copy(e.v0), this.v1.copy(e.v1),
							this.v2.copy(e.v2), this.v3.copy(e.v3), this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						return e.v0 = this.v0.toArray(), e.v1 = this.v1
							.toArray(), e.v2 = this.v2.toArray(), e.v3 =
							this.v3.toArray(), e
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "fromJSON", this).call(
								this, e), this.v0.fromArray(e.v0), this
							.v1.fromArray(e.v1), this.v2.fromArray(e
							.v2), this.v3.fromArray(e.v3), this
					}
				}]), n
			}(Rl);
			Vl.prototype.isCubicBezierCurve3 = !0;
			var Wl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : new Ie,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : new Ie;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"LineCurve", e.v1 = r, e.v2 = i, e
				}
				return (0, y.default)(n, [{
					key: "getPoint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : new Ie,
							n = t;
						return 1 === e ? n.copy(this.v2) : (n.copy(this
							.v2).sub(this.v1), n.multiplyScalar(
							e).add(this.v1)), n
					}
				}, {
					key: "getPointAt",
					value: function(e, t) {
						return this.getPoint(e, t)
					}
				}, {
					key: "getTangent",
					value: function(e, t) {
						var n = t || new Ie;
						return n.copy(this.v2).sub(this.v1).normalize(),
							n
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.v1.copy(e.v1), this.v2.copy(e.v2),
							this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						return e.v1 = this.v1.toArray(), e.v2 = this.v2
							.toArray(), e
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "fromJSON", this).call(
								this, e), this.v1.fromArray(e.v1), this
							.v2.fromArray(e.v2), this
					}
				}]), n
			}(Rl);
			Wl.prototype.isLineCurve = !0;
			var jl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new je,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"LineCurve3", e.isLineCurve3 = !0, e.v1 = r, e.v2 = i, e
					}
					return (0, y.default)(n, [{
						key: "getPoint",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : new je,
								n = t;
							return 1 === e ? n.copy(this.v2) : (n.copy(this
								.v2).sub(this.v1), n.multiplyScalar(
								e).add(this.v1)), n
						}
					}, {
						key: "getPointAt",
						value: function(e, t) {
							return this.getPoint(e, t)
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.v1.copy(e.v1), this.v2.copy(e.v2),
								this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return e.v1 = this.v1.toArray(), e.v2 = this.v2
								.toArray(), e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "fromJSON", this).call(
									this, e), this.v1.fromArray(e.v1), this
								.v2.fromArray(e.v2), this
						}
					}]), n
				}(Rl),
				ql = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new Ie,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new Ie,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : new Ie;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"QuadraticBezierCurve", e.v0 = r, e.v1 = i, e.v2 = a, e
					}
					return (0, y.default)(n, [{
						key: "getPoint",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : new Ie,
								n = t,
								r = this.v0,
								i = this.v1,
								a = this.v2;
							return n.set(Hl(e, r.x, i.x, a.x), Hl(e, r.y, i
								.y, a.y)), n
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.v0.copy(e.v0), this.v1.copy(e.v1),
								this.v2.copy(e.v2), this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return e.v0 = this.v0.toArray(), e.v1 = this.v1
								.toArray(), e.v2 = this.v2.toArray(), e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "fromJSON", this).call(
									this, e), this.v0.fromArray(e.v0), this
								.v1.fromArray(e.v1), this.v2.fromArray(e
								.v2), this
						}
					}]), n
				}(Rl);
			ql.prototype.isQuadraticBezierCurve = !0;
			var Xl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : new je,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : new je,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : new je;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"QuadraticBezierCurve3", e.v0 = r, e.v1 = i, e.v2 = a, e
				}
				return (0, y.default)(n, [{
					key: "getPoint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : new je,
							n = t,
							r = this.v0,
							i = this.v1,
							a = this.v2;
						return n.set(Hl(e, r.x, i.x, a.x), Hl(e, r.y, i
							.y, a.y), Hl(e, r.z, i.z, a.z)), n
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.v0.copy(e.v0), this.v1.copy(e.v1),
							this.v2.copy(e.v2), this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						return e.v0 = this.v0.toArray(), e.v1 = this.v1
							.toArray(), e.v2 = this.v2.toArray(), e
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "fromJSON", this).call(
								this, e), this.v0.fromArray(e.v0), this
							.v1.fromArray(e.v1), this.v2.fromArray(e
							.v2), this
					}
				}]), n
			}(Rl);
			Xl.prototype.isQuadraticBezierCurve3 = !0;
			var Yl = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : [];
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"SplineCurve", e.points = r, e
				}
				return (0, y.default)(n, [{
					key: "getPoint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !==
							arguments[1] ? arguments[1] : new Ie,
							n = t,
							r = this.points,
							i = (r.length - 1) * e,
							a = Math.floor(i),
							o = i - a,
							s = r[0 === a ? a : a - 1],
							l = r[a],
							u = r[a > r.length - 2 ? r.length - 1 : a +
								1],
							c = r[a > r.length - 3 ? r.length - 1 : a +
								2];
						return n.set(Fl(o, s.x, l.x, u.x, c.x), Fl(o, s
							.y, l.y, u.y, c.y)), n
					}
				}, {
					key: "copy",
					value: function(e) {
						(0, h.default)((0, m.default)(n.prototype),
							"copy", this).call(this, e), this
						.points = [];
						for (var t = 0, r = e.points.length; t <
							r; t++) {
							var i = e.points[t];
							this.points.push(i.clone())
						}
						return this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						e.points = [];
						for (var t = 0, r = this.points.length; t <
							r; t++) {
							var i = this.points[t];
							e.points.push(i.toArray())
						}
						return e
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						(0, h.default)((0, m.default)(n.prototype),
							"fromJSON", this).call(this, e), this
							.points = [];
						for (var t = 0, r = e.points.length; t <
							r; t++) {
							var i = e.points[t];
							this.points.push((new Ie).fromArray(i))
						}
						return this
					}
				}]), n
			}(Rl);
			Yl.prototype.isSplineCurve = !0;
			var $l = Object.freeze({
					__proto__: null,
					ArcCurve: Pl,
					CatmullRomCurve3: zl,
					CubicBezierCurve: Gl,
					CubicBezierCurve3: Vl,
					EllipseCurve: Cl,
					LineCurve: Wl,
					LineCurve3: jl,
					QuadraticBezierCurve: ql,
					QuadraticBezierCurve3: Xl,
					SplineCurve: Yl
				}),
				Zl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"CurvePath", e.curves = [], e.autoClose = !1, e
					}
					return (0, y.default)(n, [{
						key: "add",
						value: function(e) {
							this.curves.push(e)
						}
					}, {
						key: "closePath",
						value: function() {
							var e = this.curves[0].getPoint(0),
								t = this.curves[this.curves.length - 1]
								.getPoint(1);
							e.equals(t) || this.curves.push(new Wl(t, e))
						}
					}, {
						key: "getPoint",
						value: function(e) {
							for (var t = e * this.getLength(), n = this
									.getCurveLengths(), r = 0; r < n
								.length;) {
								if (n[r] >= t) {
									var i = n[r] - t,
										a = this.curves[r],
										o = a.getLength(),
										s = 0 === o ? 0 : 1 - i / o;
									return a.getPointAt(s)
								}
								r++
							}
							return null
						}
					}, {
						key: "getLength",
						value: function() {
							var e = this.getCurveLengths();
							return e[e.length - 1]
						}
					}, {
						key: "updateArcLengths",
						value: function() {
							this.needsUpdate = !0, this.cacheLengths = null,
								this.getCurveLengths()
						}
					}, {
						key: "getCurveLengths",
						value: function() {
							if (this.cacheLengths && this.cacheLengths
								.length === this.curves.length) return this
								.cacheLengths;
							for (var e = [], t = 0, n = 0, r = this.curves
									.length; n < r; n++) t += this.curves[n]
								.getLength(), e.push(t);
							return this.cacheLengths = e, e
						}
					}, {
						key: "getSpacedPoints",
						value: function() {
							for (var e = arguments.length > 0 && void 0 !==
									arguments[0] ? arguments[0] : 40,
								t = [], n = 0; n <= e; n++) t.push(this
								.getPoint(n / e));
							return this.autoClose && t.push(t[0]), t
						}
					}, {
						key: "getPoints",
						value: function() {
							for (var e, t = arguments.length > 0 &&
									void 0 !== arguments[0] ? arguments[0] :
									12, n = [], r = 0, i = this.curves; r <
								i.length; r++)
								for (var a = i[r], o = a && a
										.isEllipseCurve ? 2 * t : a && (a
											.isLineCurve || a.isLineCurve3
											) ? 1 : a && a.isSplineCurve ?
										t * a.points.length : t, s = a
										.getPoints(o), l = 0; l < s
									.length; l++) {
									var u = s[l];
									e && e.equals(u) || (n.push(u), e = u)
								}
							return this.autoClose && n.length > 1 && !n[n
								.length - 1].equals(n[0]) && n.push(n[
								0]), n
						}
					}, {
						key: "copy",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"copy", this).call(this, e), this
							.curves = [];
							for (var t = 0, r = e.curves.length; t <
								r; t++) {
								var i = e.curves[t];
								this.curves.push(i.clone())
							}
							return this.autoClose = e.autoClose, this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							e.autoClose = this.autoClose, e.curves = [];
							for (var t = 0, r = this.curves.length; t <
								r; t++) {
								var i = this.curves[t];
								e.curves.push(i.toJSON())
							}
							return e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"fromJSON", this).call(this, e), this
								.autoClose = e.autoClose, this.curves = [];
							for (var t = 0, r = e.curves.length; t <
								r; t++) {
								var i = e.curves[t];
								this.curves.push((new $l[i.type]).fromJSON(
									i))
							}
							return this
						}
					}]), n
				}(Rl),
				Jl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this)).type = "Path", r
							.currentPoint = new Ie, e && r.setFromPoints(e), r
					}
					return (0, y.default)(n, [{
						key: "setFromPoints",
						value: function(e) {
							this.moveTo(e[0].x, e[0].y);
							for (var t = 1, n = e.length; t < n; t++) this
								.lineTo(e[t].x, e[t].y);
							return this
						}
					}, {
						key: "moveTo",
						value: function(e, t) {
							return this.currentPoint.set(e, t), this
						}
					}, {
						key: "lineTo",
						value: function(e, t) {
							var n = new Wl(this.currentPoint.clone(),
								new Ie(e, t));
							return this.curves.push(n), this.currentPoint
								.set(e, t), this
						}
					}, {
						key: "quadraticCurveTo",
						value: function(e, t, n, r) {
							var i = new ql(this.currentPoint.clone(),
								new Ie(e, t), new Ie(n, r));
							return this.curves.push(i), this.currentPoint
								.set(n, r), this
						}
					}, {
						key: "bezierCurveTo",
						value: function(e, t, n, r, i, a) {
							var o = new Gl(this.currentPoint.clone(),
								new Ie(e, t), new Ie(n, r), new Ie(i, a)
								);
							return this.curves.push(o), this.currentPoint
								.set(i, a), this
						}
					}, {
						key: "splineThru",
						value: function(e) {
							var t = [this.currentPoint.clone()].concat(e),
								n = new Yl(t);
							return this.curves.push(n), this.currentPoint
								.copy(e[e.length - 1]), this
						}
					}, {
						key: "arc",
						value: function(e, t, n, r, i, a) {
							var o = this.currentPoint.x,
								s = this.currentPoint.y;
							return this.absarc(e + o, t + s, n, r, i, a),
								this
						}
					}, {
						key: "absarc",
						value: function(e, t, n, r, i, a) {
							return this.absellipse(e, t, n, n, r, i, a),
								this
						}
					}, {
						key: "ellipse",
						value: function(e, t, n, r, i, a, o, s) {
							var l = this.currentPoint.x,
								u = this.currentPoint.y;
							return this.absellipse(e + l, t + u, n, r, i, a,
								o, s), this
						}
					}, {
						key: "absellipse",
						value: function(e, t, n, r, i, a, o, s) {
							var l = new Cl(e, t, n, r, i, a, o, s);
							if (this.curves.length > 0) {
								var u = l.getPoint(0);
								u.equals(this.currentPoint) || this.lineTo(u
									.x, u.y)
							}
							this.curves.push(l);
							var c = l.getPoint(1);
							return this.currentPoint.copy(c), this
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.currentPoint.copy(e.currentPoint),
								this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							return e.currentPoint = this.currentPoint
								.toArray(), e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
								.prototype), "fromJSON", this).call(
								this, e), this.currentPoint.fromArray(e
								.currentPoint), this
						}
					}]), n
				}(Zl),
				Ql = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this, e)).uuid = Te(), r
							.type = "Shape", r.holes = [], r
					}
					return (0, y.default)(n, [{
						key: "getPointsHoles",
						value: function(e) {
							for (var t = [], n = 0, r = this.holes
								.length; n < r; n++) t[n] = this.holes[n]
								.getPoints(e);
							return t
						}
					}, {
						key: "extractPoints",
						value: function(e) {
							return {
								shape: this.getPoints(e),
								holes: this.getPointsHoles(e)
							}
						}
					}, {
						key: "copy",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"copy", this).call(this, e), this
						.holes = [];
							for (var t = 0, r = e.holes.length; t <
								r; t++) {
								var i = e.holes[t];
								this.holes.push(i.clone())
							}
							return this
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this);
							e.uuid = this.uuid, e.holes = [];
							for (var t = 0, r = this.holes.length; t <
								r; t++) {
								var i = this.holes[t];
								e.holes.push(i.toJSON())
							}
							return e
						}
					}, {
						key: "fromJSON",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"fromJSON", this).call(this, e), this.uuid =
								e.uuid, this.holes = [];
							for (var t = 0, r = e.holes.length; t <
								r; t++) {
								var i = e.holes[t];
								this.holes.push((new Jl).fromJSON(i))
							}
							return this
						}
					}]), n
				}(Jl),
				Kl = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 1;
						return (0, g.default)(this, n), (r = t.call(this)).type = "Light", r
							.color = new yn(e), r.intensity = i, r
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.color.copy(e.color), this
								.intensity = e.intensity, this
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this,
								e);
							return t.object.color = this.color.getHex(), t
								.object.intensity = this.intensity,
								void 0 !== this.groundColor && (t.object
									.groundColor = this.groundColor.getHex()
									), void 0 !== this.distance && (t.object
									.distance = this.distance), void 0 !==
								this.angle && (t.object.angle = this.angle),
								void 0 !== this.decay && (t.object.decay =
									this.decay), void 0 !== this.penumbra &&
								(t.object.penumbra = this.penumbra),
								void 0 !== this.shadow && (t.object.shadow =
									this.shadow.toJSON()), t
						}
					}]), n
				}(Xt);
			Kl.prototype.isLight = !0;
			var eu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i) {
					var a;
					return (0, g.default)(this, n), (a = t.call(this, e, i)).type =
						"HemisphereLight", a.position.copy(Xt.DefaultUp), a
						.updateMatrix(), a.groundColor = new yn(r), a
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return Kl.prototype.copy.call(this, e), this
							.groundColor.copy(e.groundColor), this
					}
				}]), n
			}(Kl);
			eu.prototype.isHemisphereLight = !0;
			var tu = new wt,
				nu = new je,
				ru = new je,
				iu = function() {
					function e(t) {
						(0, g.default)(this, e), this.camera = t, this.bias = 0, this
							.normalBias = 0, this.radius = 1, this.mapSize = new Ie(512,
								512), this.map = null, this.mapPass = null, this.matrix =
							new wt, this.autoUpdate = !0, this.needsUpdate = !1, this
							._frustum = new wr, this._frameExtents = new Ie(1, 1), this
							._viewportCount = 1, this._viewports = [new He(0, 0, 1, 1)]
					}
					return (0, y.default)(e, [{
						key: "getViewportCount",
						value: function() {
							return this._viewportCount
						}
					}, {
						key: "getFrustum",
						value: function() {
							return this._frustum
						}
					}, {
						key: "updateMatrices",
						value: function(e) {
							var t = this.camera,
								n = this.matrix;
							nu.setFromMatrixPosition(e.matrixWorld), t
								.position.copy(nu), ru
								.setFromMatrixPosition(e.target
								.matrixWorld), t.lookAt(ru), t
								.updateMatrixWorld(), tu.multiplyMatrices(t
									.projectionMatrix, t.matrixWorldInverse
									), this._frustum
								.setFromProjectionMatrix(tu), n.set(.5, 0,
									0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0,
									0, 1), n.multiply(t.projectionMatrix), n
								.multiply(t.matrixWorldInverse)
						}
					}, {
						key: "getViewport",
						value: function(e) {
							return this._viewports[e]
						}
					}, {
						key: "getFrameExtents",
						value: function() {
							return this._frameExtents
						}
					}, {
						key: "dispose",
						value: function() {
							this.map && this.map.dispose(), this.mapPass &&
								this.mapPass.dispose()
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.camera = e.camera.clone(), this
								.bias = e.bias, this.radius = e.radius, this
								.mapSize.copy(e.mapSize), this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = {};
							return 0 !== this.bias && (e.bias = this.bias),
								0 !== this.normalBias && (e.normalBias =
									this.normalBias), 1 !== this.radius && (
									e.radius = this.radius), 512 === this
								.mapSize.x && 512 === this.mapSize.y || (e
									.mapSize = this.mapSize.toArray()), e
								.camera = this.camera.toJSON(!1).object,
								delete e.camera.matrix, e
						}
					}]), e
				}(),
				au = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this, new vr(50, 1, .5,
							500))).focus = 1, e
					}
					return (0, y.default)(n, [{
						key: "updateMatrices",
						value: function(e) {
							var t = this.camera,
								r = 2 * Se * e.angle * this.focus,
								i = this.mapSize.width / this.mapSize
								.height,
								a = e.distance || t.far;
							r === t.fov && i === t.aspect && a === t.far ||
								(t.fov = r, t.aspect = i, t.far = a, t
									.updateProjectionMatrix()), (0, h
									.default)((0, m.default)(n.prototype),
									"updateMatrices", this).call(this, e)
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.focus = e.focus, this
						}
					}]), n
				}(iu);
			au.prototype.isSpotLightShadow = !0;
			var ou = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
						arguments[2] : 0,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : Math.PI / 3,
						s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
							4] : 0,
						l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
							5] : 1;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"SpotLight", i.position.copy(Xt.DefaultUp), i.updateMatrix(), i
						.target = new Xt, i.distance = a, i.angle = o, i.penumbra = s, i
						.decay = l, i.shadow = new au, i
				}
				return (0, y.default)(n, [{
					key: "power",
					get: function() {
						return this.intensity * Math.PI
					},
					set: function(e) {
						this.intensity = e / Math.PI
					}
				}, {
					key: "dispose",
					value: function() {
						this.shadow.dispose()
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.distance = e.distance, this.angle =
							e.angle, this.penumbra = e.penumbra, this
							.decay = e.decay, this.target = e.target
							.clone(), this.shadow = e.shadow.clone(),
							this
					}
				}]), n
			}(Kl);
			ou.prototype.isSpotLight = !0;
			var su = new wt,
				lu = new je,
				uu = new je,
				cu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this, new vr(90, 1, .5,
								500)))._frameExtents = new Ie(4, 2), e._viewportCount = 6, e
							._viewports = [new He(2, 1, 1, 1), new He(0, 1, 1, 1), new He(3,
									1, 1, 1), new He(1, 1, 1, 1), new He(3, 0, 1, 1),
								new He(1, 0, 1, 1)
							], e._cubeDirections = [new je(1, 0, 0), new je(-1, 0, 0),
								new je(0, 0, 1), new je(0, 0, -1), new je(0, 1, 0), new je(
									0, -1, 0)
							], e._cubeUps = [new je(0, 1, 0), new je(0, 1, 0), new je(0, 1,
								0), new je(0, 1, 0), new je(0, 0, 1), new je(0, 0, -1)], e
					}
					return (0, y.default)(n, [{
						key: "updateMatrices",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0,
								n = this.camera,
								r = this.matrix,
								i = e.distance || n.far;
							i !== n.far && (n.far = i, n
									.updateProjectionMatrix()), lu
								.setFromMatrixPosition(e.matrixWorld), n
								.position.copy(lu), uu.copy(n.position), uu
								.add(this._cubeDirections[t]), n.up.copy(
									this._cubeUps[t]), n.lookAt(uu), n
								.updateMatrixWorld(), r.makeTranslation(-lu
									.x, -lu.y, -lu.z), su.multiplyMatrices(n
									.projectionMatrix, n.matrixWorldInverse
									), this._frustum
								.setFromProjectionMatrix(su)
						}
					}]), n
				}(iu);
			cu.prototype.isPointLightShadow = !0;
			var hu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
						arguments[2] : 0,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 1;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"PointLight", i.distance = a, i.decay = o, i.shadow = new cu, i
				}
				return (0, y.default)(n, [{
					key: "power",
					get: function() {
						return 4 * this.intensity * Math.PI
					},
					set: function(e) {
						this.intensity = e / (4 * Math.PI)
					}
				}, {
					key: "dispose",
					value: function() {
						this.shadow.dispose()
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.distance = e.distance, this.decay =
							e.decay, this.shadow = e.shadow.clone(),
							this
					}
				}]), n
			}(Kl);
			hu.prototype.isPointLight = !0;
			var du = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : -1,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1,
						a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
							2] : 1,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : -1,
						s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
							4] : .1,
						l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
							5] : 2e3;
					return (0, g.default)(this, n), (e = t.call(this)).type =
						"OrthographicCamera", e.zoom = 1, e.view = null, e.left = r, e
						.right = i, e.top = a, e.bottom = o, e.near = s, e.far = l, e
						.updateProjectionMatrix(), e
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e, t) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this, e,
								t), this.left = e.left, this.right = e
							.right, this.top = e.top, this.bottom = e
							.bottom, this.near = e.near, this.far = e
							.far, this.zoom = e.zoom, this.view =
							null === e.view ? null : Object.assign({}, e
								.view), this
					}
				}, {
					key: "setViewOffset",
					value: function(e, t, n, r, i, a) {
						null === this.view && (this.view = {
								enabled: !0,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							}), this.view.enabled = !0, this.view
							.fullWidth = e, this.view.fullHeight = t,
							this.view.offsetX = n, this.view.offsetY =
							r, this.view.width = i, this.view.height =
							a, this.updateProjectionMatrix()
					}
				}, {
					key: "clearViewOffset",
					value: function() {
						null !== this.view && (this.view.enabled = !1),
							this.updateProjectionMatrix()
					}
				}, {
					key: "updateProjectionMatrix",
					value: function() {
						var e = (this.right - this.left) / (2 * this
								.zoom),
							t = (this.top - this.bottom) / (2 * this
								.zoom),
							n = (this.right + this.left) / 2,
							r = (this.top + this.bottom) / 2,
							i = n - e,
							a = n + e,
							o = r + t,
							s = r - t;
						if (null !== this.view && this.view.enabled) {
							var l = (this.right - this.left) / this.view
								.fullWidth / this.zoom,
								u = (this.top - this.bottom) / this.view
								.fullHeight / this.zoom;
							a = (i += l * this.view.offsetX) + l * this
								.view.width, s = (o -= u * this.view
									.offsetY) - u * this.view.height
						}
						this.projectionMatrix.makeOrthographic(i, a, o,
								s, this.near, this.far), this
							.projectionMatrixInverse.copy(this
								.projectionMatrix).invert()
					}
				}, {
					key: "toJSON",
					value: function(e) {
						var t = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this,
							e);
						return t.object.zoom = this.zoom, t.object
							.left = this.left, t.object.right = this
							.right, t.object.top = this.top, t.object
							.bottom = this.bottom, t.object.near = this
							.near, t.object.far = this.far, null !==
							this.view && (t.object.view = Object
						.assign({}, this.view)), t
					}
				}]), n
			}(pr);
			du.prototype.isOrthographicCamera = !0;
			var fu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					return (0, g.default)(this, n), t.call(this, new du(-5, 5, 5, -5,
						.5, 500))
				}
				return n
			}(iu);
			fu.prototype.isDirectionalLightShadow = !0;
			var pu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"DirectionalLight", i.position.copy(Xt.DefaultUp), i
						.updateMatrix(), i.target = new Xt, i.shadow = new fu, i
				}
				return (0, y.default)(n, [{
					key: "dispose",
					value: function() {
						this.shadow.dispose()
					}
				}, {
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.target = e.target.clone(), this
							.shadow = e.shadow.clone(), this
					}
				}]), n
			}(Kl);
			pu.prototype.isDirectionalLight = !0;
			var vu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"AmbientLight", i
				}
				return n
			}(Kl);
			vu.prototype.isAmbientLight = !0;
			var mu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r) {
					var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
						arguments[2] : 10,
						o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
							3] : 10;
					return (0, g.default)(this, n), (i = t.call(this, e, r)).type =
						"RectAreaLight", i.width = a, i.height = o, i
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.width = e.width, this.height = e
							.height, this
					}
				}, {
					key: "toJSON",
					value: function(e) {
						var t = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this,
							e);
						return t.object.width = this.width, t.object
							.height = this.height, t
					}
				}]), n
			}(Kl);
			mu.prototype.isRectAreaLight = !0;
			var gu = function() {
				function e() {
					(0, g.default)(this, e), this.coefficients = [];
					for (var t = 0; t < 9; t++) this.coefficients.push(new je)
				}
				return (0, y.default)(e, [{
					key: "set",
					value: function(e) {
						for (var t = 0; t < 9; t++) this.coefficients[t]
							.copy(e[t]);
						return this
					}
				}, {
					key: "zero",
					value: function() {
						for (var e = 0; e < 9; e++) this.coefficients[e]
							.set(0, 0, 0);
						return this
					}
				}, {
					key: "getAt",
					value: function(e, t) {
						var n = e.x,
							r = e.y,
							i = e.z,
							a = this.coefficients;
						return t.copy(a[0]).multiplyScalar(.282095), t
							.addScaledVector(a[1], .488603 * r), t
							.addScaledVector(a[2], .488603 * i), t
							.addScaledVector(a[3], .488603 * n), t
							.addScaledVector(a[4], n * r * 1.092548), t
							.addScaledVector(a[5], r * i * 1.092548), t
							.addScaledVector(a[6], .315392 * (3 * i *
								i - 1)), t.addScaledVector(a[7], n * i *
								1.092548), t.addScaledVector(a[8],
								.546274 * (n * n - r * r)), t
					}
				}, {
					key: "getIrradianceAt",
					value: function(e, t) {
						var n = e.x,
							r = e.y,
							i = e.z,
							a = this.coefficients;
						return t.copy(a[0]).multiplyScalar(.886227), t
							.addScaledVector(a[1], 1.023328 * r), t
							.addScaledVector(a[2], 1.023328 * i), t
							.addScaledVector(a[3], 1.023328 * n), t
							.addScaledVector(a[4], .858086 * n * r), t
							.addScaledVector(a[5], .858086 * r * i), t
							.addScaledVector(a[6], .743125 * i * i -
								.247708), t.addScaledVector(a[7],
								.858086 * n * i), t.addScaledVector(a[
								8], .429043 * (n * n - r * r)), t
					}
				}, {
					key: "add",
					value: function(e) {
						for (var t = 0; t < 9; t++) this.coefficients[t]
							.add(e.coefficients[t]);
						return this
					}
				}, {
					key: "addScaledSH",
					value: function(e, t) {
						for (var n = 0; n < 9; n++) this.coefficients[n]
							.addScaledVector(e.coefficients[n], t);
						return this
					}
				}, {
					key: "scale",
					value: function(e) {
						for (var t = 0; t < 9; t++) this.coefficients[t]
							.multiplyScalar(e);
						return this
					}
				}, {
					key: "lerp",
					value: function(e, t) {
						for (var n = 0; n < 9; n++) this.coefficients[n]
							.lerp(e.coefficients[n], t);
						return this
					}
				}, {
					key: "equals",
					value: function(e) {
						for (var t = 0; t < 9; t++)
							if (!this.coefficients[t].equals(e
									.coefficients[t])) return !1;
						return !0
					}
				}, {
					key: "copy",
					value: function(e) {
						return this.set(e.coefficients)
					}
				}, {
					key: "clone",
					value: function() {
						return (new this.constructor).copy(this)
					}
				}, {
					key: "fromArray",
					value: function(e) {
						for (var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0, n =
								this.coefficients, r = 0; r < 9; r++) n[
							r].fromArray(e, t + 3 * r);
						return this
					}
				}, {
					key: "toArray",
					value: function() {
						for (var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : [], t =
								arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0, n =
								this.coefficients, r = 0; r < 9; r++) n[
							r].toArray(e, t + 3 * r);
						return e
					}
				}], [{
					key: "getBasisAt",
					value: function(e, t) {
						var n = e.x,
							r = e.y,
							i = e.z;
						t[0] = .282095, t[1] = .488603 * r, t[2] =
							.488603 * i, t[3] = .488603 * n, t[4] =
							1.092548 * n * r, t[5] = 1.092548 * r * i,
							t[6] = .315392 * (3 * i * i - 1), t[7] =
							1.092548 * n * i, t[8] = .546274 * (n * n -
								r * r)
					}
				}]), e
			}();
			gu.prototype.isSphericalHarmonics3 = !0;
			var yu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n() {
					var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
						arguments[0] : new gu,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 1;
					return (0, g.default)(this, n), (e = t.call(this, void 0, i)).sh =
						r, e
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.sh.copy(e.sh), this
					}
				}, {
					key: "fromJSON",
					value: function(e) {
						return this.intensity = e.intensity, this.sh
							.fromArray(e.sh), this
					}
				}, {
					key: "toJSON",
					value: function(e) {
						var t = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this,
							e);
						return t.object.sh = this.sh.toArray(), t
					}
				}]), n
			}(Kl);
			yu.prototype.isLightProbe = !0;
			var xu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this, e)).textures = {},
							r
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new Tl(i.manager);
							a.setPath(i.path), a.setRequestHeader(i
								.requestHeader), a.setWithCredentials(i
								.withCredentials), a.load(e, (function(
								n) {
								try {
									t(i.parse(JSON.parse(n)))
								} catch (t) {
									r ? r(t) : console.error(t),
										i.manager.itemError(e)
								}
							}), n, r)
						}
					}, {
						key: "parse",
						value: function(e) {
							var t = this.textures;

							function n(e) {
								return void 0 === t[e] && console.warn(
									"THREE.MaterialLoader: Undefined texture",
									e), t[e]
							}
							var r = new il[e.type];
							if (void 0 !== e.uuid && (r.uuid = e.uuid),
								void 0 !== e.name && (r.name = e.name),
								void 0 !== e.color && void 0 !== r.color &&
								r.color.setHex(e.color), void 0 !== e
								.roughness && (r.roughness = e.roughness),
								void 0 !== e.metalness && (r.metalness = e
									.metalness), void 0 !== e.sheen && (r
									.sheen = (new yn).setHex(e.sheen)),
								void 0 !== e.emissive && void 0 !== r
								.emissive && r.emissive.setHex(e.emissive),
								void 0 !== e.specular && void 0 !== r
								.specular && r.specular.setHex(e.specular),
								void 0 !== e.shininess && (r.shininess = e
									.shininess), void 0 !== e.clearcoat && (
									r.clearcoat = e.clearcoat), void 0 !== e
								.clearcoatRoughness && (r
									.clearcoatRoughness = e
									.clearcoatRoughness), void 0 !== e
								.transmission && (r.transmission = e
									.transmission), void 0 !== e
								.thickness && (r.thickness = e.thickness),
								void 0 !== e.attenuationDistance && (r
									.attenuationDistance = e
									.attenuationDistance), void 0 !== e
								.attenuationColor && void 0 !== r
								.attenuationColor && r.attenuationColor
								.setHex(e.attenuationColor), void 0 !== e
								.fog && (r.fog = e.fog), void 0 !== e
								.flatShading && (r.flatShading = e
									.flatShading), void 0 !== e.blending &&
								(r.blending = e.blending), void 0 !== e
								.combine && (r.combine = e.combine),
								void 0 !== e.side && (r.side = e.side),
								void 0 !== e.shadowSide && (r.shadowSide = e
									.shadowSide), void 0 !== e.opacity && (r
									.opacity = e.opacity), void 0 !== e
								.transparent && (r.transparent = e
									.transparent), void 0 !== e.alphaTest &&
								(r.alphaTest = e.alphaTest), void 0 !== e
								.depthTest && (r.depthTest = e.depthTest),
								void 0 !== e.depthWrite && (r.depthWrite = e
									.depthWrite), void 0 !== e.colorWrite &&
								(r.colorWrite = e.colorWrite), void 0 !== e
								.stencilWrite && (r.stencilWrite = e
									.stencilWrite), void 0 !== e
								.stencilWriteMask && (r.stencilWriteMask = e
									.stencilWriteMask), void 0 !== e
								.stencilFunc && (r.stencilFunc = e
									.stencilFunc), void 0 !== e
								.stencilRef && (r.stencilRef = e
								.stencilRef), void 0 !== e
								.stencilFuncMask && (r.stencilFuncMask = e
									.stencilFuncMask), void 0 !== e
								.stencilFail && (r.stencilFail = e
									.stencilFail), void 0 !== e
								.stencilZFail && (r.stencilZFail = e
									.stencilZFail), void 0 !== e
								.stencilZPass && (r.stencilZPass = e
									.stencilZPass), void 0 !== e
								.wireframe && (r.wireframe = e.wireframe),
								void 0 !== e.wireframeLinewidth && (r
									.wireframeLinewidth = e
									.wireframeLinewidth), void 0 !== e
								.wireframeLinecap && (r.wireframeLinecap = e
									.wireframeLinecap), void 0 !== e
								.wireframeLinejoin && (r.wireframeLinejoin =
									e.wireframeLinejoin), void 0 !== e
								.rotation && (r.rotation = e.rotation),
								1 !== e.linewidth && (r.linewidth = e
									.linewidth), void 0 !== e.dashSize && (r
									.dashSize = e.dashSize), void 0 !== e
								.gapSize && (r.gapSize = e.gapSize),
								void 0 !== e.scale && (r.scale = e.scale),
								void 0 !== e.polygonOffset && (r
									.polygonOffset = e.polygonOffset),
								void 0 !== e.polygonOffsetFactor && (r
									.polygonOffsetFactor = e
									.polygonOffsetFactor), void 0 !== e
								.polygonOffsetUnits && (r
									.polygonOffsetUnits = e
									.polygonOffsetUnits), void 0 !== e
								.morphTargets && (r.morphTargets = e
									.morphTargets), void 0 !== e
								.morphNormals && (r.morphNormals = e
									.morphNormals), void 0 !== e
								.dithering && (r.dithering = e.dithering),
								void 0 !== e.alphaToCoverage && (r
									.alphaToCoverage = e.alphaToCoverage),
								void 0 !== e.premultipliedAlpha && (r
									.premultipliedAlpha = e
									.premultipliedAlpha), void 0 !== e
								.vertexTangents && (r.vertexTangents = e
									.vertexTangents), void 0 !== e
								.visible && (r.visible = e.visible),
								void 0 !== e.toneMapped && (r.toneMapped = e
									.toneMapped), void 0 !== e.userData && (
									r.userData = e.userData), void 0 !== e
								.vertexColors && ("number" == typeof e
									.vertexColors ? r.vertexColors = e
									.vertexColors > 0 : r.vertexColors = e
									.vertexColors), void 0 !== e.uniforms)
								for (var i in e.uniforms) {
									var a = e.uniforms[i];
									switch (r.uniforms[i] = {}, a.type) {
										case "t":
											r.uniforms[i].value = n(a
											.value);
											break;
										case "c":
											r.uniforms[i].value = (new yn)
												.setHex(a.value);
											break;
										case "v2":
											r.uniforms[i].value = (new Ie)
												.fromArray(a.value);
											break;
										case "v3":
											r.uniforms[i].value = (new je)
												.fromArray(a.value);
											break;
										case "v4":
											r.uniforms[i].value = (new He)
												.fromArray(a.value);
											break;
										case "m3":
											r.uniforms[i].value = (new Ne)
												.fromArray(a.value);
											break;
										case "m4":
											r.uniforms[i].value = (new wt)
												.fromArray(a.value);
											break;
										default:
											r.uniforms[i].value = a.value
									}
								}
							if (void 0 !== e.defines && (r.defines = e
									.defines), void 0 !== e.vertexShader &&
								(r.vertexShader = e.vertexShader),
								void 0 !== e.fragmentShader && (r
									.fragmentShader = e.fragmentShader),
								void 0 !== e.extensions)
								for (var o in e.extensions) r.extensions[
									o] = e.extensions[o];
							if (void 0 !== e.shading && (r.flatShading =
									1 === e.shading), void 0 !== e.size && (
									r.size = e.size), void 0 !== e
								.sizeAttenuation && (r.sizeAttenuation = e
									.sizeAttenuation), void 0 !== e.map && (
									r.map = n(e.map)), void 0 !== e
								.matcap && (r.matcap = n(e.matcap)),
								void 0 !== e.alphaMap && (r.alphaMap = n(e
									.alphaMap)), void 0 !== e.bumpMap && (r
									.bumpMap = n(e.bumpMap)), void 0 !== e
								.bumpScale && (r.bumpScale = e.bumpScale),
								void 0 !== e.normalMap && (r.normalMap = n(e
									.normalMap)), void 0 !== e
								.normalMapType && (r.normalMapType = e
									.normalMapType), void 0 !== e
								.normalScale) {
								var s = e.normalScale;
								!1 === Array.isArray(s) && (s = [s, s]), r
									.normalScale = (new Ie).fromArray(s)
							}
							return void 0 !== e.displacementMap && (r
									.displacementMap = n(e.displacementMap)
									), void 0 !== e.displacementScale && (r
									.displacementScale = e.displacementScale
									), void 0 !== e.displacementBias && (r
									.displacementBias = e.displacementBias),
								void 0 !== e.roughnessMap && (r
									.roughnessMap = n(e.roughnessMap)),
								void 0 !== e.metalnessMap && (r
									.metalnessMap = n(e.metalnessMap)),
								void 0 !== e.emissiveMap && (r.emissiveMap =
									n(e.emissiveMap)), void 0 !== e
								.emissiveIntensity && (r.emissiveIntensity =
									e.emissiveIntensity), void 0 !== e
								.specularMap && (r.specularMap = n(e
									.specularMap)), void 0 !== e.envMap && (
									r.envMap = n(e.envMap)), void 0 !== e
								.envMapIntensity && (r.envMapIntensity = e
									.envMapIntensity), void 0 !== e
								.reflectivity && (r.reflectivity = e
									.reflectivity), void 0 !== e
								.refractionRatio && (r.refractionRatio = e
									.refractionRatio), void 0 !== e
								.lightMap && (r.lightMap = n(e.lightMap)),
								void 0 !== e.lightMapIntensity && (r
									.lightMapIntensity = e.lightMapIntensity
									), void 0 !== e.aoMap && (r.aoMap = n(e
									.aoMap)), void 0 !== e.aoMapIntensity &&
								(r.aoMapIntensity = e.aoMapIntensity),
								void 0 !== e.gradientMap && (r.gradientMap =
									n(e.gradientMap)), void 0 !== e
								.clearcoatMap && (r.clearcoatMap = n(e
									.clearcoatMap)), void 0 !== e
								.clearcoatRoughnessMap && (r
									.clearcoatRoughnessMap = n(e
										.clearcoatRoughnessMap)), void 0 !==
								e.clearcoatNormalMap && (r
									.clearcoatNormalMap = n(e
										.clearcoatNormalMap)), void 0 !== e
								.clearcoatNormalScale && (r
									.clearcoatNormalScale = (new Ie)
									.fromArray(e.clearcoatNormalScale)),
								void 0 !== e.transmissionMap && (r
									.transmissionMap = n(e.transmissionMap)
									), void 0 !== e.thicknessMap && (r
									.thicknessMap = n(e.thicknessMap)), r
						}
					}, {
						key: "setTextures",
						value: function(e) {
							return this.textures = e, this
						}
					}]), n
				}(Ml),
				_u = function() {
					function e() {
						(0, g.default)(this, e)
					}
					return (0, y.default)(e, null, [{
						key: "decodeText",
						value: function(e) {
							if ("undefined" != typeof TextDecoder) return (
								new TextDecoder).decode(e);
							for (var t = "", n = 0, r = e.length; n <
								r; n++) t += String.fromCharCode(e[n]);
							try {
								return decodeURIComponent(escape(t))
							} catch (e) {
								return t
							}
						}
					}, {
						key: "extractUrlBase",
						value: function(e) {
							var t = e.lastIndexOf("/");
							return -1 === t ? "./" : e.substr(0, t + 1)
						}
					}]), e
				}(),
				bu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"InstancedBufferGeometry", e.instanceCount = 1 / 0, e
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.instanceCount = e.instanceCount,
								this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "toJSON",
						value: function() {
							var e = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this,
								this);
							return e.instanceCount = this.instanceCount, e
								.isInstancedBufferGeometry = !0, e
						}
					}]), n
				}(Vn);
			bu.prototype.isInstancedBufferGeometry = !0;
			var wu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e, r, i, a) {
					var o;
					return (0, g.default)(this, n), "number" == typeof i && (a = i,
							i = !1, console.error(
								"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
								)), (o = t.call(this, e, r, i)).meshPerAttribute = a ||
						1, o
				}
				return (0, y.default)(n, [{
					key: "copy",
					value: function(e) {
						return (0, h.default)((0, m.default)(n
								.prototype), "copy", this).call(this,
							e), this.meshPerAttribute = e
							.meshPerAttribute, this
					}
				}, {
					key: "toJSON",
					value: function() {
						var e = (0, h.default)((0, m.default)(n
							.prototype), "toJSON", this).call(this);
						return e.meshPerAttribute = this
							.meshPerAttribute, e
							.isInstancedBufferAttribute = !0, e
					}
				}]), n
			}(wn);
			wu.prototype.isInstancedBufferAttribute = !0;
			var Mu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new Tl(i.manager);
							a.setPath(i.path), a.setRequestHeader(i
								.requestHeader), a.setWithCredentials(i
								.withCredentials), a.load(e, (function(
								n) {
								try {
									t(i.parse(JSON.parse(n)))
								} catch (t) {
									r ? r(t) : console.error(t),
										i.manager.itemError(e)
								}
							}), n, r)
						}
					}, {
						key: "parse",
						value: function(e) {
							var t = {},
								n = {};

							function r(e, r) {
								if (void 0 !== t[r]) return t[r];
								var i = e.interleavedBuffers[r],
									a = function(e, t) {
										if (void 0 !== n[t]) return n[t];
										var r = e.arrayBuffers[t],
											i = new Uint32Array(r).buffer;
										return n[t] = i, i
									}(e, i.buffer),
									o = Nn(i.type, a),
									s = new Ga(o, i.stride);
								return s.uuid = i.uuid, t[r] = s, s
							}
							var i = e.isInstancedBufferGeometry ? new bu :
								new Vn,
								a = e.data.index;
							if (void 0 !== a) {
								var o = Nn(a.type, a.array);
								i.setIndex(new wn(o, 1))
							}
							var s = e.data.attributes;
							for (var l in s) {
								var u = s[l],
									c = void 0;
								if (u.isInterleavedBufferAttribute) {
									var h = r(e.data, u.data);
									c = new Wa(h, u.itemSize, u.offset, u
										.normalized)
								} else {
									var d = Nn(u.type, u.array);
									c = new(u.isInstancedBufferAttribute ?
										wu : wn)(d, u.itemSize, u
										.normalized)
								}
								void 0 !== u.name && (c.name = u.name),
									void 0 !== u.usage && c.setUsage(u
										.usage), void 0 !== u.updateRange &&
									(c.updateRange.offset = u.updateRange
										.offset, c.updateRange.count = u
										.updateRange.count), i.setAttribute(
										l, c)
							}
							var f = e.data.morphAttributes;
							if (f)
								for (var p in f) {
									for (var v = f[p], m = [], g = 0, y = v
											.length; g < y; g++) {
										var x = v[g],
											_ = void 0;
										if (x
											.isInterleavedBufferAttribute) {
											var b = r(e.data, x.data);
											_ = new Wa(b, x.itemSize, x
												.offset, x.normalized)
										} else {
											var w = Nn(x.type, x.array);
											_ = new wn(w, x.itemSize, x
												.normalized)
										}
										void 0 !== x.name && (_.name = x
											.name), m.push(_)
									}
									i.morphAttributes[p] = m
								}
							e.data.morphTargetsRelative && (i
								.morphTargetsRelative = !0);
							var M = e.data.groups || e.data.drawcalls || e
								.data.offsets;
							if (void 0 !== M)
								for (var S = 0, T = M.length; S !== T; ++
									S) {
									var E = M[S];
									i.addGroup(E.start, E.count, E
										.materialIndex)
								}
							var A = e.data.boundingSphere;
							if (void 0 !== A) {
								var L = new je;
								void 0 !== A.center && L.fromArray(A
									.center), i.boundingSphere = new ft(L, A
										.radius)
							}
							return e.name && (i.name = e.name), e
								.userData && (i.userData = e.userData), i
						}
					}]), n
				}(Ml),
				Su = {
					UVMapping: i,
					CubeReflectionMapping: a,
					CubeRefractionMapping: o,
					EquirectangularReflectionMapping: s,
					EquirectangularRefractionMapping: x,
					CubeUVReflectionMapping: b,
					CubeUVRefractionMapping: S
				},
				Tu = {
					RepeatWrapping: T,
					ClampToEdgeWrapping: E,
					MirroredRepeatWrapping: A
				},
				Eu = {
					NearestFilter: L,
					NearestMipmapNearestFilter: k,
					NearestMipmapLinearFilter: R,
					LinearFilter: C,
					LinearMipmapNearestFilter: P,
					LinearMipmapLinearFilter: I
				},
				Au = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), r = t.call(this, e), "undefined" ==
							typeof createImageBitmap && console.warn(
								"THREE.ImageBitmapLoader: createImageBitmap() not supported."
								), "undefined" == typeof fetch && console.warn(
								"THREE.ImageBitmapLoader: fetch() not supported."), r
							.options = {
								premultiplyAlpha: "none"
							}, r
					}
					return (0, y.default)(n, [{
						key: "setOptions",
						value: function(e) {
							return this.options = e, this
						}
					}, {
						key: "load",
						value: function(e, t, n, r) {
							void 0 === e && (e = ""), void 0 !== this
								.path && (e = this.path + e), e = this
								.manager.resolveURL(e);
							var i = this,
								a = _l.get(e);
							if (void 0 !== a) return i.manager.itemStart(e),
								setTimeout((function() {
									t && t(a), i.manager
										.itemEnd(e)
								}), 0), a;
							var o = {};
							o.credentials = "anonymous" === this
								.crossOrigin ? "same-origin" : "include", o
								.headers = this.requestHeader, fetch(e, o)
								.then((function(e) {
									return e.blob()
								})).then((function(e) {
									return createImageBitmap(e,
										Object.assign(i
										.options, {
											colorSpaceConversion: "none"
										}))
								})).then((function(n) {
									_l.add(e, n), t && t(n), i
										.manager.itemEnd(e)
								})).catch((function(t) {
									r && r(t), i.manager.itemError(
										e), i.manager.itemEnd(e)
								})), i.manager.itemStart(e)
						}
					}]), n
				}(Ml);
			Au.prototype.isImageBitmapLoader = !0;
			var Lu, ku = function() {
					function e() {
						(0, g.default)(this, e), this.type = "ShapePath", this.color =
							new yn, this.subPaths = [], this.currentPath = null
					}
					return (0, y.default)(e, [{
						key: "moveTo",
						value: function(e, t) {
							return this.currentPath = new Jl, this.subPaths
								.push(this.currentPath), this.currentPath
								.moveTo(e, t), this
						}
					}, {
						key: "lineTo",
						value: function(e, t) {
							return this.currentPath.lineTo(e, t), this
						}
					}, {
						key: "quadraticCurveTo",
						value: function(e, t, n, r) {
							return this.currentPath.quadraticCurveTo(e, t,
								n, r), this
						}
					}, {
						key: "bezierCurveTo",
						value: function(e, t, n, r, i, a) {
							return this.currentPath.bezierCurveTo(e, t, n,
								r, i, a), this
						}
					}, {
						key: "splineThru",
						value: function(e) {
							return this.currentPath.splineThru(e), this
						}
					}, {
						key: "toShapes",
						value: function(e, t) {
							function n(e) {
								for (var t = [], n = 0, r = e.length; n <
									r; n++) {
									var i = e[n],
										a = new Ql;
									a.curves = i.curves, t.push(a)
								}
								return t
							}

							function r(e, t) {
								for (var n = t.length, r = !1, i = n - 1,
										a = 0; a < n; i = a++) {
									var o = t[i],
										s = t[a],
										l = s.x - o.x,
										u = s.y - o.y;
									if (Math.abs(u) > Number.EPSILON) {
										if (u < 0 && (o = t[a], l = -l, s =
												t[i], u = -u), e.y < o.y ||
											e.y > s.y) continue;
										if (e.y === o.y) {
											if (e.x === o.x) return !0
										} else {
											var c = u * (e.x - o.x) - l * (e
												.y - o.y);
											if (0 === c) return !0;
											if (c < 0) continue;
											r = !r
										}
									} else {
										if (e.y !== o.y) continue;
										if (s.x <= e.x && e.x <= o.x || o
											.x <= e.x && e.x <= s.x)
										return !0
									}
								}
								return r
							}
							var i, a, o, s = ks.isClockWise,
								l = this.subPaths;
							if (0 === l.length) return [];
							if (!0 === t) return n(l);
							var u = [];
							if (1 === l.length) return a = l[0], (o =
									new Ql).curves = a.curves, u.push(
								o), u;
							var c = !s(l[0].getPoints());
							c = e ? !c : c;
							var h, d, f = [],
								p = [],
								v = [],
								m = 0;
							p[m] = void 0, v[m] = [];
							for (var g = 0, y = l.length; g < y; g++) i = s(
								h = (a = l[g]).getPoints()), (i = e ? !
								i : i) ? (!c && p[m] && m++, p[m] = {
									s: new Ql,
									p: h
								}, p[m].s.curves = a.curves, c && m++,
								v[m] = []) : v[m].push({
								h: a,
								p: h[0]
							});
							if (!p[0]) return n(l);
							if (p.length > 1) {
								for (var x = !1, _ = [], b = 0, w = p
									.length; b < w; b++) f[b] = [];
								for (var M = 0, S = p.length; M < S; M++)
									for (var T = v[M], E = 0; E < T
										.length; E++) {
										for (var A = T[E], L = !0, k =
											0; k < p.length; k++) r(A.p, p[
											k].p) && (M !== k && _
									.push({
											froms: M,
											tos: k,
											hole: E
										}), L ? (L = !1, f[k].push(
											A)) : x = !0);
										L && f[M].push(A)
									}
								_.length > 0 && (x || (v = f))
							}
							for (var R = 0, C = p.length; R < C; R++) {
								o = p[R].s, u.push(o);
								for (var P = 0, I = (d = v[R]).length; P <
									I; P++) o.holes.push(d[P].h)
							}
							return u
						}
					}]), e
				}(),
				Ru = function() {
					function e(t) {
						(0, g.default)(this, e), this.type = "Font", this.data = t
					}
					return (0, y.default)(e, [{
						key: "generateShapes",
						value: function(e) {
							for (var t = arguments.length > 1 && void 0 !==
									arguments[1] ? arguments[1] : 100,
									n = [], r = function(e, t, n) {
										for (var r = Array.from(e), i = t /
												n.resolution, a = (n
													.boundingBox.yMax - n
													.boundingBox.yMin + n
													.underlineThickness) *
												i, o = [], s = 0, l = 0, u =
												0; u < r.length; u++) {
											var c = r[u];
											if ("\n" === c) s = 0, l -= a;
											else {
												var h = Cu(c, i, s, l, n);
												s += h.offsetX, o.push(h
													.path)
											}
										}
										return o
									}(e, t, this.data), i = 0, a = r
									.length; i < a; i++) Array.prototype
								.push.apply(n, r[i].toShapes());
							return n
						}
					}]), e
				}();

			function Cu(e, t, n, r, i) {
				var a = i.glyphs[e] || i.glyphs["?"];
				if (a) {
					var o, s, l, u, c, h, d, f, p = new ku;
					if (a.o)
						for (var v = a._cachedOutline || (a._cachedOutline = a.o.split(
								" ")), m = 0, g = v.length; m < g;) switch (v[m++]) {
							case "m":
								o = v[m++] * t + n, s = v[m++] * t + r, p.moveTo(o, s);
								break;
							case "l":
								o = v[m++] * t + n, s = v[m++] * t + r, p.lineTo(o, s);
								break;
							case "q":
								l = v[m++] * t + n, u = v[m++] * t + r, c = v[m++] * t +
									n, h = v[m++] * t + r, p.quadraticCurveTo(c, h, l,
										u);
								break;
							case "b":
								l = v[m++] * t + n, u = v[m++] * t + r, c = v[m++] * t +
									n, h = v[m++] * t + r, d = v[m++] * t + n, f = v[
										m++] * t + r, p.bezierCurveTo(c, h, d, f, l, u)
						}
					return {
						offsetX: a.ha * t,
						path: p
					}
				}
				console.error('THREE.Font: character "' + e +
					'" does not exists in font family ' + i.familyName + ".")
			}
			Ru.prototype.isFont = !0;
			var Pu = {
					getContext: function() {
						return void 0 === Lu && (Lu = new(window.AudioContext || window
							.webkitAudioContext)), Lu
					},
					setContext: function(e) {
						Lu = e
					}
				},
				Iu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new Tl(this.manager);
							a.setResponseType("arraybuffer"), a.setPath(this
								.path), a.setRequestHeader(this
								.requestHeader), a.setWithCredentials(
								this.withCredentials), a.load(e, (
								function(n) {
									try {
										var a = n.slice(0);
										Pu.getContext()
											.decodeAudioData(a, (
												function(e) {
													t(e)
												}))
									} catch (t) {
										r ? r(t) : console.error(t),
											i.manager.itemError(e)
									}
								}), n, r)
						}
					}]), n
				}(Ml),
				Du = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
							arguments[2] : 1;
						(0, g.default)(this, n), i = t.call(this, void 0, a);
						var o = (new yn).set(e),
							s = (new yn).set(r),
							l = new je(o.r, o.g, o.b),
							u = new je(s.r, s.g, s.b),
							c = Math.sqrt(Math.PI),
							h = c * Math.sqrt(.75);
						return i.sh.coefficients[0].copy(l).add(u).multiplyScalar(c), i.sh
							.coefficients[1].copy(l).sub(u).multiplyScalar(h), i
					}
					return n
				}(yu);
			Du.prototype.isHemisphereLightProbe = !0;
			var Nu = function(e) {
				(0, p.default)(n, e);
				var t = M(n);

				function n(e) {
					var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
						arguments[1] : 1;
					(0, g.default)(this, n), r = t.call(this, void 0, i);
					var a = (new yn).set(e);
					return r.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 *
						Math.sqrt(Math.PI)), r
				}
				return n
			}(yu);
			Nu.prototype.isAmbientLightProbe = !0;
			var Ou = new wt,
				Bu = new wt,
				zu = function() {
					function e() {
						var t = !(arguments.length > 0 && void 0 !== arguments[0]) ||
							arguments[0];
						(0, g.default)(this, e), this.autoStart = t, this.startTime = 0,
							this.oldTime = 0, this.elapsedTime = 0, this.running = !1
					}
					return (0, y.default)(e, [{
						key: "start",
						value: function() {
							this.startTime = Fu(), this.oldTime = this
								.startTime, this.elapsedTime = 0, this
								.running = !0
						}
					}, {
						key: "stop",
						value: function() {
							this.getElapsedTime(), this.running = !1, this
								.autoStart = !1
						}
					}, {
						key: "getElapsedTime",
						value: function() {
							return this.getDelta(), this.elapsedTime
						}
					}, {
						key: "getDelta",
						value: function() {
							var e = 0;
							if (this.autoStart && !this.running) return this
								.start(), 0;
							if (this.running) {
								var t = Fu();
								e = (t - this.oldTime) / 1e3, this.oldTime =
									t, this.elapsedTime += e
							}
							return e
						}
					}]), e
				}();

			function Fu() {
				return ("undefined" == typeof performance ? Date : performance).now()
			}
			var Hu = new je,
				Uu = new We,
				Gu = new je,
				Vu = new je,
				Wu = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this)).type = "Audio", r
							.listener = e, r.context = e.context, r.gain = r.context
							.createGain(), r.gain.connect(e.getInput()), r.autoplay = !1, r
							.buffer = null, r.detune = 0, r.loop = !1, r.loopStart = 0, r
							.loopEnd = 0, r.offset = 0, r.duration = void 0, r
							.playbackRate = 1, r.isPlaying = !1, r.hasPlaybackControl = !0,
							r.source = null, r.sourceType = "empty", r._startedAt = 0, r
							._progress = 0, r._connected = !1, r.filters = [], r
					}
					return (0, y.default)(n, [{
						key: "getOutput",
						value: function() {
							return this.gain
						}
					}, {
						key: "setNodeSource",
						value: function(e) {
							return this.hasPlaybackControl = !1, this
								.sourceType = "audioNode", this.source = e,
								this.connect(), this
						}
					}, {
						key: "setMediaElementSource",
						value: function(e) {
							return this.hasPlaybackControl = !1, this
								.sourceType = "mediaNode", this.source =
								this.context.createMediaElementSource(e),
								this.connect(), this
						}
					}, {
						key: "setMediaStreamSource",
						value: function(e) {
							return this.hasPlaybackControl = !1, this
								.sourceType = "mediaStreamNode", this
								.source = this.context
								.createMediaStreamSource(e), this.connect(),
								this
						}
					}, {
						key: "setBuffer",
						value: function(e) {
							return this.buffer = e, this.sourceType =
								"buffer", this.autoplay && this.play(), this
						}
					}, {
						key: "play",
						value: function() {
							var e = arguments.length > 0 && void 0 !==
								arguments[0] ? arguments[0] : 0;
							if (!0 !== this.isPlaying) {
								if (!1 !== this.hasPlaybackControl) {
									this._startedAt = this.context
										.currentTime + e;
									var t = this.context
									.createBufferSource();
									return t.buffer = this.buffer, t.loop =
										this.loop, t.loopStart = this
										.loopStart, t.loopEnd = this
										.loopEnd, t.onended = this.onEnded
										.bind(this), t.start(this
											._startedAt, this._progress +
											this.offset, this.duration),
										this.isPlaying = !0, this.source =
										t, this.setDetune(this.detune), this
										.setPlaybackRate(this.playbackRate),
										this.connect()
								}
								console.warn(
									"THREE.Audio: this Audio has no playback control."
									)
							} else console.warn(
								"THREE.Audio: Audio is already playing."
								)
						}
					}, {
						key: "pause",
						value: function() {
							if (!1 !== this.hasPlaybackControl) return !
								0 === this.isPlaying && (this
									._progress += Math.max(this.context
										.currentTime - this._startedAt,
										0) * this.playbackRate, !0 ===
									this.loop && (this._progress = this
										._progress % (this.duration ||
											this.buffer.duration)), this
									.source.stop(), this.source
									.onended = null, this.isPlaying = !1
									), this;
							console.warn(
								"THREE.Audio: this Audio has no playback control."
								)
						}
					}, {
						key: "stop",
						value: function() {
							if (!1 !== this.hasPlaybackControl) return this
								._progress = 0, this.source.stop(), this
								.source.onended = null, this
								.isPlaying = !1, this;
							console.warn(
								"THREE.Audio: this Audio has no playback control."
								)
						}
					}, {
						key: "connect",
						value: function() {
							if (this.filters.length > 0) {
								this.source.connect(this.filters[0]);
								for (var e = 1, t = this.filters.length; e <
									t; e++) this.filters[e - 1].connect(this
									.filters[e]);
								this.filters[this.filters.length - 1]
									.connect(this.getOutput())
							} else this.source.connect(this.getOutput());
							return this._connected = !0, this
						}
					}, {
						key: "disconnect",
						value: function() {
							if (this.filters.length > 0) {
								this.source.disconnect(this.filters[0]);
								for (var e = 1, t = this.filters.length; e <
									t; e++) this.filters[e - 1].disconnect(
									this.filters[e]);
								this.filters[this.filters.length - 1]
									.disconnect(this.getOutput())
							} else this.source.disconnect(this.getOutput());
							return this._connected = !1, this
						}
					}, {
						key: "getFilters",
						value: function() {
							return this.filters
						}
					}, {
						key: "setFilters",
						value: function(e) {
							return e || (e = []), !0 === this._connected ? (
									this.disconnect(), this.filters = e
									.slice(), this.connect()) : this
								.filters = e.slice(), this
						}
					}, {
						key: "setDetune",
						value: function(e) {
							if (this.detune = e, void 0 !== this.source
								.detune) return !0 === this.isPlaying &&
								this.source.detune.setTargetAtTime(this
									.detune, this.context.currentTime,
									.01), this
						}
					}, {
						key: "getDetune",
						value: function() {
							return this.detune
						}
					}, {
						key: "getFilter",
						value: function() {
							return this.getFilters()[0]
						}
					}, {
						key: "setFilter",
						value: function(e) {
							return this.setFilters(e ? [e] : [])
						}
					}, {
						key: "setPlaybackRate",
						value: function(e) {
							if (!1 !== this.hasPlaybackControl) return this
								.playbackRate = e, !0 === this
								.isPlaying && this.source.playbackRate
								.setTargetAtTime(this.playbackRate, this
									.context.currentTime, .01), this;
							console.warn(
								"THREE.Audio: this Audio has no playback control."
								)
						}
					}, {
						key: "getPlaybackRate",
						value: function() {
							return this.playbackRate
						}
					}, {
						key: "onEnded",
						value: function() {
							this.isPlaying = !1
						}
					}, {
						key: "getLoop",
						value: function() {
							return !1 === this.hasPlaybackControl ? (console
								.warn(
									"THREE.Audio: this Audio has no playback control."
									), !1) : this.loop
						}
					}, {
						key: "setLoop",
						value: function(e) {
							if (!1 !== this.hasPlaybackControl) return this
								.loop = e, !0 === this.isPlaying && (
									this.source.loop = this.loop), this;
							console.warn(
								"THREE.Audio: this Audio has no playback control."
								)
						}
					}, {
						key: "setLoopStart",
						value: function(e) {
							return this.loopStart = e, this
						}
					}, {
						key: "setLoopEnd",
						value: function(e) {
							return this.loopEnd = e, this
						}
					}, {
						key: "getVolume",
						value: function() {
							return this.gain.gain.value
						}
					}, {
						key: "setVolume",
						value: function(e) {
							return this.gain.gain.setTargetAtTime(e, this
								.context.currentTime, .01), this
						}
					}]), n
				}(Xt),
				ju = new je,
				qu = new We,
				Xu = new je,
				Yu = new je,
				$u = function() {
					function e(t) {
						var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
							1] : 2048;
						(0, g.default)(this, e), this.analyser = t.context.createAnalyser(),
							this.analyser.fftSize = n, this.data = new Uint8Array(this
								.analyser.frequencyBinCount), t.getOutput().connect(this
								.analyser)
					}
					return (0, y.default)(e, [{
						key: "getFrequencyData",
						value: function() {
							return this.analyser.getByteFrequencyData(this
								.data), this.data
						}
					}, {
						key: "getAverageFrequency",
						value: function() {
							for (var e = 0, t = this.getFrequencyData(), n =
									0; n < t.length; n++) e += t[n];
							return e / t.length
						}
					}]), e
				}(),
				Zu = function() {
					function e(t, n, r) {
						var i, a, o;
						switch ((0, g.default)(this, e), this.binding = t, this.valueSize =
							r, n) {
							case "quaternion":
								i = this._slerp, a = this._slerpAdditive, o = this
									._setAdditiveIdentityQuaternion, this.buffer =
									new Float64Array(6 * r), this._workIndex = 5;
								break;
							case "string":
							case "bool":
								i = this._select, a = this._select, o = this
									._setAdditiveIdentityOther, this.buffer = new Array(5 *
										r);
								break;
							default:
								i = this._lerp, a = this._lerpAdditive, o = this
									._setAdditiveIdentityNumeric, this.buffer =
									new Float64Array(5 * r)
						}
						this._mixBufferRegion = i, this._mixBufferRegionAdditive = a, this
							._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this
							.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this
							.useCount = 0, this.referenceCount = 0
					}
					return (0, y.default)(e, [{
						key: "accumulate",
						value: function(e, t) {
							var n = this.buffer,
								r = this.valueSize,
								i = e * r + r,
								a = this.cumulativeWeight;
							if (0 === a) {
								for (var o = 0; o !== r; ++o) n[i + o] = n[
									o];
								a = t
							} else {
								var s = t / (a += t);
								this._mixBufferRegion(n, i, 0, s, r)
							}
							this.cumulativeWeight = a
						}
					}, {
						key: "accumulateAdditive",
						value: function(e) {
							var t = this.buffer,
								n = this.valueSize,
								r = n * this._addIndex;
							0 === this.cumulativeWeightAdditive && this
								._setIdentity(), this
								._mixBufferRegionAdditive(t, r, 0, e, n),
								this.cumulativeWeightAdditive += e
						}
					}, {
						key: "apply",
						value: function(e) {
							var t = this.valueSize,
								n = this.buffer,
								r = e * t + t,
								i = this.cumulativeWeight,
								a = this.cumulativeWeightAdditive,
								o = this.binding;
							if (this.cumulativeWeight = 0, this
								.cumulativeWeightAdditive = 0, i < 1) {
								var s = t * this._origIndex;
								this._mixBufferRegion(n, r, s, 1 - i, t)
							}
							a > 0 && this._mixBufferRegionAdditive(n, r,
								this._addIndex * t, 1, t);
							for (var l = t, u = t + t; l !== u; ++l)
								if (n[l] !== n[l + t]) {
									o.setValue(n, r);
									break
								}
						}
					}, {
						key: "saveOriginalState",
						value: function() {
							var e = this.binding,
								t = this.buffer,
								n = this.valueSize,
								r = n * this._origIndex;
							e.getValue(t, r);
							for (var i = n, a = r; i !== a; ++i) t[i] = t[
								r + i % n];
							this._setIdentity(), this.cumulativeWeight = 0,
								this.cumulativeWeightAdditive = 0
						}
					}, {
						key: "restoreOriginalState",
						value: function() {
							var e = 3 * this.valueSize;
							this.binding.setValue(this.buffer, e)
						}
					}, {
						key: "_setAdditiveIdentityNumeric",
						value: function() {
							for (var e = this._addIndex * this.valueSize,
									t = e + this.valueSize, n = e; n <
								t; n++) this.buffer[n] = 0
						}
					}, {
						key: "_setAdditiveIdentityQuaternion",
						value: function() {
							this._setAdditiveIdentityNumeric(), this.buffer[
								this._addIndex * this.valueSize + 3] = 1
						}
					}, {
						key: "_setAdditiveIdentityOther",
						value: function() {
							for (var e = this._origIndex * this.valueSize,
									t = this._addIndex * this.valueSize, n =
									0; n < this.valueSize; n++) this.buffer[
								t + n] = this.buffer[e + n]
						}
					}, {
						key: "_select",
						value: function(e, t, n, r, i) {
							if (r >= .5)
								for (var a = 0; a !== i; ++a) e[t + a] = e[
									n + a]
						}
					}, {
						key: "_slerp",
						value: function(e, t, n, r) {
							We.slerpFlat(e, t, e, t, e, n, r)
						}
					}, {
						key: "_slerpAdditive",
						value: function(e, t, n, r, i) {
							var a = this._workIndex * i;
							We.multiplyQuaternionsFlat(e, a, e, t, e, n), We
								.slerpFlat(e, t, e, t, e, a, r)
						}
					}, {
						key: "_lerp",
						value: function(e, t, n, r, i) {
							for (var a = 1 - r, o = 0; o !== i; ++o) {
								var s = t + o;
								e[s] = e[s] * a + e[n + o] * r
							}
						}
					}, {
						key: "_lerpAdditive",
						value: function(e, t, n, r, i) {
							for (var a = 0; a !== i; ++a) {
								var o = t + a;
								e[o] = e[o] + e[n + a] * r
							}
						}
					}]), e
				}(),
				Ju = new RegExp("[\\[\\]\\.:\\/]", "g"),
				Qu = "[^\\[\\]\\.:\\/]",
				Ku = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
				ec = /((?:WC+[\/:])*)/.source.replace("WC", Qu),
				tc = /(WCOD+)?/.source.replace("WCOD", Ku),
				nc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Qu),
				rc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Qu),
				ic = new RegExp("^" + ec + tc + nc + rc + "$"),
				ac = ["material", "materials", "bones"],
				oc = function() {
					function e(t, n, r) {
						(0, g.default)(this, e), this.path = n, this.parsedPath = r || e
							.parseTrackName(n), this.node = e.findNode(t, this.parsedPath
								.nodeName) || t, this.rootNode = t, this.getValue = this
							._getValue_unbound, this.setValue = this._setValue_unbound
					}
					return (0, y.default)(e, [{
						key: "_getValue_unavailable",
						value: function() {}
					}, {
						key: "_setValue_unavailable",
						value: function() {}
					}, {
						key: "_getValue_direct",
						value: function(e, t) {
							e[t] = this.node[this.propertyName]
						}
					}, {
						key: "_getValue_array",
						value: function(e, t) {
							for (var n = this.resolvedProperty, r = 0, i = n
									.length; r !== i; ++r) e[t++] = n[r]
						}
					}, {
						key: "_getValue_arrayElement",
						value: function(e, t) {
							e[t] = this.resolvedProperty[this.propertyIndex]
						}
					}, {
						key: "_getValue_toArray",
						value: function(e, t) {
							this.resolvedProperty.toArray(e, t)
						}
					}, {
						key: "_setValue_direct",
						value: function(e, t) {
							this.targetObject[this.propertyName] = e[t]
						}
					}, {
						key: "_setValue_direct_setNeedsUpdate",
						value: function(e, t) {
							this.targetObject[this.propertyName] = e[t],
								this.targetObject.needsUpdate = !0
						}
					}, {
						key: "_setValue_direct_setMatrixWorldNeedsUpdate",
						value: function(e, t) {
							this.targetObject[this.propertyName] = e[t],
								this.targetObject.matrixWorldNeedsUpdate = !
								0
						}
					}, {
						key: "_setValue_array",
						value: function(e, t) {
							for (var n = this.resolvedProperty, r = 0, i = n
									.length; r !== i; ++r) n[r] = e[t++]
						}
					}, {
						key: "_setValue_array_setNeedsUpdate",
						value: function(e, t) {
							for (var n = this.resolvedProperty, r = 0, i = n
									.length; r !== i; ++r) n[r] = e[t++];
							this.targetObject.needsUpdate = !0
						}
					}, {
						key: "_setValue_array_setMatrixWorldNeedsUpdate",
						value: function(e, t) {
							for (var n = this.resolvedProperty, r = 0, i = n
									.length; r !== i; ++r) n[r] = e[t++];
							this.targetObject.matrixWorldNeedsUpdate = !0
						}
					}, {
						key: "_setValue_arrayElement",
						value: function(e, t) {
							this.resolvedProperty[this.propertyIndex] = e[t]
						}
					}, {
						key: "_setValue_arrayElement_setNeedsUpdate",
						value: function(e, t) {
							this.resolvedProperty[this.propertyIndex] = e[
								t], this.targetObject.needsUpdate = !0
						}
					}, {
						key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
						value: function(e, t) {
							this.resolvedProperty[this.propertyIndex] = e[
								t], this.targetObject
								.matrixWorldNeedsUpdate = !0
						}
					}, {
						key: "_setValue_fromArray",
						value: function(e, t) {
							this.resolvedProperty.fromArray(e, t)
						}
					}, {
						key: "_setValue_fromArray_setNeedsUpdate",
						value: function(e, t) {
							this.resolvedProperty.fromArray(e, t), this
								.targetObject.needsUpdate = !0
						}
					}, {
						key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
						value: function(e, t) {
							this.resolvedProperty.fromArray(e, t), this
								.targetObject.matrixWorldNeedsUpdate = !0
						}
					}, {
						key: "_getValue_unbound",
						value: function(e, t) {
							this.bind(), this.getValue(e, t)
						}
					}, {
						key: "_setValue_unbound",
						value: function(e, t) {
							this.bind(), this.setValue(e, t)
						}
					}, {
						key: "bind",
						value: function() {
							var t = this.node,
								n = this.parsedPath,
								r = n.objectName,
								i = n.propertyName,
								a = n.propertyIndex;
							if (t || (t = e.findNode(this.rootNode, n
										.nodeName) || this.rootNode, this
									.node = t), this.getValue = this
								._getValue_unavailable, this.setValue = this
								._setValue_unavailable, t) {
								if (r) {
									var o = n.objectIndex;
									switch (r) {
										case "materials":
											if (!t.material)
											return void console.error(
													"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
													this);
											if (!t.material.materials)
												return void console.error(
													"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
													this);
											t = t.material.materials;
											break;
										case "bones":
											if (!t.skeleton)
											return void console.error(
													"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
													this);
											t = t.skeleton.bones;
											for (var s = 0; s < t
												.length; s++)
												if (t[s].name === o) {
													o = s;
													break
												} break;
										default:
											if (void 0 === t[r])
											return void console.error(
													"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
													this);
											t = t[r]
									}
									if (void 0 !== o) {
										if (void 0 === t[o])
										return void console.error(
												"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
												this, t);
										t = t[o]
									}
								}
								var l = t[i];
								if (void 0 !== l) {
									var u = this.Versioning.None;
									this.targetObject = t, void 0 !== t
										.needsUpdate ? u = this.Versioning
										.NeedsUpdate : void 0 !== t
										.matrixWorldNeedsUpdate && (u = this
											.Versioning
											.MatrixWorldNeedsUpdate);
									var c = this.BindingType.Direct;
									if (void 0 !== a) {
										if ("morphTargetInfluences" === i) {
											if (!t.geometry)
											return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
													this);
											if (!t.geometry
												.isBufferGeometry)
											return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
													this);
											if (!t.geometry.morphAttributes)
												return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
													this);
											void 0 !== t
												.morphTargetDictionary[a] &&
												(a = t
													.morphTargetDictionary[
														a])
										}
										c = this.BindingType.ArrayElement,
											this.resolvedProperty = l, this
											.propertyIndex = a
									} else void 0 !== l.fromArray &&
										void 0 !== l.toArray ? (c = this
											.BindingType.HasFromToArray,
											this.resolvedProperty = l) :
										Array.isArray(l) ? (c = this
											.BindingType.EntireArray, this
											.resolvedProperty = l) : this
										.propertyName = i;
									this.getValue = this
										.GetterByBindingType[c], this
										.setValue = this
										.SetterByBindingTypeAndVersioning[c]
										[u]
								} else {
									var h = n.nodeName;
									console.error(
										"THREE.PropertyBinding: Trying to update property for track: " +
										h + "." + i +
										" but it wasn't found.", t)
								}
							} else console.error(
								"THREE.PropertyBinding: Trying to update node for track: " +
								this.path + " but it wasn't found.")
						}
					}, {
						key: "unbind",
						value: function() {
							this.node = null, this.getValue = this
								._getValue_unbound, this.setValue = this
								._setValue_unbound
						}
					}], [{
						key: "create",
						value: function(t, n, r) {
							return t && t.isAnimationObjectGroup ? new e
								.Composite(t, n, r) : new e(t, n, r)
						}
					}, {
						key: "sanitizeNodeName",
						value: function(e) {
							return e.replace(/\s/g, "_").replace(Ju, "")
						}
					}, {
						key: "parseTrackName",
						value: function(e) {
							var t = ic.exec(e);
							if (!t) throw new Error(
								"PropertyBinding: Cannot parse trackName: " +
								e);
							var n = {
									nodeName: t[2],
									objectName: t[3],
									objectIndex: t[4],
									propertyName: t[5],
									propertyIndex: t[6]
								},
								r = n.nodeName && n.nodeName.lastIndexOf(
									".");
							if (void 0 !== r && -1 !== r) {
								var i = n.nodeName.substring(r + 1); - 1 !==
									ac.indexOf(i) && (n.nodeName = n
										.nodeName.substring(0, r), n
										.objectName = i)
							}
							if (null === n.propertyName || 0 === n
								.propertyName.length) throw new Error(
								"PropertyBinding: can not parse propertyName from trackName: " +
								e);
							return n
						}
					}, {
						key: "findNode",
						value: function(e, t) {
							if (!t || "" === t || "." === t || -1 === t ||
								t === e.name || t === e.uuid) return e;
							if (e.skeleton) {
								var n = e.skeleton.getBoneByName(t);
								if (void 0 !== n) return n
							}
							if (e.children) {
								var r = function e(n) {
									for (var r = 0; r < n.length; r++) {
										var i = n[r];
										if (i.name === t || i.uuid ===
											t) return i;
										var a = e(i.children);
										if (a) return a
									}
									return null
								}(e.children);
								if (r) return r
							}
							return null
						}
					}]), e
				}();
			oc.Composite = function() {
				function e(t, n, r) {
					(0, g.default)(this, e);
					var i = r || oc.parseTrackName(n);
					this._targetGroup = t, this._bindings = t.subscribe_(n, i)
				}
				return (0, y.default)(e, [{
					key: "getValue",
					value: function(e, t) {
						this.bind();
						var n = this._targetGroup.nCachedObjects_,
							r = this._bindings[n];
						void 0 !== r && r.getValue(e, t)
					}
				}, {
					key: "setValue",
					value: function(e, t) {
						for (var n = this._bindings, r = this
								._targetGroup.nCachedObjects_, i = n
								.length; r !== i; ++r) n[r].setValue(e,
							t)
					}
				}, {
					key: "bind",
					value: function() {
						for (var e = this._bindings, t = this
								._targetGroup.nCachedObjects_, n = e
								.length; t !== n; ++t) e[t].bind()
					}
				}, {
					key: "unbind",
					value: function() {
						for (var e = this._bindings, t = this
								._targetGroup.nCachedObjects_, n = e
								.length; t !== n; ++t) e[t].unbind()
					}
				}]), e
			}(), oc.prototype.BindingType = {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			}, oc.prototype.Versioning = {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			}, oc.prototype.GetterByBindingType = [oc.prototype._getValue_direct, oc
				.prototype._getValue_array, oc.prototype._getValue_arrayElement, oc
				.prototype._getValue_toArray
			], oc.prototype.SetterByBindingTypeAndVersioning = [
				[oc.prototype._setValue_direct, oc.prototype
					._setValue_direct_setNeedsUpdate, oc.prototype
					._setValue_direct_setMatrixWorldNeedsUpdate
				],
				[oc.prototype._setValue_array, oc.prototype
					._setValue_array_setNeedsUpdate, oc.prototype
					._setValue_array_setMatrixWorldNeedsUpdate
				],
				[oc.prototype._setValue_arrayElement, oc.prototype
					._setValue_arrayElement_setNeedsUpdate, oc.prototype
					._setValue_arrayElement_setMatrixWorldNeedsUpdate
				],
				[oc.prototype._setValue_fromArray, oc.prototype
					._setValue_fromArray_setNeedsUpdate, oc.prototype
					._setValue_fromArray_setMatrixWorldNeedsUpdate
				]
			];
			var sc = function() {
				function e() {
					(0, g.default)(this, e), this.uuid = Te(), this._objects = Array
						.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
					var t = {};
					this._indicesByUUID = t;
					for (var n = 0, r = arguments.length; n !== r; ++n) t[arguments[n]
						.uuid] = n;
					this._paths = [], this._parsedPaths = [], this._bindings = [], this
						._bindingsIndicesByPath = {};
					var i = this;
					this.stats = {
						objects: {
							get total() {
								return i._objects.length
							},
							get inUse() {
								return this.total - i.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return i._bindings.length
						}
					}
				}
				return (0, y.default)(e, [{
					key: "add",
					value: function() {
						for (var e, t = this._objects, n = this
								._indicesByUUID, r = this._paths, i =
								this._parsedPaths, a = this._bindings,
								o = a.length, s = t.length, l = this
								.nCachedObjects_, u = 0, c = arguments
								.length; u !== c; ++u) {
							var h = arguments[u],
								d = h.uuid,
								f = n[d];
							if (void 0 === f) {
								f = s++, n[d] = f, t.push(h);
								for (var p = 0, v = o; p !== v; ++p) a[
									p].push(new oc(h, r[p], i[p]))
							} else if (f < l) {
								e = t[f];
								var m = --l,
									g = t[m];
								n[g.uuid] = f, t[f] = g, n[d] = m, t[
									m] = h;
								for (var y = 0, x = o; y !== x; ++y) {
									var _ = a[y],
										b = _[m],
										w = _[f];
									_[f] = b, void 0 === w && (w =
											new oc(h, r[y], i[y])), _[
										m] = w
								}
							} else t[f] !== e && console.error(
								"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
								)
						}
						this.nCachedObjects_ = l
					}
				}, {
					key: "remove",
					value: function() {
						for (var e = this._objects, t = this
								._indicesByUUID, n = this._bindings, r =
								n.length, i = this.nCachedObjects_, a =
								0, o = arguments.length; a !== o; ++a) {
							var s = arguments[a],
								l = s.uuid,
								u = t[l];
							if (void 0 !== u && u >= i) {
								var c = i++,
									h = e[c];
								t[h.uuid] = u, e[u] = h, t[l] = c, e[
									c] = s;
								for (var d = 0, f = r; d !== f; ++d) {
									var p = n[d],
										v = p[c],
										m = p[u];
									p[u] = v, p[c] = m
								}
							}
						}
						this.nCachedObjects_ = i
					}
				}, {
					key: "uncache",
					value: function() {
						for (var e = this._objects, t = this
								._indicesByUUID, n = this._bindings, r =
								n.length, i = this.nCachedObjects_, a =
								e.length, o = 0, s = arguments
								.length; o !== s; ++o) {
							var l = arguments[o].uuid,
								u = t[l];
							if (void 0 !== u)
								if (delete t[l], u < i) {
									var c = --i,
										h = e[c],
										d = --a,
										f = e[d];
									t[h.uuid] = u, e[u] = h, t[f.uuid] =
										c, e[c] = f, e.pop();
									for (var p = 0, v = r; p !== v; ++
										p) {
										var m = n[p],
											g = m[c],
											y = m[d];
										m[u] = g, m[c] = y, m.pop()
									}
								} else {
									var x = --a,
										_ = e[x];
									x > 0 && (t[_.uuid] = u), e[u] = _,
										e.pop();
									for (var b = 0, w = r; b !== w; ++
										b) {
										var M = n[b];
										M[u] = M[x], M.pop()
									}
								}
						}
						this.nCachedObjects_ = i
					}
				}, {
					key: "subscribe_",
					value: function(e, t) {
						var n = this._bindingsIndicesByPath,
							r = n[e],
							i = this._bindings;
						if (void 0 !== r) return i[r];
						var a = this._paths,
							o = this._parsedPaths,
							s = this._objects,
							l = s.length,
							u = this.nCachedObjects_,
							c = new Array(l);
						r = i.length, n[e] = r, a.push(e), o.push(t), i
							.push(c);
						for (var h = u, d = s.length; h !== d; ++h) {
							var f = s[h];
							c[h] = new oc(f, e, t)
						}
						return c
					}
				}, {
					key: "unsubscribe_",
					value: function(e) {
						var t = this._bindingsIndicesByPath,
							n = t[e];
						if (void 0 !== n) {
							var r = this._paths,
								i = this._parsedPaths,
								a = this._bindings,
								o = a.length - 1,
								s = a[o];
							t[e[o]] = n, a[n] = s, a.pop(), i[n] = i[o],
								i.pop(), r[n] = r[o], r.pop()
						}
					}
				}]), e
			}();
			sc.prototype.isAnimationObjectGroup = !0;
			var lc = function() {
					function e(t, n) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : null,
							i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : n.blendMode;
						(0, g.default)(this, e), this._mixer = t, this._clip = n, this
							._localRoot = r, this.blendMode = i;
						for (var a = n.tracks, o = a.length, s = new Array(o), l = {
								endingStart: re,
								endingEnd: re
							}, u = 0; u !== o; ++u) {
							var c = a[u].createInterpolant(null);
							s[u] = c, c.settings = l
						}
						this._interpolantSettings = l, this._interpolants = s, this
							._propertyBindings = new Array(o), this._cacheIndex = null, this
							._byClipCacheIndex = null, this._timeScaleInterpolant = null,
							this._weightInterpolant = null, this.loop = 2201, this
							._loopCount = -1, this._startTime = null, this.time = 0, this
							.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1,
							this._effectiveWeight = 1, this.repetitions = 1 / 0, this
							.paused = !1, this.enabled = !0, this.clampWhenFinished = !1,
							this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
					}
					return (0, y.default)(e, [{
						key: "play",
						value: function() {
							return this._mixer._activateAction(this), this
						}
					}, {
						key: "stop",
						value: function() {
							return this._mixer._deactivateAction(this), this
								.reset()
						}
					}, {
						key: "reset",
						value: function() {
							return this.paused = !1, this.enabled = !0, this
								.time = 0, this._loopCount = -1, this
								._startTime = null, this.stopFading()
								.stopWarping()
						}
					}, {
						key: "isRunning",
						value: function() {
							return this.enabled && !this.paused && 0 !==
								this.timeScale && null === this
								._startTime && this._mixer._isActiveAction(
									this)
						}
					}, {
						key: "isScheduled",
						value: function() {
							return this._mixer._isActiveAction(this)
						}
					}, {
						key: "startAt",
						value: function(e) {
							return this._startTime = e, this
						}
					}, {
						key: "setLoop",
						value: function(e, t) {
							return this.loop = e, this.repetitions = t, this
						}
					}, {
						key: "setEffectiveWeight",
						value: function(e) {
							return this.weight = e, this._effectiveWeight =
								this.enabled ? e : 0, this.stopFading()
						}
					}, {
						key: "getEffectiveWeight",
						value: function() {
							return this._effectiveWeight
						}
					}, {
						key: "fadeIn",
						value: function(e) {
							return this._scheduleFading(e, 0, 1)
						}
					}, {
						key: "fadeOut",
						value: function(e) {
							return this._scheduleFading(e, 1, 0)
						}
					}, {
						key: "crossFadeFrom",
						value: function(e, t, n) {
							if (e.fadeOut(t), this.fadeIn(t), n) {
								var r = this._clip.duration,
									i = e._clip.duration,
									a = i / r,
									o = r / i;
								e.warp(1, a, t), this.warp(o, 1, t)
							}
							return this
						}
					}, {
						key: "crossFadeTo",
						value: function(e, t, n) {
							return e.crossFadeFrom(this, t, n)
						}
					}, {
						key: "stopFading",
						value: function() {
							var e = this._weightInterpolant;
							return null !== e && (this._weightInterpolant =
								null, this._mixer
								._takeBackControlInterpolant(e)), this
						}
					}, {
						key: "setEffectiveTimeScale",
						value: function(e) {
							return this.timeScale = e, this
								._effectiveTimeScale = this.paused ? 0 : e,
								this.stopWarping()
						}
					}, {
						key: "getEffectiveTimeScale",
						value: function() {
							return this._effectiveTimeScale
						}
					}, {
						key: "setDuration",
						value: function(e) {
							return this.timeScale = this._clip.duration / e,
								this.stopWarping()
						}
					}, {
						key: "syncWith",
						value: function(e) {
							return this.time = e.time, this.timeScale = e
								.timeScale, this.stopWarping()
						}
					}, {
						key: "halt",
						value: function(e) {
							return this.warp(this._effectiveTimeScale, 0, e)
						}
					}, {
						key: "warp",
						value: function(e, t, n) {
							var r = this._mixer,
								i = r.time,
								a = this.timeScale,
								o = this._timeScaleInterpolant;
							null === o && (o = r._lendControlInterpolant(),
								this._timeScaleInterpolant = o);
							var s = o.parameterPositions,
								l = o.sampleValues;
							return s[0] = i, s[1] = i + n, l[0] = e / a, l[
								1] = t / a, this
						}
					}, {
						key: "stopWarping",
						value: function() {
							var e = this._timeScaleInterpolant;
							return null !== e && (this
									._timeScaleInterpolant = null, this
									._mixer._takeBackControlInterpolant(e)),
								this
						}
					}, {
						key: "getMixer",
						value: function() {
							return this._mixer
						}
					}, {
						key: "getClip",
						value: function() {
							return this._clip
						}
					}, {
						key: "getRoot",
						value: function() {
							return this._localRoot || this._mixer._root
						}
					}, {
						key: "_update",
						value: function(e, t, n, r) {
							if (this.enabled) {
								var i = this._startTime;
								if (null !== i) {
									var a = (e - i) * n;
									if (a < 0 || 0 === n) return;
									this._startTime = null, t = n * a
								}
								t *= this._updateTimeScale(e);
								var o = this._updateTime(t),
									s = this._updateWeight(e);
								if (s > 0) {
									var l = this._interpolants,
										u = this._propertyBindings;
									if (this.blendMode === se)
										for (var c = 0, h = l.length; c !==
											h; ++c) l[c].evaluate(o), u[c]
											.accumulateAdditive(s);
									else
										for (var d = 0, f = l.length; d !==
											f; ++d) l[d].evaluate(o), u[d]
											.accumulate(r, s)
								}
							} else this._updateWeight(e)
						}
					}, {
						key: "_updateWeight",
						value: function(e) {
							var t = 0;
							if (this.enabled) {
								t = this.weight;
								var n = this._weightInterpolant;
								if (null !== n) {
									var r = n.evaluate(e)[0];
									t *= r, e > n.parameterPositions[1] && (
										this.stopFading(), 0 === r && (
											this.enabled = !1))
								}
							}
							return this._effectiveWeight = t, t
						}
					}, {
						key: "_updateTimeScale",
						value: function(e) {
							var t = 0;
							if (!this.paused) {
								t = this.timeScale;
								var n = this._timeScaleInterpolant;
								null !== n && (t *= n.evaluate(e)[0], e > n
									.parameterPositions[1] && (this
										.stopWarping(), 0 === t ? this
										.paused = !0 : this.timeScale =
										t))
							}
							return this._effectiveTimeScale = t, t
						}
					}, {
						key: "_updateTime",
						value: function(e) {
							var t = this._clip.duration,
								n = this.loop,
								r = this.time + e,
								i = this._loopCount,
								a = 2202 === n;
							if (0 === e) return -1 === i ? r : a && 1 == (
								1 & i) ? t - r : r;
							if (2200 === n) {
								-1 === i && (this._loopCount = 0, this
									._setEndings(!0, !0, !1));
								e: {
									if (r >= t) r = t;
									else {
										if (!(r < 0)) {
											this.time = r;
											break e
										}
										r = 0
									}
									this.clampWhenFinished ? this
									.paused = !0 : this.enabled = !1,
									this.time = r,
									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: e < 0 ? -1 : 1
									})
								}
							} else {
								if (-1 === i && (e >= 0 ? (i = 0, this
											._setEndings(!0, 0 === this
												.repetitions, a)) : this
										._setEndings(0 === this.repetitions,
											!0, a)), r >= t || r < 0) {
									var o = Math.floor(r / t);
									r -= t * o, i += Math.abs(o);
									var s = this.repetitions - i;
									if (s <= 0) this.clampWhenFinished ?
										this.paused = !0 : this.enabled = !
										1, r = e > 0 ? t : 0, this.time = r,
										this._mixer.dispatchEvent({
											type: "finished",
											action: this,
											direction: e > 0 ? 1 : -1
										});
									else {
										if (1 === s) {
											var l = e < 0;
											this._setEndings(l, !l, a)
										} else this._setEndings(!1, !1, a);
										this._loopCount = i, this.time = r,
											this._mixer.dispatchEvent({
												type: "loop",
												action: this,
												loopDelta: o
											})
									}
								} else this.time = r;
								if (a && 1 == (1 & i)) return t - r
							}
							return r
						}
					}, {
						key: "_setEndings",
						value: function(e, t, n) {
							var r = this._interpolantSettings;
							n ? (r.endingStart = ie, r.endingEnd = ie) : (r
								.endingStart = e ? this
								.zeroSlopeAtStart ? ie : re : ae, r
								.endingEnd = t ? this.zeroSlopeAtEnd ?
								ie : re : ae)
						}
					}, {
						key: "_scheduleFading",
						value: function(e, t, n) {
							var r = this._mixer,
								i = r.time,
								a = this._weightInterpolant;
							null === a && (a = r._lendControlInterpolant(),
								this._weightInterpolant = a);
							var o = a.parameterPositions,
								s = a.sampleValues;
							return o[0] = i, s[0] = t, o[1] = i + e, s[1] =
								n, this
						}
					}]), e
				}(),
				uc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this))._root = e, r
							._initMemoryManager(), r._accuIndex = 0, r.time = 0, r
							.timeScale = 1, r
					}
					return (0, y.default)(n, [{
						key: "_bindAction",
						value: function(e, t) {
							var n = e._localRoot || this._root,
								r = e._clip.tracks,
								i = r.length,
								a = e._propertyBindings,
								o = e._interpolants,
								s = n.uuid,
								l = this._bindingsByRootAndName,
								u = l[s];
							void 0 === u && (u = {}, l[s] = u);
							for (var c = 0; c !== i; ++c) {
								var h = r[c],
									d = h.name,
									f = u[d];
								if (void 0 !== f) a[c] = f;
								else {
									if (void 0 !== (f = a[c])) {
										null === f._cacheIndex && (++f
											.referenceCount, this
											._addInactiveBinding(f, s,
												d));
										continue
									}
									var p = t && t._propertyBindings[c]
										.binding.parsedPath;
									++(f = new Zu(oc.create(n, d, p), h
										.ValueTypeName, h.getValueSize()
										)).referenceCount, this
										._addInactiveBinding(f, s, d), a[
										c] = f
								}
								o[c].resultBuffer = f.buffer
							}
						}
					}, {
						key: "_activateAction",
						value: function(e) {
							if (!this._isActiveAction(e)) {
								if (null === e._cacheIndex) {
									var t = (e._localRoot || this._root)
										.uuid,
										n = e._clip.uuid,
										r = this._actionsByClip[n];
									this._bindAction(e, r && r.knownActions[
										0]), this._addInactiveAction(e,
										n, t)
								}
								for (var i = e._propertyBindings, a = 0, o =
										i.length; a !== o; ++a) {
									var s = i[a];
									0 == s.useCount++ && (this._lendBinding(
										s), s.saveOriginalState())
								}
								this._lendAction(e)
							}
						}
					}, {
						key: "_deactivateAction",
						value: function(e) {
							if (this._isActiveAction(e)) {
								for (var t = e._propertyBindings, n = 0, r =
										t.length; n !== r; ++n) {
									var i = t[n];
									0 == --i.useCount && (i
										.restoreOriginalState(), this
										._takeBackBinding(i))
								}
								this._takeBackAction(e)
							}
						}
					}, {
						key: "_initMemoryManager",
						value: function() {
							this._actions = [], this._nActiveActions = 0,
								this._actionsByClip = {}, this
								._bindings = [], this._nActiveBindings = 0,
								this._bindingsByRootAndName = {}, this
								._controlInterpolants = [], this
								._nActiveControlInterpolants = 0;
							var e = this;
							this.stats = {
								actions: {
									get total() {
										return e._actions.length
									},
									get inUse() {
										return e._nActiveActions
									}
								},
								bindings: {
									get total() {
										return e._bindings.length
									},
									get inUse() {
										return e._nActiveBindings
									}
								},
								controlInterpolants: {
									get total() {
										return e
											._controlInterpolants
											.length
									},
									get inUse() {
										return e
											._nActiveControlInterpolants
									}
								}
							}
						}
					}, {
						key: "_isActiveAction",
						value: function(e) {
							var t = e._cacheIndex;
							return null !== t && t < this._nActiveActions
						}
					}, {
						key: "_addInactiveAction",
						value: function(e, t, n) {
							var r = this._actions,
								i = this._actionsByClip,
								a = i[t];
							if (void 0 === a) a = {
								knownActions: [e],
								actionByRoot: {}
							}, e._byClipCacheIndex = 0, i[t] = a;
							else {
								var o = a.knownActions;
								e._byClipCacheIndex = o.length, o.push(e)
							}
							e._cacheIndex = r.length, r.push(e), a
								.actionByRoot[n] = e
						}
					}, {
						key: "_removeInactiveAction",
						value: function(e) {
							var t = this._actions,
								n = t[t.length - 1],
								r = e._cacheIndex;
							n._cacheIndex = r, t[r] = n, t.pop(), e
								._cacheIndex = null;
							var i = e._clip.uuid,
								a = this._actionsByClip,
								o = a[i],
								s = o.knownActions,
								l = s[s.length - 1],
								u = e._byClipCacheIndex;
							l._byClipCacheIndex = u, s[u] = l, s.pop(), e
								._byClipCacheIndex = null, delete o
								.actionByRoot[(e._localRoot || this._root)
									.uuid], 0 === s.length && delete a[i],
								this._removeInactiveBindingsForAction(e)
						}
					}, {
						key: "_removeInactiveBindingsForAction",
						value: function(e) {
							for (var t = e._propertyBindings, n = 0, r = t
									.length; n !== r; ++n) {
								var i = t[n];
								0 == --i.referenceCount && this
									._removeInactiveBinding(i)
							}
						}
					}, {
						key: "_lendAction",
						value: function(e) {
							var t = this._actions,
								n = e._cacheIndex,
								r = this._nActiveActions++,
								i = t[r];
							e._cacheIndex = r, t[r] = e, i._cacheIndex = n,
								t[n] = i
						}
					}, {
						key: "_takeBackAction",
						value: function(e) {
							var t = this._actions,
								n = e._cacheIndex,
								r = --this._nActiveActions,
								i = t[r];
							e._cacheIndex = r, t[r] = e, i._cacheIndex = n,
								t[n] = i
						}
					}, {
						key: "_addInactiveBinding",
						value: function(e, t, n) {
							var r = this._bindingsByRootAndName,
								i = this._bindings,
								a = r[t];
							void 0 === a && (a = {}, r[t] = a), a[n] = e, e
								._cacheIndex = i.length, i.push(e)
						}
					}, {
						key: "_removeInactiveBinding",
						value: function(e) {
							var t = this._bindings,
								n = e.binding,
								r = n.rootNode.uuid,
								i = n.path,
								a = this._bindingsByRootAndName,
								o = a[r],
								s = t[t.length - 1],
								l = e._cacheIndex;
							s._cacheIndex = l, t[l] = s, t.pop(), delete o[
									i], 0 === Object.keys(o).length &&
								delete a[r]
						}
					}, {
						key: "_lendBinding",
						value: function(e) {
							var t = this._bindings,
								n = e._cacheIndex,
								r = this._nActiveBindings++,
								i = t[r];
							e._cacheIndex = r, t[r] = e, i._cacheIndex = n,
								t[n] = i
						}
					}, {
						key: "_takeBackBinding",
						value: function(e) {
							var t = this._bindings,
								n = e._cacheIndex,
								r = --this._nActiveBindings,
								i = t[r];
							e._cacheIndex = r, t[r] = e, i._cacheIndex = n,
								t[n] = i
						}
					}, {
						key: "_lendControlInterpolant",
						value: function() {
							var e = this._controlInterpolants,
								t = this._nActiveControlInterpolants++,
								n = e[t];
							return void 0 === n && ((n = new ll(
								new Float32Array(2),
								new Float32Array(2), 1, this
								._controlInterpolantsResultBuffer
								)).__cacheIndex = t, e[t] = n), n
						}
					}, {
						key: "_takeBackControlInterpolant",
						value: function(e) {
							var t = this._controlInterpolants,
								n = e.__cacheIndex,
								r = --this._nActiveControlInterpolants,
								i = t[r];
							e.__cacheIndex = r, t[r] = e, i.__cacheIndex =
								n, t[n] = i
						}
					}, {
						key: "clipAction",
						value: function(e, t, n) {
							var r = t || this._root,
								i = r.uuid,
								a = "string" == typeof e ? yl.findByName(r,
									e) : e,
								o = null !== a ? a.uuid : e,
								s = this._actionsByClip[o],
								l = null;
							if (void 0 === n && (n = null !== a ? a
									.blendMode : oe), void 0 !== s) {
								var u = s.actionByRoot[i];
								if (void 0 !== u && u.blendMode === n)
									return u;
								l = s.knownActions[0], null === a && (a = l
									._clip)
							}
							if (null === a) return null;
							var c = new lc(this, a, t, n);
							return this._bindAction(c, l), this
								._addInactiveAction(c, o, i), c
						}
					}, {
						key: "existingAction",
						value: function(e, t) {
							var n = t || this._root,
								r = n.uuid,
								i = "string" == typeof e ? yl.findByName(n,
									e) : e,
								a = i ? i.uuid : e,
								o = this._actionsByClip[a];
							return void 0 !== o && o.actionByRoot[r] || null
						}
					}, {
						key: "stopAllAction",
						value: function() {
							for (var e = this._actions, t = this
									._nActiveActions - 1; t >= 0; --t) e[t]
								.stop();
							return this
						}
					}, {
						key: "update",
						value: function(e) {
							e *= this.timeScale;
							for (var t = this._actions, n = this
									._nActiveActions, r = this.time += e,
									i = Math.sign(e), a = this._accuIndex ^=
									1, o = 0; o !== n; ++o) t[o]._update(r,
								e, i, a);
							for (var s = this._bindings, l = this
									._nActiveBindings, u = 0; u !== l; ++u)
								s[u].apply(a);
							return this
						}
					}, {
						key: "setTime",
						value: function(e) {
							this.time = 0;
							for (var t = 0; t < this._actions.length; t++)
								this._actions[t].time = 0;
							return this.update(e)
						}
					}, {
						key: "getRoot",
						value: function() {
							return this._root
						}
					}, {
						key: "uncacheClip",
						value: function(e) {
							var t = this._actions,
								n = e.uuid,
								r = this._actionsByClip,
								i = r[n];
							if (void 0 !== i) {
								for (var a = i.knownActions, o = 0, s = a
										.length; o !== s; ++o) {
									var l = a[o];
									this._deactivateAction(l);
									var u = l._cacheIndex,
										c = t[t.length - 1];
									l._cacheIndex = null, l
										._byClipCacheIndex = null, c
										._cacheIndex = u, t[u] = c, t.pop(),
										this
										._removeInactiveBindingsForAction(l)
								}
								delete r[n]
							}
						}
					}, {
						key: "uncacheRoot",
						value: function(e) {
							var t = e.uuid,
								n = this._actionsByClip;
							for (var r in n) {
								var i = n[r].actionByRoot[t];
								void 0 !== i && (this._deactivateAction(i),
									this._removeInactiveAction(i))
							}
							var a = this._bindingsByRootAndName[t];
							if (void 0 !== a)
								for (var o in a) {
									var s = a[o];
									s.restoreOriginalState(), this
										._removeInactiveBinding(s)
								}
						}
					}, {
						key: "uncacheAction",
						value: function(e, t) {
							var n = this.existingAction(e, t);
							null !== n && (this._deactivateAction(n), this
								._removeInactiveAction(n))
						}
					}]), n
				}(xe);
			uc.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
			var cc = function() {
					function e(t) {
						(0, g.default)(this, e), "string" == typeof t && (console.warn(
								"THREE.Uniform: Type parameter is no longer needed."),
							t = arguments[1]), this.value = t
					}
					return (0, y.default)(e, [{
						key: "clone",
						value: function() {
							return new e(void 0 === this.value.clone ? this
								.value : this.value.clone())
						}
					}]), e
				}(),
				hc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i, a = arguments.length > 2 && void 0 !== arguments[2] ?
							arguments[2] : 1;
						return (0, g.default)(this, n), (i = t.call(this, e, r))
							.meshPerAttribute = a || 1, i
					}
					return (0, y.default)(n, [{
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this,
								e), this.meshPerAttribute = e
								.meshPerAttribute, this
						}
					}, {
						key: "clone",
						value: function(e) {
							var t = (0, h.default)((0, m.default)(n
								.prototype), "clone", this).call(this,
								e);
							return t.meshPerAttribute = this
								.meshPerAttribute, t
						}
					}, {
						key: "toJSON",
						value: function(e) {
							var t = (0, h.default)((0, m.default)(n
								.prototype), "toJSON", this).call(this,
								e);
							return t.isInstancedInterleavedBuffer = !0, t
								.meshPerAttribute = this.meshPerAttribute, t
						}
					}]), n
				}(Ga);
			hc.prototype.isInstancedInterleavedBuffer = !0;
			var dc = function() {
				function e(t, n, r, i, a) {
					(0, g.default)(this, e), this.buffer = t, this.type = n, this
						.itemSize = r, this.elementSize = i, this.count = a, this
						.version = 0
				}
				return (0, y.default)(e, [{
					key: "needsUpdate",
					set: function(e) {
						!0 === e && this.version++
					}
				}, {
					key: "setBuffer",
					value: function(e) {
						return this.buffer = e, this
					}
				}, {
					key: "setType",
					value: function(e, t) {
						return this.type = e, this.elementSize = t, this
					}
				}, {
					key: "setItemSize",
					value: function(e) {
						return this.itemSize = e, this
					}
				}, {
					key: "setCount",
					value: function(e) {
						return this.count = e, this
					}
				}]), e
			}();

			function fc(e, t) {
				return e.distance - t.distance
			}

			function pc(e, t, n, r) {
				if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r)
					for (var i = e.children, a = 0, o = i.length; a < o; a++) pc(i[a], t, n,
						!0)
			}
			dc.prototype.isGLBufferAttribute = !0;
			var vc = new Ie,
				mc = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new Ie(1 / 0, 1 / 0),
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new Ie(-1 / 0, -1 / 0);
						(0, g.default)(this, e), this.min = t, this.max = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.min.copy(e), this.max.copy(t), this
						}
					}, {
						key: "setFromPoints",
						value: function(e) {
							this.makeEmpty();
							for (var t = 0, n = e.length; t < n; t++) this
								.expandByPoint(e[t]);
							return this
						}
					}, {
						key: "setFromCenterAndSize",
						value: function(e, t) {
							var n = vc.copy(t).multiplyScalar(.5);
							return this.min.copy(e).sub(n), this.max.copy(e)
								.add(n), this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.min.copy(e.min), this.max.copy(e
								.max), this
						}
					}, {
						key: "makeEmpty",
						value: function() {
							return this.min.x = this.min.y = 1 / 0, this.max
								.x = this.max.y = -1 / 0, this
						}
					}, {
						key: "isEmpty",
						value: function() {
							return this.max.x < this.min.x || this.max.y <
								this.min.y
						}
					}, {
						key: "getCenter",
						value: function(e) {
							return void 0 === e && (console.warn(
									"THREE.Box2: .getCenter() target is now required"
									), e = new Ie), this.isEmpty() ? e.set(
									0, 0) : e.addVectors(this.min, this.max)
								.multiplyScalar(.5)
						}
					}, {
						key: "getSize",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Box2: .getSize() target is now required"
								), e = new Ie), this.isEmpty() ? e.set(
								0, 0) : e.subVectors(this.max, this.min)
						}
					}, {
						key: "expandByPoint",
						value: function(e) {
							return this.min.min(e), this.max.max(e), this
						}
					}, {
						key: "expandByVector",
						value: function(e) {
							return this.min.sub(e), this.max.add(e), this
						}
					}, {
						key: "expandByScalar",
						value: function(e) {
							return this.min.addScalar(-e), this.max
								.addScalar(e), this
						}
					}, {
						key: "containsPoint",
						value: function(e) {
							return !(e.x < this.min.x || e.x > this.max.x ||
								e.y < this.min.y || e.y > this.max.y)
						}
					}, {
						key: "containsBox",
						value: function(e) {
							return this.min.x <= e.min.x && e.max.x <= this
								.max.x && this.min.y <= e.min.y && e.max
								.y <= this.max.y
						}
					}, {
						key: "getParameter",
						value: function(e, t) {
							return void 0 === t && (console.warn(
								"THREE.Box2: .getParameter() target is now required"
								), t = new Ie), t.set((e.x - this.min
								.x) / (this.max.x - this.min.x), (e.y -
									this.min.y) / (this.max.y - this.min
									.y))
						}
					}, {
						key: "intersectsBox",
						value: function(e) {
							return !(e.max.x < this.min.x || e.min.x > this
								.max.x || e.max.y < this.min.y || e.min
								.y > this.max.y)
						}
					}, {
						key: "clampPoint",
						value: function(e, t) {
							return void 0 === t && (console.warn(
								"THREE.Box2: .clampPoint() target is now required"
								), t = new Ie), t.copy(e).clamp(this
								.min, this.max)
						}
					}, {
						key: "distanceToPoint",
						value: function(e) {
							return vc.copy(e).clamp(this.min, this.max).sub(
								e).length()
						}
					}, {
						key: "intersect",
						value: function(e) {
							return this.min.max(e.min), this.max.min(e.max),
								this
						}
					}, {
						key: "union",
						value: function(e) {
							return this.min.min(e.min), this.max.max(e.max),
								this
						}
					}, {
						key: "translate",
						value: function(e) {
							return this.min.add(e), this.max.add(e), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.min.equals(this.min) && e.max.equals(
								this.max)
						}
					}]), e
				}();
			mc.prototype.isBox2 = !0;
			var gc = new je,
				yc = new je,
				xc = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : new je,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je;
						(0, g.default)(this, e), this.start = t, this.end = n
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							return this.start.copy(e), this.end.copy(t),
								this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.start.copy(e.start), this.end.copy(e
								.end), this
						}
					}, {
						key: "getCenter",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Line3: .getCenter() target is now required"
								), e = new je), e.addVectors(this.start,
								this.end).multiplyScalar(.5)
						}
					}, {
						key: "delta",
						value: function(e) {
							return void 0 === e && (console.warn(
								"THREE.Line3: .delta() target is now required"
								), e = new je), e.subVectors(this.end,
								this.start)
						}
					}, {
						key: "distanceSq",
						value: function() {
							return this.start.distanceToSquared(this.end)
						}
					}, {
						key: "distance",
						value: function() {
							return this.start.distanceTo(this.end)
						}
					}, {
						key: "at",
						value: function(e, t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .at() target is now required"
									), t = new je), this.delta(t)
								.multiplyScalar(e).add(this.start)
						}
					}, {
						key: "closestPointToPointParameter",
						value: function(e, t) {
							gc.subVectors(e, this.start), yc.subVectors(this
								.end, this.start);
							var n = yc.dot(yc),
								r = yc.dot(gc) / n;
							return t && (r = Ee(r, 0, 1)), r
						}
					}, {
						key: "closestPointToPoint",
						value: function(e, t, n) {
							var r = this.closestPointToPointParameter(e, t);
							return void 0 === n && (console.warn(
									"THREE.Line3: .closestPointToPoint() target is now required"
									), n = new je), this.delta(n)
								.multiplyScalar(r).add(this.start)
						}
					}, {
						key: "applyMatrix4",
						value: function(e) {
							return this.start.applyMatrix4(e), this.end
								.applyMatrix4(e), this
						}
					}, {
						key: "equals",
						value: function(e) {
							return e.start.equals(this.start) && e.end
								.equals(this.end)
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}(),
				_c = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this)).material = e, r
							.render = function() {}, r.hasPositions = !1, r.hasNormals = !1,
							r.hasColors = !1, r.hasUvs = !1, r.positionArray = null, r
							.normalArray = null, r.colorArray = null, r.uvArray = null, r
							.count = 0, r
					}
					return n
				}(Xt);
			_c.prototype.isImmediateRenderObject = !0;
			var bc = new je,
				wc = new je,
				Mc = new wt,
				Sc = new wt,
				Tc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						(0, g.default)(this, n);
						for (var i = Ec(e), a = new Vn, o = [], s = [], l = new yn(0, 0, 1),
								u = new yn(0, 1, 0), c = 0; c < i.length; c++) {
							var h = i[c];
							h.parent && h.parent.isBone && (o.push(0, 0, 0), o.push(0, 0,
								0), s.push(l.r, l.g, l.b), s.push(u.r, u.g, u.b))
						}
						return a.setAttribute("position", new Cn(o, 3)), a.setAttribute(
								"color", new Cn(s, 3)), (r = t.call(this, a, new Ao({
								vertexColors: !0,
								depthTest: !1,
								depthWrite: !1,
								toneMapped: !1,
								transparent: !0
							}))).type = "SkeletonHelper", r.isSkeletonHelper = !0, r.root =
							e, r.bones = i, r.matrix = e.matrixWorld, r.matrixAutoUpdate = !
							1, r
					}
					return (0, y.default)(n, [{
						key: "updateMatrixWorld",
						value: function(e) {
							var t = this.bones,
								r = this.geometry,
								i = r.getAttribute("position");
							Sc.copy(this.root.matrixWorld).invert();
							for (var a = 0, o = 0; a < t.length; a++) {
								var s = t[a];
								s.parent && s.parent.isBone && (Mc
									.multiplyMatrices(Sc, s
									.matrixWorld), wc
									.setFromMatrixPosition(Mc), i
									.setXYZ(o, wc.x, wc.y, wc.z), Mc
									.multiplyMatrices(Sc, s.parent
										.matrixWorld), wc
									.setFromMatrixPosition(Mc), i
									.setXYZ(o + 1, wc.x, wc.y, wc.z),
									o += 2)
							}
							r.getAttribute("position").needsUpdate = !0, (0,
								h.default)((0, m.default)(n.prototype),
								"updateMatrixWorld", this).call(this, e)
						}
					}]), n
				}(Oo);

			function Ec(e) {
				var t = [];
				e && e.isBone && t.push(e);
				for (var n = 0; n < e.children.length; n++) t.push.apply(t, Ec(e.children[
					n]));
				return t
			}
			var Ac = new je,
				Lc = new yn,
				kc = new yn,
				Rc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 10,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 10,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 4473924,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 8947848;
						(0, g.default)(this, n), a = new yn(a), o = new yn(o);
						for (var s = i / 2, l = r / i, u = r / 2, c = [], h = [], d = 0, f =
								0, p = -u; d <= i; d++, p += l) {
							c.push(-u, 0, p, u, 0, p), c.push(p, 0, -u, p, 0, u);
							var v = d === s ? a : o;
							v.toArray(h, f), f += 3, v.toArray(h, f), f += 3, v.toArray(h,
								f), f += 3, v.toArray(h, f), f += 3
						}
						var m = new Vn;
						return m.setAttribute("position", new Cn(c, 3)), m.setAttribute(
							"color", new Cn(h, 3)), (e = t.call(this, m, new Ao({
							vertexColors: !0,
							toneMapped: !1
						}))).type = "GridHelper", e
					}
					return n
				}(Oo),
				Cc = new je,
				Pc = new je,
				Ic = new je,
				Dc = new je,
				Nc = new pr;

			function Oc(e, t, n, r, i, a, o) {
				Dc.set(i, a, o).unproject(r);
				var s = t[e];
				if (void 0 !== s)
					for (var l = n.getAttribute("position"), u = 0, c = s.length; u <
						c; u++) l.setXYZ(s[u], Dc.x, Dc.y, Dc.z)
			}
			var Bc, zc, Fc = new Ye,
				Hc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 16776960;
						(0, g.default)(this, n);
						var a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7,
								7, 4, 0, 4, 1, 5, 2, 6, 3, 7
							]),
							o = new Float32Array(24),
							s = new Vn;
						return s.setIndex(new wn(a, 1)), s.setAttribute("position", new wn(
								o, 3)), (r = t.call(this, s, new Ao({
								color: i,
								toneMapped: !1
							}))).object = e, r.type = "BoxHelper", r.matrixAutoUpdate = !1,
							r.update(), r
					}
					return (0, y.default)(n, [{
						key: "update",
						value: function(e) {
							if (void 0 !== e && console.warn(
									"THREE.BoxHelper: .update() has no longer arguments."
									), void 0 !== this.object && Fc
								.setFromObject(this.object), !Fc.isEmpty()
								) {
								var t = Fc.min,
									n = Fc.max,
									r = this.geometry.attributes.position,
									i = r.array;
								i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t
									.x, i[4] = n.y, i[5] = n.z, i[6] = t.x,
									i[7] = t.y, i[8] = n.z, i[9] = n.x, i[
										10] = t.y, i[11] = n.z, i[12] = n.x,
									i[13] = n.y, i[14] = t.z, i[15] = t.x,
									i[16] = n.y, i[17] = t.z, i[18] = t.x,
									i[19] = t.y, i[20] = t.z, i[21] = n.x,
									i[22] = t.y, i[23] = t.z, r
									.needsUpdate = !0, this.geometry
									.computeBoundingSphere()
							}
						}
					}, {
						key: "setFromObject",
						value: function(e) {
							return this.object = e, this.update(), this
						}
					}, {
						key: "copy",
						value: function(e) {
							return Oo.prototype.copy.call(this, e), this
								.object = e.object, this
						}
					}]), n
				}(Oo),
				Uc = new je,
				Gc = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 1;
						(0, g.default)(this, n);
						var i = [0, 0, 0, r, 0, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, 0, r],
							a = new Vn;
						return a.setAttribute("position", new Cn(i, 3)), a.setAttribute(
							"color", new Cn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0,
								1, 0, .6, 1
							], 3)), (e = t.call(this, a, new Ao({
							vertexColors: !0,
							toneMapped: !1
						}))).type = "AxesHelper", e
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {
							this.geometry.dispose(), this.material.dispose()
						}
					}]), n
				}(Oo),
				Vc = new Float32Array(1),
				Wc = new Int32Array(Vc.buffer),
				jc = Math.pow(2, 8),
				qc = [.125, .215, .35, .446, .526, .582],
				Xc = 5 + qc.length,
				Yc = (t = {}, (0, d.default)(t, le, 0), (0, d.default)(t, ue, 1), (0, d
					.default)(t, he, 2), (0, d.default)(t, de, 3), (0, d.default)(t, fe,
					4), (0, d.default)(t, pe, 5), (0, d.default)(t, ce, 6), t),
				$c = new xn({
					side: 1,
					depthWrite: !1,
					depthTest: !1
				}),
				Zc = new sr(new ur, $c),
				Jc = new du,
				Qc = function() {
					for (var e = [], t = [], n = [], r = 8, i = 0; i < Xc; i++) {
						var a = Math.pow(2, r);
						t.push(a);
						var o = 1 / a;
						i > 4 ? o = qc[i - 8 + 4 - 1] : 0 == i && (o = 0), n.push(o);
						for (var s = 1 / (a - 1), l = -s / 2, u = 1 + s / 2, c = [l, l, u,
									l, u, u, l, l, u, u, l, u
								], h = new Float32Array(108), d = new Float32Array(72), f =
								new Float32Array(36), p = 0; p < 6; p++) {
							var v = p % 3 * 2 / 3 - 1,
								m = p > 2 ? 0 : -1,
								g = [v, m, 0, v + 2 / 3, m, 0, v + 2 / 3, m + 1, 0, v, m, 0,
									v + 2 / 3, m + 1, 0, v, m + 1, 0
								];
							h.set(g, 18 * p), d.set(c, 12 * p);
							var y = [p, p, p, p, p, p];
							f.set(y, 6 * p)
						}
						var x = new Vn;
						x.setAttribute("position", new wn(h, 3)), x.setAttribute("uv",
								new wn(d, 2)), x.setAttribute("faceIndex", new wn(f, 1)), e
							.push(x), r > 4 && r--
					}
					return {
						_lodPlanes: e,
						_sizeLods: t,
						_sigmas: n
					}
				}(),
				Kc = Qc._lodPlanes,
				eh = Qc._sizeLods,
				th = Qc._sigmas,
				nh = new yn,
				rh = null,
				ih = (1 + Math.sqrt(5)) / 2,
				ah = 1 / ih,
				oh = [new je(1, 1, 1), new je(-1, 1, 1), new je(1, 1, -1), new je(-1, 1, -
					1), new je(0, ih, ah), new je(0, ih, -ah), new je(ah, 0, ih), new je(-
						ah, 0, ih), new je(ih, ah, 0), new je(-ih, ah, 0)
				];

			function sh(e) {
				var t = Math.max(e.r, e.g, e.b),
					n = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127);
				return e.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255
			}

			function lh(e) {
				return void 0 !== e && e.type === D && (e.encoding === le || e.encoding ===
					ue || e.encoding === ce)
			}

			function uh(e) {
				var t = new Ue(3 * jc, 3 * jc, e);
				return t.texture.mapping = b, t.texture.name = "PMREM.cubeUv", t
					.scissorTest = !0, t
			}

			function ch(e, t, n, r, i) {
				e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
			}
			Rl.create = function(e, t) {
				return console.log("THREE.Curve.create() has been deprecated"), e
					.prototype = Object.create(Rl.prototype), e.prototype.constructor =
					e, e.prototype.getPoint = t, e
			}, Jl.prototype.fromPoints = function(e) {
				return console.warn(
					"THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
					), this.setFromPoints(e)
			}, Rc.prototype.setColors = function() {
				console.error(
					"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
					)
			}, Tc.prototype.update = function() {
				console.error(
					"THREE.SkeletonHelper: update() no longer needs to be called.")
			}, Ml.prototype.extractUrlBase = function(e) {
				return console.warn(
					"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
					), _u.extractUrlBase(e)
			}, Ml.Handlers = {
				add: function() {
					console.error(
						"THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
						)
				},
				get: function() {
					console.error(
						"THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
						)
				}
			}, mc.prototype.center = function(e) {
				return console.warn(
						"THREE.Box2: .center() has been renamed to .getCenter()."), this
					.getCenter(e)
			}, mc.prototype.empty = function() {
				return console.warn(
						"THREE.Box2: .empty() has been renamed to .isEmpty()."), this
					.isEmpty()
			}, mc.prototype.isIntersectionBox = function(e) {
				return console.warn(
					"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
					), this.intersectsBox(e)
			}, mc.prototype.size = function(e) {
				return console.warn(
						"THREE.Box2: .size() has been renamed to .getSize()."), this
					.getSize(e)
			}, Ye.prototype.center = function(e) {
				return console.warn(
						"THREE.Box3: .center() has been renamed to .getCenter()."), this
					.getCenter(e)
			}, Ye.prototype.empty = function() {
				return console.warn(
						"THREE.Box3: .empty() has been renamed to .isEmpty()."), this
					.isEmpty()
			}, Ye.prototype.isIntersectionBox = function(e) {
				return console.warn(
					"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
					), this.intersectsBox(e)
			}, Ye.prototype.isIntersectionSphere = function(e) {
				return console.warn(
					"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
					), this.intersectsSphere(e)
			}, Ye.prototype.size = function(e) {
				return console.warn(
						"THREE.Box3: .size() has been renamed to .getSize()."), this
					.getSize(e)
			}, ft.prototype.empty = function() {
				return console.warn(
						"THREE.Sphere: .empty() has been renamed to .isEmpty()."), this
					.isEmpty()
			}, wr.prototype.setFromMatrix = function(e) {
				return console.warn(
					"THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
					), this.setFromProjectionMatrix(e)
			}, xc.prototype.center = function(e) {
				return console.warn(
						"THREE.Line3: .center() has been renamed to .getCenter()."),
					this.getCenter(e)
			}, Ne.prototype.flattenToArrayOffset = function(e, t) {
				return console.warn(
					"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
					), this.toArray(e, t)
			}, Ne.prototype.multiplyVector3 = function(e) {
				return console.warn(
					"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
					), e.applyMatrix3(this)
			}, Ne.prototype.multiplyVector3Array = function() {
				console.error(
					"THREE.Matrix3: .multiplyVector3Array() has been removed.")
			}, Ne.prototype.applyToBufferAttribute = function(e) {
				return console.warn(
					"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
					), e.applyMatrix3(this)
			}, Ne.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
			}, Ne.prototype.getInverse = function(e) {
				return console.warn(
					"THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
					), this.copy(e).invert()
			}, wt.prototype.extractPosition = function(e) {
				return console.warn(
					"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
					), this.copyPosition(e)
			}, wt.prototype.flattenToArrayOffset = function(e, t) {
				return console.warn(
					"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
					), this.toArray(e, t)
			}, wt.prototype.getPosition = function() {
				return console.warn(
					"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
					), (new je).setFromMatrixColumn(this, 3)
			}, wt.prototype.setRotationFromQuaternion = function(e) {
				return console.warn(
					"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
					), this.makeRotationFromQuaternion(e)
			}, wt.prototype.multiplyToArray = function() {
				console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
			}, wt.prototype.multiplyVector3 = function(e) {
				return console.warn(
					"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
					), e.applyMatrix4(this)
			}, wt.prototype.multiplyVector4 = function(e) {
				return console.warn(
					"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
					), e.applyMatrix4(this)
			}, wt.prototype.multiplyVector3Array = function() {
				console.error(
					"THREE.Matrix4: .multiplyVector3Array() has been removed.")
			}, wt.prototype.rotateAxis = function(e) {
				console.warn(
					"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
					), e.transformDirection(this)
			}, wt.prototype.crossVector = function(e) {
				return console.warn(
					"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
					), e.applyMatrix4(this)
			}, wt.prototype.translate = function() {
				console.error("THREE.Matrix4: .translate() has been removed.")
			}, wt.prototype.rotateX = function() {
				console.error("THREE.Matrix4: .rotateX() has been removed.")
			}, wt.prototype.rotateY = function() {
				console.error("THREE.Matrix4: .rotateY() has been removed.")
			}, wt.prototype.rotateZ = function() {
				console.error("THREE.Matrix4: .rotateZ() has been removed.")
			}, wt.prototype.rotateByAxis = function() {
				console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
			}, wt.prototype.applyToBufferAttribute = function(e) {
				return console.warn(
					"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
					), e.applyMatrix4(this)
			}, wt.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
			}, wt.prototype.makeFrustum = function(e, t, n, r, i, a) {
				return console.warn(
					"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
					), this.makePerspective(e, t, r, n, i, a)
			}, wt.prototype.getInverse = function(e) {
				return console.warn(
					"THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
					), this.copy(e).invert()
			}, Jt.prototype.isIntersectionLine = function(e) {
				return console.warn(
					"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
					), this.intersectsLine(e)
			}, We.prototype.multiplyVector3 = function(e) {
				return console.warn(
					"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
					), e.applyQuaternion(this)
			}, We.prototype.inverse = function() {
				return console.warn(
						"THREE.Quaternion: .inverse() has been renamed to invert()."),
					this.invert()
			}, bt.prototype.isIntersectionBox = function(e) {
				return console.warn(
					"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
					), this.intersectsBox(e)
			}, bt.prototype.isIntersectionPlane = function(e) {
				return console.warn(
					"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
					), this.intersectsPlane(e)
			}, bt.prototype.isIntersectionSphere = function(e) {
				return console.warn(
					"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
					), this.intersectsSphere(e)
			}, un.prototype.area = function() {
				return console.warn(
						"THREE.Triangle: .area() has been renamed to .getArea()."), this
					.getArea()
			}, un.prototype.barycoordFromPoint = function(e, t) {
				return console.warn(
					"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
					), this.getBarycoord(e, t)
			}, un.prototype.midpoint = function(e) {
				return console.warn(
					"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
					), this.getMidpoint(e)
			}, un.prototypenormal = function(e) {
				return console.warn(
						"THREE.Triangle: .normal() has been renamed to .getNormal()."),
					this.getNormal(e)
			}, un.prototype.plane = function(e) {
				return console.warn(
						"THREE.Triangle: .plane() has been renamed to .getPlane()."),
					this.getPlane(e)
			}, un.barycoordFromPoint = function(e, t, n, r, i) {
				return console.warn(
					"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
					), un.getBarycoord(e, t, n, r, i)
			}, un.normal = function(e, t, n, r) {
				return console.warn(
						"THREE.Triangle: .normal() has been renamed to .getNormal()."),
					un.getNormal(e, t, n, r)
			}, Ql.prototype.extractAllPoints = function(e) {
				return console.warn(
					"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
					), this.extractPoints(e)
			}, Ql.prototype.extrude = function(e) {
				return console.warn(
					"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
					), new Ps(this, e)
			}, Ql.prototype.makeGeometry = function(e) {
				return console.warn(
					"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
					), new Fs(this, e)
			}, Ie.prototype.fromAttribute = function(e, t, n) {
				return console.warn(
					"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
					), this.fromBufferAttribute(e, t, n)
			}, Ie.prototype.distanceToManhattan = function(e) {
				return console.warn(
					"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
					), this.manhattanDistanceTo(e)
			}, Ie.prototype.lengthManhattan = function() {
				return console.warn(
					"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
					), this.manhattanLength()
			}, je.prototype.setEulerFromRotationMatrix = function() {
				console.error(
					"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
					)
			}, je.prototype.setEulerFromQuaternion = function() {
				console.error(
					"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
					)
			}, je.prototype.getPositionFromMatrix = function(e) {
				return console.warn(
					"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
					), this.setFromMatrixPosition(e)
			}, je.prototype.getScaleFromMatrix = function(e) {
				return console.warn(
					"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
					), this.setFromMatrixScale(e)
			}, je.prototype.getColumnFromMatrix = function(e, t) {
				return console.warn(
					"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
					), this.setFromMatrixColumn(t, e)
			}, je.prototype.applyProjection = function(e) {
				return console.warn(
					"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
					), this.applyMatrix4(e)
			}, je.prototype.fromAttribute = function(e, t, n) {
				return console.warn(
					"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
					), this.fromBufferAttribute(e, t, n)
			}, je.prototype.distanceToManhattan = function(e) {
				return console.warn(
					"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
					), this.manhattanDistanceTo(e)
			}, je.prototype.lengthManhattan = function() {
				return console.warn(
					"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
					), this.manhattanLength()
			}, He.prototype.fromAttribute = function(e, t, n) {
				return console.warn(
					"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
					), this.fromBufferAttribute(e, t, n)
			}, He.prototype.lengthManhattan = function() {
				return console.warn(
					"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
					), this.manhattanLength()
			}, Xt.prototype.getChildByName = function(e) {
				return console.warn(
					"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
					), this.getObjectByName(e)
			}, Xt.prototype.renderDepth = function() {
				console.warn(
					"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
					)
			}, Xt.prototype.translate = function(e, t) {
				return console.warn(
					"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
					), this.translateOnAxis(t, e)
			}, Xt.prototype.getWorldRotation = function() {
				console.error(
					"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
					)
			}, Xt.prototype.applyMatrix = function(e) {
				return console.warn(
					"THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
					), this.applyMatrix4(e)
			}, Object.defineProperties(Xt.prototype, {
				eulerOrder: {
					get: function() {
						return console.warn(
							"THREE.Object3D: .eulerOrder is now .rotation.order."
							), this.rotation.order
					},
					set: function(e) {
						console.warn(
							"THREE.Object3D: .eulerOrder is now .rotation.order."
							), this.rotation.order = e
					}
				},
				useQuaternion: {
					get: function() {
						console.warn(
							"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
							)
					},
					set: function() {
						console.warn(
							"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
							)
					}
				}
			}), sr.prototype.setDrawMode = function() {
				console.error(
					"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
					)
			}, Object.defineProperties(sr.prototype, {
				drawMode: {
					get: function() {
						return console.error(
							"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
							), 0
					},
					set: function() {
						console.error(
							"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
							)
					}
				}
			}), mo.prototype.initBones = function() {
				console.error("THREE.SkinnedMesh: initBones() has been removed.")
			}, vr.prototype.setLens = function(e, t) {
				console.warn(
					"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
					), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
			}, Object.defineProperties(Kl.prototype, {
				onlyShadow: {
					set: function() {
						console.warn(
							"THREE.Light: .onlyShadow has been removed.")
					}
				},
				shadowCameraFov: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
							), this.shadow.camera.fov = e
					}
				},
				shadowCameraLeft: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
							), this.shadow.camera.left = e
					}
				},
				shadowCameraRight: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraRight is now .shadow.camera.right."
							), this.shadow.camera.right = e
					}
				},
				shadowCameraTop: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraTop is now .shadow.camera.top."
							), this.shadow.camera.top = e
					}
				},
				shadowCameraBottom: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
							), this.shadow.camera.bottom = e
					}
				},
				shadowCameraNear: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraNear is now .shadow.camera.near."
							), this.shadow.camera.near = e
					}
				},
				shadowCameraFar: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowCameraFar is now .shadow.camera.far."
							), this.shadow.camera.far = e
					}
				},
				shadowCameraVisible: {
					set: function() {
						console.warn(
							"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
							)
					}
				},
				shadowBias: {
					set: function(e) {
						console.warn(
								"THREE.Light: .shadowBias is now .shadow.bias."
								), this.shadow.bias = e
					}
				},
				shadowDarkness: {
					set: function() {
						console.warn(
							"THREE.Light: .shadowDarkness has been removed."
							)
					}
				},
				shadowMapWidth: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
							), this.shadow.mapSize.width = e
					}
				},
				shadowMapHeight: {
					set: function(e) {
						console.warn(
							"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
							), this.shadow.mapSize.height = e
					}
				}
			}), Object.defineProperties(wn.prototype, {
				length: {
					get: function() {
						return console.warn(
							"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
							), this.array.length
					}
				},
				dynamic: {
					get: function() {
						return console.warn(
							"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
							), this.usage === ge
					},
					set: function() {
						console.warn(
							"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
							), this.setUsage(ge)
					}
				}
			}), wn.prototype.setDynamic = function(e) {
				return console.warn(
					"THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
					), this.setUsage(!0 === e ? ge : me), this
			}, wn.prototype.copyIndicesArray = function() {
				console.error(
					"THREE.BufferAttribute: .copyIndicesArray() has been removed.")
			}, wn.prototype.setArray = function() {
				console.error(
					"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					)
			}, Vn.prototype.addIndex = function(e) {
				console.warn(
					"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
					), this.setIndex(e)
			}, Vn.prototype.addAttribute = function(e, t) {
				return console.warn(
						"THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
						), t && t.isBufferAttribute || t && t
					.isInterleavedBufferAttribute ? "index" === e ? (console.warn(
						"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
						), this.setIndex(t), this) : this.setAttribute(e, t) : (console
						.warn(
							"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
							), this.setAttribute(e, new wn(arguments[1], arguments[2])))
			}, Vn.prototype.addDrawCall = function(e, t, n) {
				void 0 !== n && console.warn(
						"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
						), console.warn(
						"THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
					this.addGroup(e, t)
			}, Vn.prototype.clearDrawCalls = function() {
				console.warn(
					"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
					), this.clearGroups()
			}, Vn.prototype.computeOffsets = function() {
				console.warn(
					"THREE.BufferGeometry: .computeOffsets() has been removed.")
			}, Vn.prototype.removeAttribute = function(e) {
				return console.warn(
					"THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
					), this.deleteAttribute(e)
			}, Vn.prototype.applyMatrix = function(e) {
				return console.warn(
					"THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
					), this.applyMatrix4(e)
			}, Object.defineProperties(Vn.prototype, {
				drawcalls: {
					get: function() {
						return console.error(
							"THREE.BufferGeometry: .drawcalls has been renamed to .groups."
							), this.groups
					}
				},
				offsets: {
					get: function() {
						return console.warn(
							"THREE.BufferGeometry: .offsets has been renamed to .groups."
							), this.groups
					}
				}
			}), Ga.prototype.setDynamic = function(e) {
				return console.warn(
					"THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
					), this.setUsage(!0 === e ? ge : me), this
			}, Ga.prototype.setArray = function() {
				console.error(
					"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
					)
			}, Ps.prototype.getArrays = function() {
				console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
			}, Ps.prototype.addShapeList = function() {
				console.error(
					"THREE.ExtrudeGeometry: .addShapeList() has been removed.")
			}, Ps.prototype.addShape = function() {
				console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
			}, Ua.prototype.dispose = function() {
				console.error("THREE.Scene: .dispose() has been removed.")
			}, cc.prototype.onUpdate = function() {
				return console.warn(
					"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
					), this
			}, Object.defineProperties(hn.prototype, {
				wrapAround: {
					get: function() {
						console.warn(
							"THREE.Material: .wrapAround has been removed.")
					},
					set: function() {
						console.warn(
							"THREE.Material: .wrapAround has been removed.")
					}
				},
				overdraw: {
					get: function() {
						console.warn(
							"THREE.Material: .overdraw has been removed.")
					},
					set: function() {
						console.warn(
							"THREE.Material: .overdraw has been removed.")
					}
				},
				wrapRGB: {
					get: function() {
						return console.warn(
								"THREE.Material: .wrapRGB has been removed."),
							new yn
					}
				},
				shading: {
					get: function() {
						console.error("THREE." + this.type +
							": .shading has been removed. Use the boolean .flatShading instead."
							)
					},
					set: function(e) {
						console.warn("THREE." + this.type +
							": .shading has been removed. Use the boolean .flatShading instead."
							), this.flatShading = 1 === e
					}
				},
				stencilMask: {
					get: function() {
						return console.warn("THREE." + this.type +
							": .stencilMask has been removed. Use .stencilFuncMask instead."
							), this.stencilFuncMask
					},
					set: function(e) {
						console.warn("THREE." + this.type +
							": .stencilMask has been removed. Use .stencilFuncMask instead."
							), this.stencilFuncMask = e
					}
				}
			}), Object.defineProperties(fr.prototype, {
				derivatives: {
					get: function() {
						return console.warn(
							"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
							), this.extensions.derivatives
					},
					set: function(e) {
						console.warn(
							"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
							), this.extensions.derivatives = e
					}
				}
			}), Ba.prototype.clearTarget = function(e, t, n, r) {
				console.warn(
					"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
					), this.setRenderTarget(e), this.clear(t, n, r)
			}, Ba.prototype.animate = function(e) {
				console.warn(
						"THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
					this.setAnimationLoop(e)
			}, Ba.prototype.getCurrentRenderTarget = function() {
				return console.warn(
					"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
					), this.getRenderTarget()
			}, Ba.prototype.getMaxAnisotropy = function() {
				return console.warn(
					"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
					), this.capabilities.getMaxAnisotropy()
			}, Ba.prototype.getPrecision = function() {
				return console.warn(
					"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
					), this.capabilities.precision
			}, Ba.prototype.resetGLState = function() {
				return console.warn(
						"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
					this.state.reset()
			}, Ba.prototype.supportsFloatTextures = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
					), this.extensions.get("OES_texture_float")
			}, Ba.prototype.supportsHalfFloatTextures = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
					), this.extensions.get("OES_texture_half_float")
			}, Ba.prototype.supportsStandardDerivatives = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
					), this.extensions.get("OES_standard_derivatives")
			}, Ba.prototype.supportsCompressedTextureS3TC = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
					), this.extensions.get("WEBGL_compressed_texture_s3tc")
			}, Ba.prototype.supportsCompressedTexturePVRTC = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
					), this.extensions.get("WEBGL_compressed_texture_pvrtc")
			}, Ba.prototype.supportsBlendMinMax = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
					), this.extensions.get("EXT_blend_minmax")
			}, Ba.prototype.supportsVertexTextures = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
					), this.capabilities.vertexTextures
			}, Ba.prototype.supportsInstancedArrays = function() {
				return console.warn(
					"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
					), this.extensions.get("ANGLE_instanced_arrays")
			}, Ba.prototype.enableScissorTest = function(e) {
				console.warn(
					"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
					), this.setScissorTest(e)
			}, Ba.prototype.initMaterial = function() {
				console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
			}, Ba.prototype.addPrePlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
			}, Ba.prototype.addPostPlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
			}, Ba.prototype.updateShadowMap = function() {
				console.warn(
					"THREE.WebGLRenderer: .updateShadowMap() has been removed.")
			}, Ba.prototype.setFaceCulling = function() {
				console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
			}, Ba.prototype.allocTextureUnit = function() {
				console.warn(
					"THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
			}, Ba.prototype.setTexture = function() {
				console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
			}, Ba.prototype.setTexture2D = function() {
				console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
			}, Ba.prototype.setTextureCube = function() {
				console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
			}, Ba.prototype.getActiveMipMapLevel = function() {
				return console.warn(
					"THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
					), this.getActiveMipmapLevel()
			}, Object.defineProperties(Ba.prototype, {
				shadowMapEnabled: {
					get: function() {
						return this.shadowMap.enabled
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
							), this.shadowMap.enabled = e
					}
				},
				shadowMapType: {
					get: function() {
						return this.shadowMap.type
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
							), this.shadowMap.type = e
					}
				},
				shadowMapCullFace: {
					get: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
							)
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
							)
					}
				},
				context: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
							), this.getContext()
					}
				},
				vr: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderer: .vr has been renamed to .xr"
							), this.xr
					}
				},
				gammaInput: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
							), !1
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
							)
					}
				},
				gammaOutput: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
							), !1
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
							), this.outputEncoding = !0 === e ? ue : le
					}
				},
				toneMappingWhitePoint: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
							), 1
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
							)
					}
				}
			}), Object.defineProperties(Aa.prototype, {
				cullFace: {
					get: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
							)
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
							)
					}
				},
				renderReverseSided: {
					get: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
							)
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
							)
					}
				},
				renderSingleSided: {
					get: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
							)
					},
					set: function() {
						console.warn(
							"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
							)
					}
				}
			}), Object.defineProperties(Ue.prototype, {
				wrapS: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
							), this.texture.wrapS
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
							), this.texture.wrapS = e
					}
				},
				wrapT: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
							), this.texture.wrapT
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
							), this.texture.wrapT = e
					}
				},
				magFilter: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
							), this.texture.magFilter
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
							), this.texture.magFilter = e
					}
				},
				minFilter: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
							), this.texture.minFilter
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
							), this.texture.minFilter = e
					}
				},
				anisotropy: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
							), this.texture.anisotropy
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
							), this.texture.anisotropy = e
					}
				},
				offset: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .offset is now .texture.offset."
							), this.texture.offset
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .offset is now .texture.offset."
							), this.texture.offset = e
					}
				},
				repeat: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
							), this.texture.repeat
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
							), this.texture.repeat = e
					}
				},
				format: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .format is now .texture.format."
							), this.texture.format
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .format is now .texture.format."
							), this.texture.format = e
					}
				},
				type: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .type is now .texture.type."
							), this.texture.type
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .type is now .texture.type."
							), this.texture.type = e
					}
				},
				generateMipmaps: {
					get: function() {
						return console.warn(
							"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
							), this.texture.generateMipmaps
					},
					set: function(e) {
						console.warn(
							"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
							), this.texture.generateMipmaps = e
					}
				}
			}), Wu.prototype.load = function(e) {
				console.warn(
					"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
					);
				var t = this;
				return (new Iu).load(e, (function(e) {
					t.setBuffer(e)
				})), this
			}, $u.prototype.getData = function() {
				return console.warn(
						"THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
					this.getFrequencyData()
			}, gr.prototype.updateCubeMap = function(e, t) {
				return console.warn(
						"THREE.CubeCamera: .updateCubeMap() is now .update()."), this
					.update(e, t)
			}, gr.prototype.clear = function(e, t, n, r) {
				return console.warn(
						"THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
					this.renderTarget.clear(e, t, n, r)
			}, Oe.crossOrigin = void 0, Oe.loadTexture = function(e, t, n, r) {
				console.warn(
					"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
					);
				var i = new kl;
				i.setCrossOrigin(this.crossOrigin);
				var a = i.load(e, n, void 0, r);
				return t && (a.mapping = t), a
			}, Oe.loadTextureCube = function(e, t, n, r) {
				console.warn(
					"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
					);
				var i = new Al;
				i.setCrossOrigin(this.crossOrigin);
				var a = i.load(e, n, void 0, r);
				return t && (a.mapping = t), a
			}, Oe.loadCompressedTexture = function() {
				console.error(
					"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
					)
			}, Oe.loadCompressedTextureCube = function() {
				console.error(
					"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
					)
			};
			var fh = {
				createMultiMaterialObject: function() {
					console.error(
						"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
						)
				},
				detach: function() {
					console.error(
						"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
						)
				},
				attach: function() {
					console.error(
						"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
						)
				}
			};
			"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(
					new CustomEvent("register", {
						detail: {
							revision: n
						}
					})), "undefined" != typeof window && (window.__THREE__ ? console.warn(
						"WARNING: Multiple instances of Three.js being imported.") : window
					.__THREE__ = n), e.ACESFilmicToneMapping = 4, e.AddEquation = r, e
				.AddOperation = 2, e.AdditiveAnimationBlendMode = se, e.AdditiveBlending =
				2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e
				.AmbientLight = vu, e.AmbientLightProbe = Nu, e.AnimationClip = yl, e
				.AnimationLoader = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new Tl(this.manager);
							a.setPath(this.path), a.setRequestHeader(this
								.requestHeader), a.setWithCredentials(
								this.withCredentials), a.load(e, (
								function(n) {
									try {
										t(i.parse(JSON.parse(n)))
									} catch (t) {
										r ? r(t) : console.error(t),
											i.manager.itemError(e)
									}
								}), n, r)
						}
					}, {
						key: "parse",
						value: function(e) {
							for (var t = [], n = 0; n < e.length; n++) {
								var r = yl.parse(e[n]);
								t.push(r)
							}
							return t
						}
					}]), n
				}(Ml), e.AnimationMixer = uc, e.AnimationObjectGroup = sc, e
				.AnimationUtils = al, e.ArcCurve = Pl, e.ArrayCamera = Ca, e.ArrowHelper =
				function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : new je(0, 0, 1),
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : new je(0, 0, 0),
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 1,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 16776960,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : .2 * a,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : .2 * s;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"ArrowHelper", void 0 === Bc && ((Bc = new Vn).setAttribute(
								"position", new Cn([0, 0, 0, 0, 1, 0], 3)), (zc =
								new Zo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), e.position
							.copy(i), e.line = new Io(Bc, new Ao({
								color: o,
								toneMapped: !1
							})), e.line.matrixAutoUpdate = !1, e.add(e.line), e.cone =
							new sr(zc, new xn({
								color: o,
								toneMapped: !1
							})), e.cone.matrixAutoUpdate = !1, e.add(e.cone), e
							.setDirection(r), e.setLength(a, s, l), e
					}
					return (0, y.default)(n, [{
						key: "setDirection",
						value: function(e) {
							if (e.y > .99999) this.quaternion.set(0, 0, 0,
								1);
							else if (e.y < -.99999) this.quaternion.set(1,
								0, 0, 0);
							else {
								Uc.set(e.z, 0, -e.x).normalize();
								var t = Math.acos(e.y);
								this.quaternion.setFromAxisAngle(Uc, t)
							}
						}
					}, {
						key: "setLength",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : .2 * e,
								n = arguments.length > 2 && void 0 !==
								arguments[2] ? arguments[2] : .2 * t;
							this.line.scale.set(1, Math.max(1e-4, e - t),
								1), this.line.updateMatrix(), this.cone
								.scale.set(n, t, n), this.cone.position.y =
								e, this.cone.updateMatrix()
						}
					}, {
						key: "setColor",
						value: function(e) {
							this.line.material.color.set(e), this.cone
								.material.color.set(e)
						}
					}, {
						key: "copy",
						value: function(e) {
							return (0, h.default)((0, m.default)(n
									.prototype), "copy", this).call(this, e,
									!1), this.line.copy(e.line), this.cone
								.copy(e.cone), this
						}
					}]), n
				}(Xt), e.Audio = Wu, e.AudioAnalyser = $u, e.AudioContext = Pu, e
				.AudioListener = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e;
						return (0, g.default)(this, n), (e = t.call(this)).type =
							"AudioListener", e.context = Pu.getContext(), e.gain = e.context
							.createGain(), e.gain.connect(e.context.destination), e.filter =
							null, e.timeDelta = 0, e._clock = new zu, e
					}
					return (0, y.default)(n, [{
						key: "getInput",
						value: function() {
							return this.gain
						}
					}, {
						key: "removeFilter",
						value: function() {
							return null !== this.filter && (this.gain
									.disconnect(this.filter), this.filter
									.disconnect(this.context.destination),
									this.gain.connect(this.context
										.destination), this.filter = null),
								this
						}
					}, {
						key: "getFilter",
						value: function() {
							return this.filter
						}
					}, {
						key: "setFilter",
						value: function(e) {
							return null !== this.filter ? (this.gain
									.disconnect(this.filter), this.filter
									.disconnect(this.context.destination)) :
								this.gain.disconnect(this.context
									.destination), this.filter = e, this
								.gain.connect(this.filter), this.filter
								.connect(this.context.destination), this
						}
					}, {
						key: "getMasterVolume",
						value: function() {
							return this.gain.gain.value
						}
					}, {
						key: "setMasterVolume",
						value: function(e) {
							return this.gain.gain.setTargetAtTime(e, this
								.context.currentTime, .01), this
						}
					}, {
						key: "updateMatrixWorld",
						value: function(e) {
							(0, h.default)((0, m.default)(n.prototype),
								"updateMatrixWorld", this).call(this, e);
							var t = this.context.listener,
								r = this.up;
							if (this.timeDelta = this._clock.getDelta(),
								this.matrixWorld.decompose(Hu, Uu, Gu), Vu
								.set(0, 0, -1).applyQuaternion(Uu), t
								.positionX) {
								var i = this.context.currentTime + this
									.timeDelta;
								t.positionX.linearRampToValueAtTime(Hu.x,
									i), t.positionY.linearRampToValueAtTime(
										Hu.y, i), t.positionZ
									.linearRampToValueAtTime(Hu.z, i), t
									.forwardX.linearRampToValueAtTime(Vu.x,
										i), t.forwardY
									.linearRampToValueAtTime(Vu.y, i), t
									.forwardZ.linearRampToValueAtTime(Vu.z,
										i), t.upX.linearRampToValueAtTime(r
										.x, i), t.upY
									.linearRampToValueAtTime(r.y, i), t.upZ
									.linearRampToValueAtTime(r.z, i)
							} else t.setPosition(Hu.x, Hu.y, Hu.z), t
								.setOrientation(Vu.x, Vu.y, Vu.z, r.x, r.y,
									r.z)
						}
					}]), n
				}(Xt), e.AudioLoader = Iu, e.AxesHelper = Gc, e.AxisHelper = function(e) {
					return console.warn(
							"THREE.AxisHelper has been renamed to THREE.AxesHelper."),
						new Gc(e)
				}, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e
				.BinaryTextureLoader = function(e) {
					return console.warn(
						"THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
						), new Ll(e)
				}, e.Bone = go, e.BooleanKeyframeTrack = hl, e.BoundingBoxHelper = function(
					e, t) {
					return console.warn(
						"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
						), new Hc(e, t)
				}, e.Box2 = mc, e.Box3 = Ye, e.Box3Helper = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 16776960;
						(0, g.default)(this, n);
						var a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7,
								7, 4, 0, 4, 1, 5, 2, 6, 3, 7
							]),
							o = new Vn;
						return o.setIndex(new wn(a, 1)), o.setAttribute("position", new Cn([
								1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -
								1, 1, -1, -1, -1, -1, 1, -1, -1
							], 3)), (r = t.call(this, o, new Ao({
								color: i,
								toneMapped: !1
							}))).box = e, r.type = "Box3Helper", r.geometry
							.computeBoundingSphere(), r
					}
					return (0, y.default)(n, [{
						key: "updateMatrixWorld",
						value: function(e) {
							var t = this.box;
							t.isEmpty() || (t.getCenter(this.position), t
								.getSize(this.scale), this.scale
								.multiplyScalar(.5), (0, h.default)((0,
										m.default)(n.prototype),
									"updateMatrixWorld", this).call(
									this, e))
						}
					}]), n
				}(Oo), e.BoxBufferGeometry = ur, e.BoxGeometry = ur, e.BoxHelper = Hc, e
				.BufferAttribute = wn, e.BufferGeometry = Vn, e.BufferGeometryLoader = Mu, e
				.ByteType = 1010, e.Cache = _l, e.Camera = pr, e.CameraHelper = function(
				e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						(0, g.default)(this, n);
						var i = new Vn,
							a = new Ao({
								color: 16777215,
								vertexColors: !0,
								toneMapped: !1
							}),
							o = [],
							s = [],
							l = {},
							u = new yn(16755200),
							c = new yn(16711680),
							h = new yn(43775),
							d = new yn(16777215),
							f = new yn(3355443);

						function p(e, t, n) {
							v(e, n), v(t, n)
						}

						function v(e, t) {
							o.push(0, 0, 0), s.push(t.r, t.g, t.b), void 0 === l[e] && (l[
								e] = []), l[e].push(o.length / 3 - 1)
						}
						return p("n1", "n2", u), p("n2", "n4", u), p("n4", "n3", u), p("n3",
								"n1", u), p("f1", "f2", u), p("f2", "f4", u), p("f4", "f3",
								u), p("f3", "f1", u), p("n1", "f1", u), p("n2", "f2", u), p(
								"n3", "f3", u), p("n4", "f4", u), p("p", "n1", c), p("p",
								"n2", c), p("p", "n3", c), p("p", "n4", c), p("u1", "u2",
							h), p("u2", "u3", h), p("u3", "u1", h), p("c", "t", d), p("p",
								"c", f), p("cn1", "cn2", f), p("cn3", "cn4", f), p("cf1",
								"cf2", f), p("cf3", "cf4", f), i.setAttribute("position",
								new Cn(o, 3)), i.setAttribute("color", new Cn(s, 3)), (r = t
								.call(this, i, a)).type = "CameraHelper", r.camera = e, r
							.camera.updateProjectionMatrix && r.camera
							.updateProjectionMatrix(), r.matrix = e.matrixWorld, r
							.matrixAutoUpdate = !1, r.pointMap = l, r.update(), r
					}
					return (0, y.default)(n, [{
						key: "update",
						value: function() {
							var e = this.geometry,
								t = this.pointMap;
							Nc.projectionMatrixInverse.copy(this.camera
									.projectionMatrixInverse), Oc("c", t, e,
									Nc, 0, 0, -1), Oc("t", t, e, Nc, 0, 0,
									1), Oc("n1", t, e, Nc, -1, -1, -1), Oc(
									"n2", t, e, Nc, 1, -1, -1), Oc("n3", t,
									e, Nc, -1, 1, -1), Oc("n4", t, e, Nc, 1,
									1, -1), Oc("f1", t, e, Nc, -1, -1, 1),
								Oc("f2", t, e, Nc, 1, -1, 1), Oc("f3", t, e,
									Nc, -1, 1, 1), Oc("f4", t, e, Nc, 1, 1,
									1), Oc("u1", t, e, Nc, .7, 1.1, -1), Oc(
									"u2", t, e, Nc, -.7, 1.1, -1), Oc("u3",
									t, e, Nc, 0, 2, -1), Oc("cf1", t, e, Nc,
									-1, 0, 1), Oc("cf2", t, e, Nc, 1, 0, 1),
								Oc("cf3", t, e, Nc, 0, -1, 1), Oc("cf4", t,
									e, Nc, 0, 1, 1), Oc("cn1", t, e, Nc, -1,
									0, -1), Oc("cn2", t, e, Nc, 1, 0, -1),
								Oc("cn3", t, e, Nc, 0, -1, -1), Oc("cn4", t,
									e, Nc, 0, 1, -1), e.getAttribute(
									"position").needsUpdate = !0
						}
					}, {
						key: "dispose",
						value: function() {
							this.geometry.dispose(), this.material.dispose()
						}
					}]), n
				}(Oo), e.CanvasRenderer = function() {
					console.error("THREE.CanvasRenderer has been removed")
				}, e.CanvasTexture = Xo, e.CatmullRomCurve3 = zl, e.CineonToneMapping = 3, e
				.CircleBufferGeometry = $o, e.CircleGeometry = $o, e.ClampToEdgeWrapping =
				E, e.Clock = zu, e.Color = yn, e.ColorKeyframeTrack = dl, e
				.CompressedTexture = qo, e.CompressedTextureLoader = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = [],
								o = new qo,
								s = new Tl(this.manager);
							s.setPath(this.path), s.setResponseType(
								"arraybuffer"), s.setRequestHeader(this
								.requestHeader), s.setWithCredentials(i
								.withCredentials);
							var l = 0;

							function u(u) {
								s.load(e[u], (function(e) {
									var n = i.parse(e, !0);
									a[u] = {
										width: n.width,
										height: n.height,
										format: n.format,
										mipmaps: n.mipmaps
									}, 6 === (l += 1) && (
										1 === n
										.mipmapCount && (o
											.minFilter = C),
										o.image = a, o
										.format = n.format,
										o.needsUpdate = !0,
										t && t(o))
								}), n, r)
							}
							if (Array.isArray(e))
								for (var c = 0, h = e.length; c < h; ++c) u(
									c);
							else s.load(e, (function(e) {
								var n = i.parse(e, !0);
								if (n.isCubemap) {
									for (var r = n.mipmaps
											.length / n
											.mipmapCount, s =
											0; s < r; s++) {
										a[s] = {
											mipmaps: []
										};
										for (var l = 0; l < n
											.mipmapCount; l++)
											a[s].mipmaps.push(n
												.mipmaps[s * n
													.mipmapCount +
													l]), a[s]
											.format = n.format,
											a[s].width = n
											.width, a[s]
											.height = n.height
									}
									o.image = a
								} else o.image.width = n.width,
									o.image.height = n.height, o
									.mipmaps = n.mipmaps;
								1 === n.mipmapCount && (o
										.minFilter = C), o
									.format = n.format, o
									.needsUpdate = !0, t && t(o)
							}), n, r);
							return o
						}
					}]), n
				}(Ml), e.ConeBufferGeometry = Jo, e.ConeGeometry = Jo, e.CubeCamera = gr, e
				.CubeReflectionMapping = a, e.CubeRefractionMapping = o, e.CubeTexture = yr,
				e.CubeTextureLoader = Al, e.CubeUVReflectionMapping = b, e
				.CubeUVRefractionMapping = S, e.CubicBezierCurve = Gl, e.CubicBezierCurve3 =
				Vl, e.CubicInterpolant = sl, e.CullFaceBack = 1, e.CullFaceFront = 2, e
				.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Rl, e.CurvePath = Zl,
				e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry =
				Zo, e.CylinderGeometry = Zo, e.Cylindrical = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : 1,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0;
						return (0, g.default)(this, e), this.radius = t, this.theta = n,
							this.y = r, this
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t, n) {
							return this.radius = e, this.theta = t, this.y =
								n, this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.radius = e.radius, this.theta = e
								.theta, this.y = e.y, this
						}
					}, {
						key: "setFromVector3",
						value: function(e) {
							return this.setFromCartesianCoords(e.x, e.y, e
								.z)
						}
					}, {
						key: "setFromCartesianCoords",
						value: function(e, t, n) {
							return this.radius = Math.sqrt(e * e + n * n),
								this.theta = Math.atan2(e, n), this.y = t,
								this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}(), e.DataTexture = yo, e.DataTexture2DArray = Vr, e.DataTexture3D = Wr, e
				.DataTextureLoader = Ll, e.DataUtils = function() {
					function e() {
						(0, g.default)(this, e)
					}
					return (0, y.default)(e, null, [{
						key: "toHalfFloat",
						value: function(e) {
							Vc[0] = e;
							var t = Wc[0],
								n = t >> 16 & 32768,
								r = t >> 12 & 2047,
								i = t >> 23 & 255;
							return i < 103 ? n : i > 142 ? (n |= 31744, n |=
									(255 == i ? 0 : 1) && 8388607 & t) : i <
								113 ? n |= ((r |= 2048) >> 114 - i) + (r >>
									113 - i & 1) : (n |= i - 112 << 10 |
									r >> 1, n += 1 & r)
						}
					}]), e
				}(), e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e
				.DefaultLoadingManager = wl, e.DepthFormat = G, e.DepthStencilFormat = V, e
				.DepthTexture = Yo, e.DirectionalLight = pu, e.DirectionalLightHelper =
				function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						(0, g.default)(this, n), (a = t.call(this)).light = e, a.light
							.updateMatrixWorld(), a.matrix = e.matrixWorld, a
							.matrixAutoUpdate = !1, a.color = i, void 0 === r && (r = 1);
						var o = new Vn;
						o.setAttribute("position", new Cn([-r, r, 0, r, r, 0, r, -r, 0, -r,
							-r, 0, -r, r, 0
						], 3));
						var s = new Ao({
							fog: !1,
							toneMapped: !1
						});
						return a.lightPlane = new Io(o, s), a.add(a.lightPlane), (o =
								new Vn).setAttribute("position", new Cn([0, 0, 0, 0, 0, 1],
								3)), a.targetLine = new Io(o, s), a.add(a.targetLine), a
							.update(), a
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {
							this.lightPlane.geometry.dispose(), this
								.lightPlane.material.dispose(), this
								.targetLine.geometry.dispose(), this
								.targetLine.material.dispose()
						}
					}, {
						key: "update",
						value: function() {
							Cc.setFromMatrixPosition(this.light
								.matrixWorld), Pc.setFromMatrixPosition(this
									.light.target.matrixWorld), Ic
								.subVectors(Pc, Cc), this.lightPlane.lookAt(
									Pc), void 0 !== this.color ? (this
									.lightPlane.material.color.set(this
										.color), this.targetLine.material
									.color.set(this.color)) : (this
									.lightPlane.material.color.copy(this
										.light.color), this.targetLine
									.material.color.copy(this.light.color)),
								this.targetLine.lookAt(Pc), this.targetLine
								.scale.z = Ic.length()
						}
					}]), n
				}(Xt), e.DiscreteInterpolant = ul, e.DodecahedronBufferGeometry = Ko, e
				.DodecahedronGeometry = Ko, e.DoubleSide = 2, e.DstAlphaFactor = 206, e
				.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) {
					return console.warn(
						"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
						), new wn(e, t).setUsage(ge)
				}, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = ge, e.DynamicReadUsage =
				35049, e.EdgesGeometry = is, e.EdgesHelper = function(e, t) {
					return console.warn(
						"THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
						), new Oo(new is(e.geometry), new Ao({
						color: void 0 !== t ? t : 16777215
					}))
				}, e.EllipseCurve = Cl, e.EqualDepth = 4, e.EqualStencilFunc = 514, e
				.EquirectangularReflectionMapping = s, e.EquirectangularRefractionMapping =
				x, e.Euler = Pt, e.EventDispatcher = xe, e.ExtrudeBufferGeometry = Ps, e
				.ExtrudeGeometry = Ps, e.FaceColors = 1, e.FileLoader = Tl, e.FlatShading =
				1, e.Float16BufferAttribute = Rn, e.Float32Attribute = function(e, t) {
					return console.warn(
						"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
						), new Cn(e, t)
				}, e.Float32BufferAttribute = Cn, e.Float64Attribute = function(e, t) {
					return console.warn(
						"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
						), new Pn(e, t)
				}, e.Float64BufferAttribute = Pn, e.FloatType = B, e.Fog = Ha, e.FogExp2 =
				Fa, e.Font = Ru, e.FontLoader = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = new Tl(this.manager);
							a.setPath(this.path), a.setRequestHeader(this
								.requestHeader), a.setWithCredentials(i
								.withCredentials), a.load(e, (function(
								e) {
								var n;
								try {
									n = JSON.parse(e)
								} catch (t) {
									console.warn(
										"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
										), n = JSON.parse(e
										.substring(65, e
											.length - 2))
								}
								var r = i.parse(n);
								t && t(r)
							}), n, r)
						}
					}, {
						key: "parse",
						value: function(e) {
							return new Ru(e)
						}
					}]), n
				}(Ml), e.FrontSide = 0, e.Frustum = wr, e.GLBufferAttribute = dc, e.GLSL1 =
				"100", e.GLSL3 = ye, e.GammaEncoding = ce, e.GreaterDepth = 6, e
				.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e
				.GreaterStencilFunc = 516, e.GridHelper = Rc, e.Group = Pa, e
				.HalfFloatType = z, e.HemisphereLight = eu, e.HemisphereLightHelper =
				function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						(0, g.default)(this, n), (a = t.call(this)).light = e, a.light
							.updateMatrixWorld(), a.matrix = e.matrixWorld, a
							.matrixAutoUpdate = !1, a.color = i;
						var o = new Os(r);
						o.rotateY(.5 * Math.PI), a.material = new xn({
							wireframe: !0,
							fog: !1,
							toneMapped: !1
						}), void 0 === a.color && (a.material.vertexColors = !0);
						var s = o.getAttribute("position"),
							l = new Float32Array(3 * s.count);
						return o.setAttribute("color", new wn(l, 3)), a.add(new sr(o, a
							.material)), a.update(), a
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {
							this.children[0].geometry.dispose(), this
								.children[0].material.dispose()
						}
					}, {
						key: "update",
						value: function() {
							var e = this.children[0];
							if (void 0 !== this.color) this.material.color
								.set(this.color);
							else {
								var t = e.geometry.getAttribute("color");
								Lc.copy(this.light.color), kc.copy(this
									.light.groundColor);
								for (var n = 0, r = t.count; n < r; n++) {
									var i = n < r / 2 ? Lc : kc;
									t.setXYZ(n, i.r, i.g, i.b)
								}
								t.needsUpdate = !0
							}
							e.lookAt(Ac.setFromMatrixPosition(this.light
								.matrixWorld).negate())
						}
					}]), n
				}(Xt), e.HemisphereLightProbe = Du, e.IcosahedronBufferGeometry = Ds, e
				.IcosahedronGeometry = Ds, e.ImageBitmapLoader = Au, e.ImageLoader = El, e
				.ImageUtils = Oe, e.ImmediateRenderObject = _c, e.IncrementStencilOp = 7682,
				e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = wu, e
				.InstancedBufferGeometry = bu, e.InstancedInterleavedBuffer = hc, e
				.InstancedMesh = Eo, e.Int16Attribute = function(e, t) {
					return console.warn(
						"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
						), new En(e, t)
				}, e.Int16BufferAttribute = En, e.Int32Attribute = function(e, t) {
					return console.warn(
						"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
						), new Ln(e, t)
				}, e.Int32BufferAttribute = Ln, e.Int8Attribute = function(e, t) {
					return console.warn(
						"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
						), new Mn(e, t)
				}, e.Int8BufferAttribute = Mn, e.IntType = 1013, e.InterleavedBuffer = Ga, e
				.InterleavedBufferAttribute = Wa, e.Interpolant = ol, e
				.InterpolateDiscrete = ee, e.InterpolateLinear = te, e.InterpolateSmooth =
				ne, e.InvertStencilOp = 5386, e.JSONLoader = function() {
					console.error("THREE.JSONLoader has been removed.")
				}, e.KeepStencilOp = ve, e.KeyframeTrack = cl, e.LOD = uo, e
				.LatheBufferGeometry = Ns, e.LatheGeometry = Ns, e.Layers = It, e
				.LensFlare = function() {
					console.error(
						"THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
						)
				}, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e
				.LessStencilFunc = 513, e.Light = Kl, e.LightProbe = yu, e.Line = Io, e
				.Line3 = xc, e.LineBasicMaterial = Ao, e.LineCurve = Wl, e.LineCurve3 = jl,
				e.LineDashedMaterial = rl, e.LineLoop = Bo, e.LinePieces = 1, e
				.LineSegments = Oo, e.LineStrip = 0, e.LinearEncoding = le, e.LinearFilter =
				C, e.LinearInterpolant = ll, e.LinearMipMapLinearFilter = 1008, e
				.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = I, e
				.LinearMipmapNearestFilter = P, e.LinearToneMapping = 1, e.Loader = Ml, e
				.LoaderUtils = _u, e.LoadingManager = bl, e.LogLuvEncoding = 3003, e
				.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e
				.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
					LEFT: 0,
					MIDDLE: 1,
					RIGHT: 2,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2
				}, e.Material = hn, e.MaterialLoader = xu, e.Math = Pe, e.MathUtils = Pe, e
				.Matrix3 = Ne, e.Matrix4 = wt, e.MaxEquation = 104, e.Mesh = sr, e
				.MeshBasicMaterial = xn, e.MeshDepthMaterial = Ta, e.MeshDistanceMaterial =
				Ea, e.MeshFaceMaterial = function(e) {
					return console.warn(
						"THREE.MeshFaceMaterial has been removed. Use an Array instead."
						), e
				}, e.MeshLambertMaterial = tl, e.MeshMatcapMaterial = nl, e
				.MeshNormalMaterial = el, e.MeshPhongMaterial = Qs, e.MeshPhysicalMaterial =
				Js, e.MeshStandardMaterial = Zs, e.MeshToonMaterial = Ks, e.MinEquation =
				103, e.MirroredRepeatWrapping = A, e.MixOperation = 1, e.MultiMaterial =
				function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
						[];
					return console.warn(
							"THREE.MultiMaterial has been removed. Use an Array instead."),
						e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
							return e.slice()
						}, e
				}, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = L, e
				.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e
				.NearestMipmapLinearFilter = R, e.NearestMipmapNearestFilter = k, e
				.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0,
				e.NoToneMapping = 0, e.NormalAnimationBlendMode = oe, e.NormalBlending = 1,
				e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack =
				fl, e.Object3D = Xt, e.ObjectLoader = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						return (0, g.default)(this, n), t.call(this, e)
					}
					return (0, y.default)(n, [{
						key: "load",
						value: function(e, t, n, r) {
							var i = this,
								a = "" === this.path ? _u.extractUrlBase(
								e) : this.path;
							this.resourcePath = this.resourcePath || a;
							var o = new Tl(this.manager);
							o.setPath(this.path), o.setRequestHeader(this
								.requestHeader), o.setWithCredentials(
								this.withCredentials), o.load(e, (
								function(n) {
									var a = null;
									try {
										a = JSON.parse(n)
									} catch (t) {
										return void 0 !== r && r(t),
											void console.error(
												"THREE:ObjectLoader: Can't parse " +
												e + ".", t.message)
									}
									var o = a.metadata;
									void 0 !== o && void 0 !== o
										.type && "geometry" !== o
										.type.toLowerCase() ? i
										.parse(a, t) : console
										.error(
											"THREE.ObjectLoader: Can't load " +
											e)
								}), n, r)
						}
					}, {
						key: "parse",
						value: function(e, t) {
							var n = this.parseAnimations(e.animations),
								r = this.parseShapes(e.shapes),
								i = this.parseGeometries(e.geometries, r),
								a = this.parseImages(e.images, (function() {
									void 0 !== t && t(l)
								})),
								o = this.parseTextures(e.textures, a),
								s = this.parseMaterials(e.materials, o),
								l = this.parseObject(e.object, i, s, n),
								u = this.parseSkeletons(e.skeletons, l);
							if (this.bindSkeletons(l, u), void 0 !== t) {
								var c = !1;
								for (var h in a)
									if (a[h] instanceof HTMLImageElement) {
										c = !0;
										break
									}! 1 === c && t(l)
							}
							return l
						}
					}, {
						key: "parseShapes",
						value: function(e) {
							var t = {};
							if (void 0 !== e)
								for (var n = 0, r = e.length; n < r; n++) {
									var i = (new Ql).fromJSON(e[n]);
									t[i.uuid] = i
								}
							return t
						}
					}, {
						key: "parseSkeletons",
						value: function(e, t) {
							var n = {},
								r = {};
							if (t.traverse((function(e) {
									e.isBone && (r[e.uuid] = e)
								})), void 0 !== e)
								for (var i = 0, a = e.length; i < a; i++) {
									var o = (new bo).fromJSON(e[i], r);
									n[o.uuid] = o
								}
							return n
						}
					}, {
						key: "parseGeometries",
						value: function(e, t) {
							var n, r = {};
							if (void 0 !== e)
								for (var i = new Mu, a = 0, o = e
									.length; a < o; a++) {
									var s = void 0,
										l = e[a];
									switch (l.type) {
										case "PlaneGeometry":
										case "PlaneBufferGeometry":
											s = new Xs[l.type](l.width, l
												.height, l
												.widthSegments, l
												.heightSegments);
											break;
										case "BoxGeometry":
										case "BoxBufferGeometry":
											s = new Xs[l.type](l.width, l
												.height, l.depth, l
												.widthSegments, l
												.heightSegments, l
												.depthSegments);
											break;
										case "CircleGeometry":
										case "CircleBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.segments, l.thetaStart,
												l.thetaLength);
											break;
										case "CylinderGeometry":
										case "CylinderBufferGeometry":
											s = new Xs[l.type](l.radiusTop,
												l.radiusBottom, l
												.height, l
												.radialSegments, l
												.heightSegments, l
												.openEnded, l
												.thetaStart, l
												.thetaLength);
											break;
										case "ConeGeometry":
										case "ConeBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.height, l
												.radialSegments, l
												.heightSegments, l
												.openEnded, l
												.thetaStart, l
												.thetaLength);
											break;
										case "SphereGeometry":
										case "SphereBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.widthSegments, l
												.heightSegments, l
												.phiStart, l.phiLength,
												l.thetaStart, l
												.thetaLength);
											break;
										case "DodecahedronGeometry":
										case "DodecahedronBufferGeometry":
										case "IcosahedronGeometry":
										case "IcosahedronBufferGeometry":
										case "OctahedronGeometry":
										case "OctahedronBufferGeometry":
										case "TetrahedronGeometry":
										case "TetrahedronBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.detail);
											break;
										case "RingGeometry":
										case "RingBufferGeometry":
											s = new Xs[l.type](l
												.innerRadius, l
												.outerRadius, l
												.thetaSegments, l
												.phiSegments, l
												.thetaStart, l
												.thetaLength);
											break;
										case "TorusGeometry":
										case "TorusBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.tube, l.radialSegments,
												l.tubularSegments, l.arc
												);
											break;
										case "TorusKnotGeometry":
										case "TorusKnotBufferGeometry":
											s = new Xs[l.type](l.radius, l
												.tube, l
												.tubularSegments, l
												.radialSegments, l.p, l
												.q);
											break;
										case "TubeGeometry":
										case "TubeBufferGeometry":
											s = new Xs[l.type]((new $l[l
													.path.type])
												.fromJSON(l.path), l
												.tubularSegments, l
												.radius, l
												.radialSegments, l
												.closed);
											break;
										case "LatheGeometry":
										case "LatheBufferGeometry":
											s = new Xs[l.type](l.points, l
												.segments, l.phiStart, l
												.phiLength);
											break;
										case "PolyhedronGeometry":
										case "PolyhedronBufferGeometry":
											s = new Xs[l.type](l.vertices, l
												.indices, l.radius, l
												.details);
											break;
										case "ShapeGeometry":
										case "ShapeBufferGeometry":
											n = [];
											for (var u = 0, c = l.shapes
													.length; u < c; u++) {
												var h = t[l.shapes[u]];
												n.push(h)
											}
											s = new Xs[l.type](n, l
												.curveSegments);
											break;
										case "ExtrudeGeometry":
										case "ExtrudeBufferGeometry":
											n = [];
											for (var d = 0, f = l.shapes
													.length; d < f; d++) {
												var p = t[l.shapes[d]];
												n.push(p)
											}
											var v = l.options.extrudePath;
											void 0 !== v && (l.options
													.extrudePath = (new $l[v
														.type]).fromJSON(v)
													), s = new Xs[l.type](n,
													l.options);
											break;
										case "BufferGeometry":
										case "InstancedBufferGeometry":
											s = i.parse(l);
											break;
										case "Geometry":
											console.error(
												'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
												);
											break;
										default:
											console.warn(
												'THREE.ObjectLoader: Unsupported geometry type "' +
												l.type + '"');
											continue
									}
									s.uuid = l.uuid, void 0 !== l.name && (s
											.name = l.name), !0 === s
										.isBufferGeometry && void 0 !== l
										.userData && (s.userData = l
											.userData), r[l.uuid] = s
								}
							return r
						}
					}, {
						key: "parseMaterials",
						value: function(e, t) {
							var n = {},
								r = {};
							if (void 0 !== e) {
								var i = new xu;
								i.setTextures(t);
								for (var a = 0, o = e.length; a < o; a++) {
									var s = e[a];
									if ("MultiMaterial" === s.type) {
										for (var l = [], u = 0; u < s
											.materials.length; u++) {
											var c = s.materials[u];
											void 0 === n[c.uuid] && (n[c
													.uuid] = i.parse(c)), l
												.push(n[c.uuid])
										}
										r[s.uuid] = l
									} else void 0 === n[s.uuid] && (n[s
											.uuid] = i.parse(s)), r[s
										.uuid] = n[s.uuid]
								}
							}
							return r
						}
					}, {
						key: "parseAnimations",
						value: function(e) {
							var t = {};
							if (void 0 !== e)
								for (var n = 0; n < e.length; n++) {
									var r = e[n],
										i = yl.parse(r);
									t[i.uuid] = i
								}
							return t
						}
					}, {
						key: "parseImages",
						value: function(e, t) {
							var n, r = this,
								i = {};

							function a(e) {
								if ("string" == typeof e) {
									var t = e;
									return function(e) {
										return r.manager.itemStart(e), n
											.load(e, (function() {
												r.manager
													.itemEnd(e)
											}), void 0, (
										function() {
												r.manager
													.itemError(
														e), r
													.manager
													.itemEnd(e)
											}))
									}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(
										t) ? t : r.resourcePath + t)
								}
								return e.data ? {
									data: Nn(e.type, e.data),
									width: e.width,
									height: e.height
								} : null
							}
							if (void 0 !== e && e.length > 0) {
								var o = new bl(t);
								(n = new El(o)).setCrossOrigin(this
									.crossOrigin);
								for (var s = 0, l = e.length; s < l; s++) {
									var u = e[s],
										c = u.url;
									if (Array.isArray(c)) {
										i[u.uuid] = [];
										for (var h = 0, d = c.length; h <
											d; h++) {
											var f = a(c[h]);
											null !== f && (
												f instanceof HTMLImageElement ?
												i[u.uuid].push(f) : i[u
													.uuid].push(new yo(f
													.data, f.width,
													f.height)))
										}
									} else {
										var p = a(u.url);
										null !== p && (i[u.uuid] = p)
									}
								}
							}
							return i
						}
					}, {
						key: "parseTextures",
						value: function(e, t) {
							function n(e, t) {
								return "number" == typeof e ? e : (console
									.warn(
										"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
										e), t[e])
							}
							var r = {};
							if (void 0 !== e)
								for (var i = 0, a = e.length; i < a; i++) {
									var o = e[i],
										s = void 0;
									void 0 === o.image && console.warn(
											'THREE.ObjectLoader: No "image" specified for',
											o.uuid), void 0 === t[o
										.image] && console.warn(
											"THREE.ObjectLoader: Undefined image",
											o.image);
									var l = t[o.image];
									Array.isArray(l) ? (s = new yr(l), 6 ===
											l.length && (s.needsUpdate = !0)
											) : (s = l && l.data ? new yo(l
												.data, l.width, l.height) :
											new ze(l), l && (s
												.needsUpdate = !0)), s
										.uuid = o.uuid, void 0 !== o.name &&
										(s.name = o.name), void 0 !== o
										.mapping && (s.mapping = n(o
											.mapping, Su)), void 0 !== o
										.offset && s.offset.fromArray(o
											.offset), void 0 !== o.repeat &&
										s.repeat.fromArray(o.repeat),
										void 0 !== o.center && s.center
										.fromArray(o.center), void 0 !== o
										.rotation && (s.rotation = o
											.rotation), void 0 !== o.wrap &&
										(s.wrapS = n(o.wrap[0], Tu), s
											.wrapT = n(o.wrap[1], Tu)),
										void 0 !== o.format && (s.format = o
											.format), void 0 !== o.type && (
											s.type = o.type), void 0 !== o
										.encoding && (s.encoding = o
											.encoding), void 0 !== o
										.minFilter && (s.minFilter = n(o
											.minFilter, Eu)), void 0 !== o
										.magFilter && (s.magFilter = n(o
											.magFilter, Eu)), void 0 !== o
										.anisotropy && (s.anisotropy = o
											.anisotropy), void 0 !== o
										.flipY && (s.flipY = o.flipY),
										void 0 !== o.premultiplyAlpha && (s
											.premultiplyAlpha = o
											.premultiplyAlpha), void 0 !== o
										.unpackAlignment && (s
											.unpackAlignment = o
											.unpackAlignment), r[o.uuid] = s
								}
							return r
						}
					}, {
						key: "parseObject",
						value: function(e, t, n, r) {
							var i, a, o;

							function s(e) {
								return void 0 === t[e] && console.warn(
									"THREE.ObjectLoader: Undefined geometry",
									e), t[e]
							}

							function l(e) {
								if (void 0 !== e) {
									if (Array.isArray(e)) {
										for (var t = [], r = 0, i = e
											.length; r < i; r++) {
											var a = e[r];
											void 0 === n[a] && console.warn(
												"THREE.ObjectLoader: Undefined material",
												a), t.push(n[a])
										}
										return t
									}
									return void 0 === n[e] && console.warn(
										"THREE.ObjectLoader: Undefined material",
										e), n[e]
								}
							}
							switch (e.type) {
								case "Scene":
									i = new Ua, void 0 !== e.background &&
										Number.isInteger(e.background) && (i
											.background = new yn(e
												.background)), void 0 !== e
										.fog && ("Fog" === e.fog.type ? i
											.fog = new Ha(e.fog.color, e.fog
												.near, e.fog.far) :
											"FogExp2" === e.fog.type && (i
												.fog = new Fa(e.fog.color, e
													.fog.density)));
									break;
								case "PerspectiveCamera":
									i = new vr(e.fov, e.aspect, e.near, e
											.far), void 0 !== e.focus && (i
											.focus = e.focus), void 0 !== e
										.zoom && (i.zoom = e.zoom),
										void 0 !== e.filmGauge && (i
											.filmGauge = e.filmGauge),
										void 0 !== e.filmOffset && (i
											.filmOffset = e.filmOffset),
										void 0 !== e.view && (i.view =
											Object.assign({}, e.view));
									break;
								case "OrthographicCamera":
									i = new du(e.left, e.right, e.top, e
											.bottom, e.near, e.far),
										void 0 !== e.zoom && (i.zoom = e
											.zoom), void 0 !== e.view && (i
											.view = Object.assign({}, e
												.view));
									break;
								case "AmbientLight":
									i = new vu(e.color, e.intensity);
									break;
								case "DirectionalLight":
									i = new pu(e.color, e.intensity);
									break;
								case "PointLight":
									i = new hu(e.color, e.intensity, e
										.distance, e.decay);
									break;
								case "RectAreaLight":
									i = new mu(e.color, e.intensity, e
										.width, e.height);
									break;
								case "SpotLight":
									i = new ou(e.color, e.intensity, e
										.distance, e.angle, e.penumbra,
										e.decay);
									break;
								case "HemisphereLight":
									i = new eu(e.color, e.groundColor, e
										.intensity);
									break;
								case "LightProbe":
									i = (new yu).fromJSON(e);
									break;
								case "SkinnedMesh":
									a = s(e.geometry), o = l(e.material),
										i = new mo(a, o), void 0 !== e
										.bindMode && (i.bindMode = e
											.bindMode), void 0 !== e
										.bindMatrix && i.bindMatrix
										.fromArray(e.bindMatrix), void 0 !==
										e.skeleton && (i.skeleton = e
											.skeleton);
									break;
								case "Mesh":
									a = s(e.geometry), o = l(e.material),
										i = new sr(a, o);
									break;
								case "InstancedMesh":
									a = s(e.geometry), o = l(e.material);
									var u = e.count,
										c = e.instanceMatrix,
										h = e.instanceColor;
									(i = new Eo(a, o, u)).instanceMatrix =
										new wn(new Float32Array(c.array),
											16), void 0 !== h && (i
											.instanceColor = new wn(
												new Float32Array(h.array), h
												.itemSize));
									break;
								case "LOD":
									i = new uo;
									break;
								case "Line":
									i = new Io(s(e.geometry), l(e
									.material));
									break;
								case "LineLoop":
									i = new Bo(s(e.geometry), l(e
									.material));
									break;
								case "LineSegments":
									i = new Oo(s(e.geometry), l(e
									.material));
									break;
								case "PointCloud":
								case "Points":
									i = new Vo(s(e.geometry), l(e
									.material));
									break;
								case "Sprite":
									i = new ao(l(e.material));
									break;
								case "Group":
									i = new Pa;
									break;
								case "Bone":
									i = new go;
									break;
								default:
									i = new Xt
							}
							if (i.uuid = e.uuid, void 0 !== e.name && (i
									.name = e.name), void 0 !== e.matrix ? (
									i.matrix.fromArray(e.matrix), void 0 !==
									e.matrixAutoUpdate && (i
										.matrixAutoUpdate = e
										.matrixAutoUpdate), i
									.matrixAutoUpdate && i.matrix.decompose(
										i.position, i.quaternion, i.scale)
									) : (void 0 !== e.position && i.position
									.fromArray(e.position), void 0 !== e
									.rotation && i.rotation.fromArray(e
										.rotation), void 0 !== e
									.quaternion && i.quaternion.fromArray(e
										.quaternion), void 0 !== e.scale &&
									i.scale.fromArray(e.scale)), void 0 !==
								e.castShadow && (i.castShadow = e
									.castShadow), void 0 !== e
								.receiveShadow && (i.receiveShadow = e
									.receiveShadow), e.shadow && (void 0 !==
									e.shadow.bias && (i.shadow.bias = e
										.shadow.bias), void 0 !== e.shadow
									.normalBias && (i.shadow.normalBias = e
										.shadow.normalBias), void 0 !== e
									.shadow.radius && (i.shadow.radius = e
										.shadow.radius), void 0 !== e.shadow
									.mapSize && i.shadow.mapSize.fromArray(e
										.shadow.mapSize), void 0 !== e
									.shadow.camera && (i.shadow.camera =
										this.parseObject(e.shadow.camera))),
								void 0 !== e.visible && (i.visible = e
									.visible), void 0 !== e.frustumCulled &&
								(i.frustumCulled = e.frustumCulled),
								void 0 !== e.renderOrder && (i.renderOrder =
									e.renderOrder), void 0 !== e.userData &&
								(i.userData = e.userData), void 0 !== e
								.layers && (i.layers.mask = e.layers),
								void 0 !== e.children)
								for (var d = e.children, f = 0; f < d
									.length; f++) i.add(this.parseObject(d[
									f], t, n, r));
							if (void 0 !== e.animations)
								for (var p = e.animations, v = 0; v < p
									.length; v++) {
									var m = p[v];
									i.animations.push(r[m])
								}
							if ("LOD" === e.type) {
								void 0 !== e.autoUpdate && (i.autoUpdate = e
									.autoUpdate);
								for (var g = e.levels, y = 0; y < g
									.length; y++) {
									var x = g[y],
										_ = i.getObjectByProperty("uuid", x
											.object);
									void 0 !== _ && i.addLevel(_, x
										.distance)
								}
							}
							return i
						}
					}, {
						key: "bindSkeletons",
						value: function(e, t) {
							0 !== Object.keys(t).length && e.traverse((
								function(e) {
									if (!0 === e.isSkinnedMesh &&
										void 0 !== e.skeleton) {
										var n = t[e.skeleton];
										void 0 === n ? console.warn(
												"THREE.ObjectLoader: No skeleton found with UUID:",
												e.skeleton) : e
											.bind(n, e.bindMatrix)
									}
								}))
						}
					}, {
						key: "setTexturePath",
						value: function(e) {
							return console.warn(
								"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
								), this.setResourcePath(e)
						}
					}]), n
				}(Ml), e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = Os, e
				.OctahedronGeometry = Os, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207,
				e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e
				.OneMinusSrcColorFactor = 203, e.OrthographicCamera = du, e.PCFShadowMap =
				1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = function() {
					function e(t) {
						(0, g.default)(this, e), this._renderer = t, this
							._pingPongRenderTarget = null, this._blurMaterial = function(
							e) {
								var t = new Float32Array(20),
									n = new je(0, 1, 0);
								return new $s({
									name: "SphericalGaussianBlur",
									defines: {
										n: 20
									},
									uniforms: {
										envMap: {
											value: null
										},
										samples: {
											value: 1
										},
										weights: {
											value: t
										},
										latitudinal: {
											value: !1
										},
										dTheta: {
											value: 0
										},
										mipInt: {
											value: 0
										},
										poleAxis: {
											value: n
										},
										inputEncoding: {
											value: Yc[3e3]
										},
										outputEncoding: {
											value: Yc[3e3]
										}
									},
									vertexShader: "",
									fragmentShader: ""
										.concat(
											""
											),
									blending: 0,
									depthTest: !1,
									depthWrite: !1
								})
							}(), this._equirectShader = null, this._cubemapShader = null,
							this._compileMaterial(this._blurMaterial)
					}
					return (0, y.default)(e, [{
						key: "fromScene",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] ? arguments[1] : 0,
								n = arguments.length > 2 && void 0 !==
								arguments[2] ? arguments[2] : .1,
								r = arguments.length > 3 && void 0 !==
								arguments[3] ? arguments[3] : 100;
							rh = this._renderer.getRenderTarget();
							var i = this._allocateTargets();
							return this._sceneToCubeUV(e, n, r, i), t > 0 &&
								this._blur(i, 0, 0, t), this._applyPMREM(i),
								this._cleanup(i), i
						}
					}, {
						key: "fromEquirectangular",
						value: function(e) {
							return this._fromTexture(e)
						}
					}, {
						key: "fromCubemap",
						value: function(e) {
							return this._fromTexture(e)
						}
					}, {
						key: "compileCubemapShader",
						value: function() {
							null === this._cubemapShader && (this
								._cubemapShader = dh(), this
								._compileMaterial(this._cubemapShader))
						}
					}, {
						key: "compileEquirectangularShader",
						value: function() {
							null === this._equirectShader && (this
								._equirectShader = hh(), this
								._compileMaterial(this._equirectShader))
						}
					}, {
						key: "dispose",
						value: function() {
							this._blurMaterial.dispose(), null !== this
								._cubemapShader && this._cubemapShader
								.dispose(), null !== this._equirectShader &&
								this._equirectShader.dispose();
							for (var e = 0; e < Kc.length; e++) Kc[e]
								.dispose()
						}
					}, {
						key: "_cleanup",
						value: function(e) {
							this._pingPongRenderTarget.dispose(), this
								._renderer.setRenderTarget(rh), e
								.scissorTest = !1, ch(e, 0, 0, e.width, e
									.height)
						}
					}, {
						key: "_fromTexture",
						value: function(e) {
							rh = this._renderer.getRenderTarget();
							var t = this._allocateTargets(e);
							return this._textureToCubeUV(e, t), this
								._applyPMREM(t), this._cleanup(t), t
						}
					}, {
						key: "_allocateTargets",
						value: function(e) {
							var t = {
									magFilter: L,
									minFilter: L,
									generateMipmaps: !1,
									type: D,
									format: 1023,
									encoding: lh(e) ? e.encoding : he,
									depthBuffer: !1
								},
								n = uh(t);
							return n.depthBuffer = !e, this
								._pingPongRenderTarget = uh(t), n
						}
					}, {
						key: "_compileMaterial",
						value: function(e) {
							var t = new sr(Kc[0], e);
							this._renderer.compile(t, Jc)
						}
					}, {
						key: "_sceneToCubeUV",
						value: function(e, t, n, r) {
							var i = new vr(90, 1, t, n),
								a = [1, -1, 1, 1, 1, 1],
								o = [1, 1, 1, -1, -1, -1],
								s = this._renderer,
								l = s.autoClear,
								u = s.outputEncoding,
								c = s.toneMapping;
							s.getClearColor(nh), s.toneMapping = 0, s
								.outputEncoding = le, s.autoClear = !1;
							var h = !1,
								d = e.background;
							if (d) {
								if (d.isColor) {
									$c.color.copy(d).convertSRGBToLinear(),
										e.background = null;
									var f = sh($c.color);
									$c.opacity = f, h = !0
								}
							} else {
								$c.color.copy(nh).convertSRGBToLinear();
								var p = sh($c.color);
								$c.opacity = p, h = !0
							}
							for (var v = 0; v < 6; v++) {
								var m = v % 3;
								0 == m ? (i.up.set(0, a[v], 0), i.lookAt(o[
									v], 0, 0)) : 1 == m ? (i.up.set(0,
									0, a[v]), i.lookAt(0, o[v], 0)) : (i
									.up.set(0, a[v], 0), i.lookAt(0, 0,
										o[v])), ch(r, m * jc, v > 2 ?
									jc : 0, jc, jc), s.setRenderTarget(
									r), h && s.render(Zc, i), s.render(
									e, i)
							}
							s.toneMapping = c, s.outputEncoding = u, s
								.autoClear = l
						}
					}, {
						key: "_textureToCubeUV",
						value: function(e, t) {
							var n = this._renderer;
							e.isCubeTexture ? null == this._cubemapShader &&
								(this._cubemapShader = dh()) : null == this
								._equirectShader && (this._equirectShader =
									hh());
							var r = e.isCubeTexture ? this._cubemapShader :
								this._equirectShader,
								i = new sr(Kc[0], r),
								a = r.uniforms;
							a.envMap.value = e, e.isCubeTexture || a
								.texelSize.value.set(1 / e.image.width, 1 /
									e.image.height), a.inputEncoding.value =
								Yc[e.encoding], a.outputEncoding.value = Yc[
									t.texture.encoding], ch(t, 0, 0, 3 * jc,
									2 * jc), n.setRenderTarget(t), n.render(
									i, Jc)
						}
					}, {
						key: "_applyPMREM",
						value: function(e) {
							var t = this._renderer,
								n = t.autoClear;
							t.autoClear = !1;
							for (var r = 1; r < Xc; r++) {
								var i = Math.sqrt(th[r] * th[r] - th[r -
										1] * th[r - 1]),
									a = oh[(r - 1) % oh.length];
								this._blur(e, r - 1, r, i, a)
							}
							t.autoClear = n
						}
					}, {
						key: "_blur",
						value: function(e, t, n, r, i) {
							var a = this._pingPongRenderTarget;
							this._halfBlur(e, a, t, n, r, "latitudinal", i),
								this._halfBlur(a, e, n, n, r,
									"longitudinal", i)
						}
					}, {
						key: "_halfBlur",
						value: function(e, t, n, r, i, a, o) {
							var s = this._renderer,
								l = this._blurMaterial;
							"latitudinal" !== a && "longitudinal" !== a &&
								console.error(
									"blur direction must be either latitudinal or longitudinal!"
									);
							var u = new sr(Kc[r], l),
								c = l.uniforms,
								h = eh[n] - 1,
								d = isFinite(i) ? Math.PI / (2 * h) : 2 *
								Math.PI / 39,
								f = i / d,
								p = isFinite(i) ? 1 + Math.floor(3 * f) :
								20;
							p > 20 && console.warn("sigmaRadians, ".concat(
								i,
								", is too large and will clip, as it requested "
								).concat(p,
								" samples when the maximum is set to 20"
								));
							for (var v = [], m = 0, g = 0; g < 20; ++g) {
								var y = g / f,
									x = Math.exp(-y * y / 2);
								v.push(x), 0 == g ? m += x : g < p && (m +=
									2 * x)
							}
							for (var _ = 0; _ < v.length; _++) v[_] = v[_] /
								m;
							c.envMap.value = e.texture, c.samples.value = p,
								c.weights.value = v, c.latitudinal.value =
								"latitudinal" === a, o && (c.poleAxis
									.value = o), c.dTheta.value = d, c
								.mipInt.value = 8 - n, c.inputEncoding
								.value = Yc[e.texture.encoding], c
								.outputEncoding.value = Yc[e.texture
									.encoding];
							var b = eh[r];
							ch(t, 3 * Math.max(0, jc - 2 * b), (0 === r ?
									0 : 2 * jc) + 2 * b * (r > 4 ? r -
									8 + 4 : 0), 3 * b, 2 * b), s
								.setRenderTarget(t), s.render(u, Jc)
						}
					}]), e
				}(), e.ParametricBufferGeometry = Bs, e.ParametricGeometry = Bs, e
				.Particle = function(e) {
					return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
						new ao(e)
				}, e.ParticleBasicMaterial = function(e) {
					return console.warn(
						"THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
						), new zo(e)
				}, e.ParticleSystem = function(e, t) {
					return console.warn(
							"THREE.ParticleSystem has been renamed to THREE.Points."),
						new Vo(e, t)
				}, e.ParticleSystemMaterial = function(e) {
					return console.warn(
						"THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
						), new zo(e)
				}, e.Path = Jl, e.PerspectiveCamera = vr, e.Plane = Jt, e
				.PlaneBufferGeometry = Tr, e.PlaneGeometry = Tr, e.PlaneHelper = function(
				e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r, i = arguments.length > 1 && void 0 !== arguments[1] ?
							arguments[1] : 1,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 16776960;
						(0, g.default)(this, n);
						var o = a,
							s = new Vn;
						s.setAttribute("position", new Cn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1,
							1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0,
							1, 0, 0, 0
						], 3)), s.computeBoundingSphere(), (r = t.call(this, s, new Ao({
							color: o,
							toneMapped: !1
						}))).type = "PlaneHelper", r.plane = e, r.size = i;
						var l = new Vn;
						return l.setAttribute("position", new Cn([1, 1, 1, -1, 1, 1, -1, -1,
							1, 1, 1, 1, -1, -1, 1, 1, -1, 1
						], 3)), l.computeBoundingSphere(), r.add(new sr(l, new xn({
							color: o,
							opacity: .2,
							transparent: !0,
							depthWrite: !1,
							toneMapped: !1
						}))), r
					}
					return (0, y.default)(n, [{
						key: "updateMatrixWorld",
						value: function(e) {
							var t = -this.plane.constant;
							Math.abs(t) < 1e-8 && (t = 1e-8), this.scale
								.set(.5 * this.size, .5 * this.size, t),
								this.children[0].material.side = t < 0 ? 1 :
								0, this.lookAt(this.plane.normal), (0, h
									.default)((0, m.default)(n.prototype),
									"updateMatrixWorld", this).call(this, e)
						}
					}]), n
				}(Io), e.PointCloud = function(e, t) {
					return console.warn(
						"THREE.PointCloud has been renamed to THREE.Points."), new Vo(e,
						t)
				}, e.PointCloudMaterial = function(e) {
					return console.warn(
						"THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
						), new zo(e)
				}, e.PointLight = hu, e.PointLightHelper = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r, i) {
						var a;
						return (0, g.default)(this, n), (a = t.call(this, new Hs(r, 4, 2),
								new xn({
									wireframe: !0,
									fog: !1,
									toneMapped: !1
								}))).light = e, a.light.updateMatrixWorld(), a.color = i, a
							.type = "PointLightHelper", a.matrix = a.light.matrixWorld, a
							.matrixAutoUpdate = !1, a.update(), a
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {
							this.geometry.dispose(), this.material.dispose()
						}
					}, {
						key: "update",
						value: function() {
							void 0 !== this.color ? this.material.color.set(
								this.color) : this.material.color.copy(
								this.light.color)
						}
					}]), n
				}(sr), e.Points = Vo, e.PointsMaterial = zo, e.PolarGridHelper = function(
				e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n() {
						var e, r = arguments.length > 0 && void 0 !== arguments[0] ?
							arguments[0] : 10,
							i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 16,
							a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 8,
							o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 64,
							s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[
								4] : 4473924,
							l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[
								5] : 8947848;
						(0, g.default)(this, n), s = new yn(s), l = new yn(l);
						for (var u = [], c = [], h = 0; h <= i; h++) {
							var d = h / i * (2 * Math.PI),
								f = Math.sin(d) * r,
								p = Math.cos(d) * r;
							u.push(0, 0, 0), u.push(f, 0, p);
							var v = 1 & h ? s : l;
							c.push(v.r, v.g, v.b), c.push(v.r, v.g, v.b)
						}
						for (var m = 0; m <= a; m++)
							for (var y = 1 & m ? s : l, x = r - r / a * m, _ = 0; _ <
								o; _++) {
								var b = _ / o * (2 * Math.PI),
									w = Math.sin(b) * x,
									M = Math.cos(b) * x;
								u.push(w, 0, M), c.push(y.r, y.g, y.b), b = (_ + 1) / o * (
										2 * Math.PI), w = Math.sin(b) * x, M = Math.cos(b) *
									x, u.push(w, 0, M), c.push(y.r, y.g, y.b)
							}
						var S = new Vn;
						return S.setAttribute("position", new Cn(u, 3)), S.setAttribute(
							"color", new Cn(c, 3)), (e = t.call(this, S, new Ao({
							vertexColors: !0,
							toneMapped: !1
						}))).type = "PolarGridHelper", e
					}
					return n
				}(Oo), e.PolyhedronBufferGeometry = Qo, e.PolyhedronGeometry = Qo, e
				.PositionalAudio = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e) {
						var r;
						return (0, g.default)(this, n), (r = t.call(this, e)).panner = r
							.context.createPanner(), r.panner.panningModel = "HRTF", r
							.panner.connect(r.gain), r
					}
					return (0, y.default)(n, [{
						key: "getOutput",
						value: function() {
							return this.panner
						}
					}, {
						key: "getRefDistance",
						value: function() {
							return this.panner.refDistance
						}
					}, {
						key: "setRefDistance",
						value: function(e) {
							return this.panner.refDistance = e, this
						}
					}, {
						key: "getRolloffFactor",
						value: function() {
							return this.panner.rolloffFactor
						}
					}, {
						key: "setRolloffFactor",
						value: function(e) {
							return this.panner.rolloffFactor = e, this
						}
					}, {
						key: "getDistanceModel",
						value: function() {
							return this.panner.distanceModel
						}
					}, {
						key: "setDistanceModel",
						value: function(e) {
							return this.panner.distanceModel = e, this
						}
					}, {
						key: "getMaxDistance",
						value: function() {
							return this.panner.maxDistance
						}
					}, {
						key: "setMaxDistance",
						value: function(e) {
							return this.panner.maxDistance = e, this
						}
					}, {
						key: "setDirectionalCone",
						value: function(e, t, n) {
							return this.panner.coneInnerAngle = e, this
								.panner.coneOuterAngle = t, this.panner
								.coneOuterGain = n, this
						}
					}, {
						key: "updateMatrixWorld",
						value: function(e) {
							if ((0, h.default)((0, m.default)(n.prototype),
									"updateMatrixWorld", this).call(this,
								e), !0 !== this.hasPlaybackControl || !1 !==
								this.isPlaying) {
								this.matrixWorld.decompose(ju, qu, Xu), Yu
									.set(0, 0, 1).applyQuaternion(qu);
								var t = this.panner;
								if (t.positionX) {
									var r = this.context.currentTime + this
										.listener.timeDelta;
									t.positionX.linearRampToValueAtTime(ju
											.x, r), t.positionY
										.linearRampToValueAtTime(ju.y, r), t
										.positionZ.linearRampToValueAtTime(
											ju.z, r), t.orientationX
										.linearRampToValueAtTime(Yu.x, r), t
										.orientationY
										.linearRampToValueAtTime(Yu.y, r), t
										.orientationZ
										.linearRampToValueAtTime(Yu.z, r)
								} else t.setPosition(ju.x, ju.y, ju.z), t
									.setOrientation(Yu.x, Yu.y, Yu.z)
							}
						}
					}]), n
				}(Wu), e.PropertyBinding = oc, e.PropertyMixer = Zu, e
				.QuadraticBezierCurve = ql, e.QuadraticBezierCurve3 = Xl, e.Quaternion = We,
				e.QuaternionKeyframeTrack = vl, e.QuaternionLinearInterpolant = pl, e
				.REVISION = n, e.RGBADepthPacking = 3201, e.RGBAFormat = U, e
				.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e
				.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e
				.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e
				.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e
				.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e
				.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e
				.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e
				.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e
				.RGBA_ETC2_EAC_Format = K, e.RGBA_PVRTC_2BPPV1_Format = J, e
				.RGBA_PVRTC_4BPPV1_Format = Z, e.RGBA_S3TC_DXT1_Format = j, e
				.RGBA_S3TC_DXT3_Format = q, e.RGBA_S3TC_DXT5_Format = X, e.RGBDEncoding =
				pe, e.RGBEEncoding = he, e.RGBEFormat = 1023, e.RGBFormat = H, e
				.RGBIntegerFormat = 1032, e.RGBM16Encoding = fe, e.RGBM7Encoding = de, e
				.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = Q, e.RGB_PVRTC_2BPPV1_Format =
				$, e.RGB_PVRTC_4BPPV1_Format = Y, e.RGB_S3TC_DXT1_Format = W, e.RGFormat =
				1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = $s, e.Ray = bt, e
				.Raycaster = function() {
					function e(t, n) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0,
							i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[
								3] : 1 / 0;
						(0, g.default)(this, e), this.ray = new bt(t, n), this.near = r,
							this.far = i, this.camera = null, this.layers = new It, this
							.params = {
								Mesh: {},
								Line: {
									threshold: 1
								},
								LOD: {},
								Points: {
									threshold: 1
								},
								Sprite: {}
							}
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t) {
							this.ray.set(e, t)
						}
					}, {
						key: "setFromCamera",
						value: function(e, t) {
							t && t.isPerspectiveCamera ? (this.ray.origin
									.setFromMatrixPosition(t.matrixWorld),
									this.ray.direction.set(e.x, e.y, .5)
									.unproject(t).sub(this.ray.origin)
									.normalize(), this.camera = t) : t && t
								.isOrthographicCamera ? (this.ray.origin
									.set(e.x, e.y, (t.near + t.far) / (t
										.near - t.far)).unproject(t), this
									.ray.direction.set(0, 0, -1)
									.transformDirection(t.matrixWorld), this
									.camera = t) : console.error(
									"THREE.Raycaster: Unsupported camera type: " +
									t.type)
						}
					}, {
						key: "intersectObject",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !==
								arguments[1] && arguments[1],
								n = arguments.length > 2 && void 0 !==
								arguments[2] ? arguments[2] : [];
							return pc(e, this, n, t), n.sort(fc), n
						}
					}, {
						key: "intersectObjects",
						value: function(e) {
							for (var t = arguments.length > 1 && void 0 !==
									arguments[1] && arguments[1], n =
									arguments.length > 2 && void 0 !==
									arguments[2] ? arguments[2] : [], r = 0,
									i = e.length; r < i; r++) pc(e[r], this,
								n, t);
							return n.sort(fc), n
						}
					}]), e
				}(), e.RectAreaLight = mu, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e
				.ReinhardToneMapping = 2, e.RepeatWrapping = T, e.ReplaceStencilOp = 7681, e
				.ReverseSubtractEquation = 102, e.RingBufferGeometry = zs, e.RingGeometry =
				zs, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e
				.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format =
				37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e
				.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format =
				37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e
				.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format =
				37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e
				.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format =
				37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e
				.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = Ua, e.SceneUtils = fh, e
				.ShaderChunk = Er, e.ShaderLib = Lr, e.ShaderMaterial = fr, e
				.ShadowMaterial = Ys, e.Shape = Ql, e.ShapeBufferGeometry = Fs, e
				.ShapeGeometry = Fs, e.ShapePath = ku, e.ShapeUtils = ks, e.ShortType =
				1011, e.Skeleton = bo, e.SkeletonHelper = Tc, e.SkinnedMesh = mo, e
				.SmoothShading = 2, e.Sphere = ft, e.SphereBufferGeometry = Hs, e
				.SphereGeometry = Hs, e.Spherical = function() {
					function e() {
						var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[
								0] : 1,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[
								1] : 0,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
								2] : 0;
						return (0, g.default)(this, e), this.radius = t, this.phi = n, this
							.theta = r, this
					}
					return (0, y.default)(e, [{
						key: "set",
						value: function(e, t, n) {
							return this.radius = e, this.phi = t, this
								.theta = n, this
						}
					}, {
						key: "copy",
						value: function(e) {
							return this.radius = e.radius, this.phi = e.phi,
								this.theta = e.theta, this
						}
					}, {
						key: "makeSafe",
						value: function() {
							var e = 1e-6;
							return this.phi = Math.max(e, Math.min(Math.PI -
								e, this.phi)), this
						}
					}, {
						key: "setFromVector3",
						value: function(e) {
							return this.setFromCartesianCoords(e.x, e.y, e
								.z)
						}
					}, {
						key: "setFromCartesianCoords",
						value: function(e, t, n) {
							return this.radius = Math.sqrt(e * e + t * t +
									n * n), 0 === this.radius ? (this
									.theta = 0, this.phi = 0) : (this
									.theta = Math.atan2(e, n), this.phi =
									Math.acos(Ee(t / this.radius, -1, 1))),
								this
						}
					}, {
						key: "clone",
						value: function() {
							return (new this.constructor).copy(this)
						}
					}]), e
				}(), e.SphericalHarmonics3 = gu, e.SplineCurve = Yl, e.SpotLight = ou, e
				.SpotLightHelper = function(e) {
					(0, p.default)(n, e);
					var t = M(n);

					function n(e, r) {
						var i;
						(0, g.default)(this, n), (i = t.call(this)).light = e, i.light
							.updateMatrixWorld(), i.matrix = e.matrixWorld, i
							.matrixAutoUpdate = !1, i.color = r;
						for (var a = new Vn, o = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,
								0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1
							], s = 0, l = 1; s < 32; s++, l++) {
							var u = s / 32 * Math.PI * 2,
								c = l / 32 * Math.PI * 2;
							o.push(Math.cos(u), Math.sin(u), 1, Math.cos(c), Math.sin(c), 1)
						}
						a.setAttribute("position", new Cn(o, 3));
						var h = new Ao({
							fog: !1,
							toneMapped: !1
						});
						return i.cone = new Oo(a, h), i.add(i.cone), i.update(), i
					}
					return (0, y.default)(n, [{
						key: "dispose",
						value: function() {
							this.cone.geometry.dispose(), this.cone.material
								.dispose()
						}
					}, {
						key: "update",
						value: function() {
							this.light.updateMatrixWorld();
							var e = this.light.distance ? this.light
								.distance : 1e3,
								t = e * Math.tan(this.light.angle);
							this.cone.scale.set(t, t, e), bc
								.setFromMatrixPosition(this.light.target
									.matrixWorld), this.cone.lookAt(bc),
								void 0 !== this.color ? this.cone.material
								.color.set(this.color) : this.cone.material
								.color.copy(this.light.color)
						}
					}]), n
				}(Xt), e.Sprite = ao, e.SpriteMaterial = qa, e.SrcAlphaFactor = 204, e
				.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage =
				35046, e.StaticDrawUsage = me, e.StaticReadUsage = 35045, e.StereoCamera =
				function() {
					function e() {
						(0, g.default)(this, e), this.type = "StereoCamera", this.aspect =
							1, this.eyeSep = .064, this.cameraL = new vr, this.cameraL
							.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this
							.cameraR = new vr, this.cameraR.layers.enable(2), this.cameraR
							.matrixAutoUpdate = !1, this._cache = {
								focus: null,
								fov: null,
								aspect: null,
								near: null,
								far: null,
								zoom: null,
								eyeSep: null
							}
					}
					return (0, y.default)(e, [{
						key: "update",
						value: function(e) {
							var t = this._cache;
							if (t.focus !== e.focus || t.fov !== e.fov || t
								.aspect !== e.aspect * this.aspect || t
								.near !== e.near || t.far !== e.far || t
								.zoom !== e.zoom || t.eyeSep !== this.eyeSep
								) {
								t.focus = e.focus, t.fov = e.fov, t.aspect =
									e.aspect * this.aspect, t.near = e.near,
									t.far = e.far, t.zoom = e.zoom, t
									.eyeSep = this.eyeSep;
								var n, r, i = e.projectionMatrix.clone(),
									a = t.eyeSep / 2,
									o = a * t.near / t.focus,
									s = t.near * Math.tan(Me * t.fov * .5) /
									t.zoom;
								Bu.elements[12] = -a, Ou.elements[12] = a,
									n = -s * t.aspect + o, r = s * t
									.aspect + o, i.elements[0] = 2 * t
									.near / (r - n), i.elements[8] = (r +
									n) / (r - n), this.cameraL
									.projectionMatrix.copy(i), n = -s * t
									.aspect - o, r = s * t.aspect - o, i
									.elements[0] = 2 * t.near / (r - n), i
									.elements[8] = (r + n) / (r - n), this
									.cameraR.projectionMatrix.copy(i)
							}
							this.cameraL.matrixWorld.copy(e.matrixWorld)
								.multiply(Bu), this.cameraR.matrixWorld
								.copy(e.matrixWorld).multiply(Ou)
						}
					}]), e
				}(), e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e
				.StreamReadUsage = 35041, e.StringKeyframeTrack = ml, e.SubtractEquation =
				101, e.SubtractiveBlending = 3, e.TOUCH = {
					ROTATE: 0,
					PAN: 1,
					DOLLY_PAN: 2,
					DOLLY_ROTATE: 3
				}, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = Us, e
				.TetrahedronGeometry = Us, e.TextBufferGeometry = Gs, e.TextGeometry = Gs, e
				.Texture = ze, e.TextureLoader = kl, e.TorusBufferGeometry = Vs, e
				.TorusGeometry = Vs, e.TorusKnotBufferGeometry = Ws, e.TorusKnotGeometry =
				Ws, e.Triangle = un, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1,
				e.TrianglesDrawMode = 0, e.TubeBufferGeometry = js, e.TubeGeometry = js, e
				.UVMapping = i, e.Uint16Attribute = function(e, t) {
					return console.warn(
						"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
						), new An(e, t)
				}, e.Uint16BufferAttribute = An, e.Uint32Attribute = function(e, t) {
					return console.warn(
						"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
						), new kn(e, t)
				}, e.Uint32BufferAttribute = kn, e.Uint8Attribute = function(e, t) {
					return console.warn(
						"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
						), new Sn(e, t)
				}, e.Uint8BufferAttribute = Sn, e.Uint8ClampedAttribute = function(e, t) {
					return console.warn(
						"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
						), new Tn(e, t)
				}, e.Uint8ClampedBufferAttribute = Tn, e.Uniform = cc, e.UniformsLib = Ar, e
				.UniformsUtils = dr, e.UnsignedByteType = D, e.UnsignedInt248Type = F, e
				.UnsignedIntType = O, e.UnsignedShort4444Type = 1017, e
				.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e
				.UnsignedShortType = N, e.VSMShadowMap = 3, e.Vector2 = Ie, e.Vector3 = je,
				e.Vector4 = He, e.VectorKeyframeTrack = gl, e.Vertex = function(e, t, n) {
					return console.warn(
							"THREE.Vertex has been removed. Use THREE.Vector3 instead."),
						new je(e, t, n)
				}, e.VertexColors = 2, e.VideoTexture = jo, e.WebGL1Renderer = za, e
				.WebGLCubeRenderTarget = xr, e.WebGLMultipleRenderTargets = Ge, e
				.WebGLMultisampleRenderTarget = Ve, e.WebGLRenderTarget = Ue, e
				.WebGLRenderTargetCube = function(e, t, n) {
					return console.warn(
						"THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
						), new xr(e, n)
				}, e.WebGLRenderer = Ba, e.WebGLUtils = Ra, e.WireframeGeometry = qs, e
				.WireframeHelper = function(e, t) {
					return console.warn(
						"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
						), new Oo(new qs(e.geometry), new Ao({
						color: void 0 !== t ? t : 16777215
					}))
				}, e.WrapAroundEnding = ae, e.XHRLoader = function(e) {
					return console.warn(
							"THREE.XHRLoader has been renamed to THREE.FileLoader."),
						new Tl(e)
				}, e.ZeroCurvatureEnding = re, e.ZeroFactor = 200, e.ZeroSlopeEnding = ie, e
				.ZeroStencilOp = 0, e.sRGBEncoding = ue, Object.defineProperty(e,
					"__esModule", {
						value: !0
					})
		}, "object" == (0, x.default)(t) && void 0 !== e ? o(t) : (i = [t], void 0 === (a =
			"function" == typeof(r = o) ? r.apply(t, i) : r) || (e.exports = a))
	}, function(e, t, n) {
		var r = n(60);
		e.exports = function(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError(
				"Super expression must either be null or a function");
			e.prototype = Object.create(t && t.prototype, {
				constructor: {
					value: e,
					writable: !0,
					configurable: !0
				}
			}), t && r(e, t)
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		var r = n(6).default,
			i = n(8);
		e.exports = function(e, t) {
			if (t && ("object" === r(t) || "function" == typeof t)) return t;
			if (void 0 !== t) throw new TypeError(
				"Derived constructors may only return object or undefined");
			return i(e)
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2));
		n(17);
		var o = r(n(9)),
			s = r(n(18)),
			l = r(n(19)),
			u = r(n(20)),
			c = r(n(23)),
			h = r(n(26)),
			d = r(n(29)),
			f = r(n(35)),
			p = r(n(37)),
			v = r(n(39)),
			m = r(n(41)),
			g = r(n(43)),
			y = r(n(45)),
			x = r(n(47)),
			_ = r(n(49)),
			b = r(n(62)),
			w = r(n(4)),
			M = r(n(64)),
			S = [u.default, c.default, h.default, d.default, f.default, p.default, v.default, m
				.default, g.default, y.default, x.default, b.default, M.default, _.default
			],
			T = function() {
				function e(t) {
					var n = this;
					(0, i.default)(this, e);
					var r = document.querySelectorAll("[data-mod-name]");
					r && r.length && function() {
						for (var e = n.getModules(), t = 0; t < r.length; t++) {
							var i = r[t];
							o.default.addListener(i, (function(t) {
								var n = t.getAttribute("data-mod-name"),
									r = t.getAttribute("data-loaded");
								e[n] && !r && ($(t).find(".lazyload-html").each(
									(function() {
										var e = $(this);
										window.innerWidth > 1023 &&
											e.hasClass(
												"lazyload-html-m"
												) || window
											.innerWidth <= 1023 && e
											.hasClass(
												"lazyload-html-pc"
												) ? e.remove() : e
											.after(this.innerText)
											.remove()
									})), new e[n](t), t.setAttribute(
									"data-loaded", !0))
							}))
						}
					}(), new o.default(t), s.default.getInstance({
						env: "prod"
					}).scan(), (0, w.default)(1024) && new l.default({
						selector: ".element-entrance",
						enterDiff: 70,
						outDiff: 70,
						disableOut: !0
					});
					var a = (0, w.default)(768) ? "pc" : "mb";
					window.addEventListener("resize", (function() {
						("pc" === a && !(0, w.default)(768) || "mb" === a && (0, w
							.default)(768)) && window.location.reload()
					}), !1)
				}
				return (0, a.default)(e, [{
					key: "getModules",
					value: function() {
						var e = {};
						return S.forEach((function(t) {
							t.moduleName ? e[t.moduleName()] = t :
								new t("body")
						})), e
					}
				}]), e
			}();
		t.default = T
	}, function(e, t, n) {}, function(t, n) {
		t.exports = e("@cloud/link-to")
	}, function(t, n) {
		t.exports = e("@cloud/element-entrance")
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(21);
		var s = r(n(22)),
			l = r(n(4)),
			u = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), (0, o.default)
					(this, "reportedBannerIndexs", []), (0, o.default)(this, "bannerQuantity",
						void 0), (0, o.default)(this, "reportQueue", []), this.$el = $(t), this
						.init(), this.bindEvents()
				}
				return (0, a.default)(e, [{
					key: "init",
					value: function() {
						this.initBiParam(), this.initCarousel(), this
							.initProducts()
					}
				}, {
					key: "initBiParam",
					value: function() {
						var e = window.localStorage && window.localStorage
							.getItem("ua"),
							t = this.getCustomerCookie("ua") || e || "",
							n = this.$el.find(".carousel-slide");
						n.each((function(e, n) {
							$(n).attr("bi_param_rec_account", t)
						})), this.bannerQuantity = n.length
					}
				}, {
					key: "initCarousel",
					value: function() {
						var e = this,
							t = this.$el.find(".banner-container"),
							n = function() {
								var n = function(e) {
										e.find("[data-src]").each((function() {
											var e = $(this),
												t = e.attr(
													"data-src");
											"IMG" === this.tagName ?
												e.attr("src", t) : e
												.css({
													"background-image": "url(" +
														t + ")"
												})
										}))
									},
									r = new s.default(t.get(0), {
										effect: "none",
										speed: 700,
										loop: !0,
										autoplay: window.swiperTime || 5e3,
										onIndicatorsRender: function(e, t,
											n) {
											var r =
												"banner_slideBullets_" +
												(n + 1);
											return t.replace('">',
												'" bi_name="' + r +
												'"><span></span>')
										},
										beforeSlide: function(e) {
											e.$startSlide.find(
												"[data-exit-animation]"
												).each((function() {
												var e = $(
														this
														),
													t = e
													.attr(
														"data-exit-animation"
														);
												e.addClass(
													t)
											})), e.$startSlide.find(
												"[data-exit-transition]"
												).each((function() {
												var e = $(
														this
														),
													t = e
													.attr(
														"data-exit-transition"
														),
													n = e
													.attr(
														"data-enter-transition"
														);
												n && e
													.removeClass(
														n),
													e
													.addClass(
														t)
											}))
										},
										afterSlide: function(e) {
											n(r.$currentSlide), n(r
												.$currentSlide
												.next());
											var t = function(e, t, n) {
												var r = $(e),
													i = r.attr(t);
												r.toggleClass(i, n)
											};
											e.$targetSlide.find(
													"[data-animation]")
												.each((function() {
													t(this, "data-animation",
														!0)
												})), e.$startSlide.find(
													"[data-animation]")
												.each((function() {
													t(this, "data-animation",
														!1)
												})), e.$startSlide.find(
													"[data-enter-animation]"
													).each((function() {
													t(this, "data-enter-animation",
														!1)
												})), e.$targetSlide
												.find(
													"[data-enter-animation]"
													).each((function() {
													t(this, "data-enter-animation",
														!0)
												})), e.$startSlide.find(
													"[data-exit-animation]"
													).each((function() {
													t(this, "data-exit-animation",
														!1)
												})), e.$startSlide.find(
													"[data-exit-transition]"
													).each((function() {
													t(this, "data-exit-transition",
														!1)
												})), e.$targetSlide
												.find(
													"[data-enter-transition]"
													).each((function() {
													t(this, "data-enter-transition",
														!0)
												}))
										}
									});
								r.$indicatorWrapper.on("mouseenter", (
							function() {
									r.pause()
								})).on("mouseleave", (function() {
									r.play()
								})), n(r.$currentSlide), n(r.$currentSlide
									.next()), e.initReport(r, "pc")
							},
							r = function() {
								t.addClass("swiper-container").children(
									".carousel-wrapper").addClass(
									"swiper-wrapper").find(
									".carousel-slide").addClass(
									"swiper-slide").each((function() {
									var e = $(this),
										t = e.attr("data-img"),
										n = e.find("a").attr(
										"href"),
										r = e.find("a").attr(
											"bi_name"),
										i = e.find(
											".banner-text-mb");
									i.attr("mbtitle") && i.find(
											"h5").text(i.attr(
											"mbtitle")), i.attr(
											"mbdesc") && i.find("p")
										.text(i.attr("mbdesc")), i
										.find(
											".banner-text-btn-wrapper"
											).remove(), e.html(
											'<a href="' + n +
											'" target="_blank" bi_name="' +
											r + '"><img src="' + t +
											'"></a>').find("a")
										.append(i)
								})), t.addClass("init-img");
								var n = new Swiper(t.get(0), {
									effect: "slide",
									speed: 800,
									autoplay: 5e3,
									loop: !0,
									autoplayDisableOnInteraction: !1,
									paginationClickable: !0,
									pagination: ".carousel-indicator-wrapper",
									onPaginationRendered: function(e) {
										Array.prototype.forEach
											.call(e.bullets, (
												function(e, t) {
													$(e).attr(
														"bi_name",
														"banner_slideBullets_" +
														(t +
															1)
														)
												}))
									}
								});
								$(n.container).data("carousel", n), e
									.initReport(n, "mb")
							};
						(0, l.default)(768) ? n(): r()
					}
				}, {
					key: "initProducts",
					value: function() {
						var e = 1e3 / 60;
						this.$el.find(".banner-product").each((function() {
							var t;
							$(this).on("mouseenter", (function() {
								var n = $(this).find(
										"i"),
									r = parseInt(n.attr(
										"data-current"
										)) || 0,
									i = n.innerHeight();
								clearInterval(t), t =
									setInterval((
										function() {
											n.attr("data-current",
													r
													),
												n
												.css({
													"background-position-y": r *
														i *
														-
														1
												}),
												r++
												>=
												28 &&
												(clearInterval(
														t
														),
													t =
													null
													)
										}), e)
							})).on("mouseleave", (function() {
								var n = $(this).find(
										"i"),
									r = parseInt(n.attr(
										"data-current"
										)) || 0,
									i = n.innerHeight();
								clearInterval(t), t =
									setInterval((
										function() {
											n.attr("data-current",
													r
													),
												n
												.css({
													"background-position-y": r *
														i *
														-
														1
												}),
												r--
												<=
												0 &&
												(clearInterval(
														t
														),
													t =
													null
													)
										}), e)
							}))
						}))
					}
				}, {
					key: "initReport",
					value: function(e, t) {
						var n = this;
						({
							pc: function() {
								var t = function() {
									n.notifyReportQueue(), n
										.reportedBannerIndexs
										.length >= n
										.bannerQuantity || n
										.isBannerInView() && n
										.reportBySlide(e
											.$currentSlide.get(0))
								};
								e.addEvent("afterSlide", (function() {
									setTimeout((function() {
										t()
									}), 1e3)
								})), $(window).scroll((function() {
									t()
								})), t()
							},
							mb: function() {
								var t = function() {
									n.notifyReportQueue(), n
										.reportedBannerIndexs
										.length >= n
										.bannerQuantity || n
										.isBannerInView() && n
										.reportBySlide(e.slides[e
											.activeIndex])
								};
								e.on("slideChangeEnd", (function() {
									t()
								})), $(window).scroll((function() {
									t()
								})), t()
							}
						})[t]()
					}
				}, {
					key: "report",
					value: function(e, t) {
						this.reportQueue.push({
							eventLabel: e,
							params: t
						}), this.notifyReportQueue()
					}
				}, {
					key: "notifyReportQueue",
					value: function() {
						if (window.onEvent && 0 !== this.reportQueue.length) {
							this.reportQueue.forEach((function(e) {
								window.onEvent(
									"www_china_zh-cn_index",
									"view", e.eventLabel, "1", e
									.params)
							})), this.reportQueue = []
						}
					}
				}, {
					key: "reportBySlide",
					value: function(e) {
						var t = e.getAttribute("bi_param_rec_position");
						if (-1 === this.reportedBannerIndexs.indexOf(t)) {
							this.reportedBannerIndexs.push(t);
							var n = this.getParams(e),
								r = $(e).find("a").attr("href"),
								i = "home-banner_".concat(n.rec_position, "_")
								.concat(r);
							this.report(i, n)
						}
					}
				}, {
					key: "getParams",
					value: function(e) {
						var t = "bi_param_",
							n = {};
						return Array.from(e.attributes).forEach((function(e) {
							if (0 === e.name.indexOf(t)) {
								var r = e.name.substring(t.length);
								n[r] = e.value
							}
						})), n
					}
				}, {
					key: "isBannerInView",
					value: function() {
						var e = this.$el.find("#banner-container").get(0)
							.getBoundingClientRect();
						return !!e && e.bottom >= e.height / 2
					}
				}, {
					key: "getCustomerCookie",
					value: function(e) {
						var t, n;
						return document.cookie.length > 0 && -1 !== (t =
							document.cookie.indexOf(e + "=")) ? (t = t + e
							.length + 1, -1 === (n = document.cookie
								.indexOf(";", t)) && (n = document.cookie
								.length), decodeURI(document.cookie
								.substring(t, n))) : ""
					}
				}, {
					key: "bindEvents",
					value: function() {}
				}], [{
					key: "moduleName",
					value: function() {
						return "banner"
					}
				}]), e
			}();
		t.default = u
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var r = function(e, t) {
				this.options = $.extend({}, {
					effect: "cover",
					speed: 500,
					loop: !0,
					autoplay: 5e3,
					onIndicatorsRender: function(e, t) {
						return t
					}
				}, t);
				var n = this;
				this.$container = $(e), this.$wrapper = this.$container.find(
						".carousel-wrapper"), this.$slides = this.$wrapper.find(
						".carousel-slide"), this.$indicatorWrapper = this.$container.find(
						".carousel-indicator-wrapper"), this.currentIndex = 0, this
					.$currentSlide = this.$slides.eq(this.currentIndex), this.$activeSlide = $(
						this.$currentSlide), this.events = {
						beforeSlide: this.options.beforeSlide ? [this.options.beforeSlide] : [],
						afterSlide: this.options.afterSlide ? [this.options.afterSlide] : []
					}, i[this.options.effect].init.call(this);
				var r = "";
				this.$slides.each((function(e) {
						var t = "";
						t = e === n.currentIndex ?
							'<div class="carousel-indicator carousel-indicator-active"></div>' :
							'<div class="carousel-indicator"></div>', r += n.options
							.onIndicatorsRender(n, t, e)
					})), this.$indicatorWrapper.html(r), this.$indicators = this
					.$indicatorWrapper.children(), this.$indicatorWrapper.on("click",
						".carousel-indicator", (function() {
							var e = $(this).index();
							n.goto(e)
						})), this.options.autoplay > 0 && (this.playing = this.options.autoplay,
						this.timeOutToNext(this.playing))
			},
			i = {
				cover: {
					init: function() {
						this.$container.attr("data-effect", "cover"), this.$currentSlide
							.addClass("carousel-slide-current carousel-slide-active")
							.siblings().removeClass(
								"carousel-slide-current carousel-slide-active"), this
							.$currentSlide.prevAll().add(this.$currentSlide).css("left", 0),
							this.$currentSlide.nextAll().css("left", "100%")
					},
					transition: function(e, t) {
						t || (t = function() {});
						var n = this,
							r = this.$slides.eq(e),
							i = this.currentIndex,
							a = this.$currentSlide,
							o = function() {
								r.css({
									left: "100%"
								}).addClass("to-top").animate({
									left: 0
								}, n.options.speed, (function() {
									r.nextAll().css({
										left: "100%"
									}), r.removeClass("to-top"), t(n)
								}))
							},
							s = function() {
								r.prevUntil(a).add(r).css({
									left: "100%"
								}).animate({
									left: 0
								}, n.options.speed, (function() {
									t(n)
								}))
							},
							l = function() {
								a.prevUntil(r).add(a).css({
									left: 0
								}).animate({
									left: "100%"
								}, n.options.speed, (function() {
									t(n)
								}))
							};
						0 === e && i === this.$slides.length - 1 ? o() : e > i ? s() : e <
							i && l(), this.$currentSlide = r.addClass(
								"carousel-slide-current")
					}
				},
				none: {
					init: function() {
						this.$container.attr("data-effect", "none"), this.$currentSlide
							.addClass("carousel-slide-current carousel-slide-active")
							.siblings().removeClass(
								"carousel-slide-current carousel-slide-active")
					},
					transition: function(e, t) {
						var n = this,
							r = this.$slides.eq(e);
						this.$currentSlide.removeClass("carousel-slide-current"),
							setTimeout((function() {
								t(n)
							}), this.options.speed), this.$currentSlide = r.addClass(
								"carousel-slide-current")
					}
				}
			};
		r.prototype.goto = function(e) {
			var t = this.$slides.eq(e);
			if (e !== this.currentIndex && 0 !== t.length && !0 !== this.sliding) {
				var n = this,
					r = this.currentIndex,
					a = [{
						$startSlide: this.$currentSlide,
						$targetSlide: t,
						startIndex: r,
						targetIndex: e
					}];
				this.events.beforeSlide.forEach((function(e) {
					e.apply(n, a)
				}));
				this.sliding = !0, this.$currentSlide.removeClass("carousel-slide-current"),
					i[this.options.effect].transition.call(this, e, (function(e) {
						$(".carousel-slide").removeClass("carousel-slide-active"), e
							.$activeSlide = t.addClass("carousel-slide-active"), e
							.sliding = !1, e.events.afterSlide.forEach((function(
							t) {
								t.apply(e, a)
							}))
					})), this.$currentSlide = t.addClass("carousel-slide-current"), this
					.currentIndex = e, this.activeIndicator(e), this.playing > 0 && this
					.timeOutToNext(this.playing)
			}
		}, r.prototype.next = function() {
			var e = this.currentIndex + 1;
			e > this.$slides.length - 1 && (e = 0), this.goto(e)
		}, r.prototype.prev = function() {
			var e = this.currentIndex - 1;
			e < 0 && (e = this.$slides.length - 1), this.goto(e)
		}, r.prototype.play = function(e) {
			e = e >= 0 ? e : this.options.autoplay, this.playing > 0 || (this.playing = e,
				this.timeOutToNext(e))
		}, r.prototype.pause = function() {
			"number" == typeof this.playTimerIndex && (clearTimeout(this.playTimerIndex),
				this.playing = 0)
		}, r.prototype.timeOutToNext = function(e) {
			var t = this,
				n = parseInt(this.$currentSlide.attr("carousel-autoplay"));
			n && (e = n), e > 0 && (clearTimeout(this.playTimerIndex), this.playTimerIndex =
				setTimeout((function() {
					t.next()
				}), e))
		}, r.prototype.activeIndicator = function(e) {
			this.$indicators.removeClass("carousel-indicator-active").eq(e).addClass(
				"carousel-indicator-active")
		}, r.prototype.addEvent = function(e, t) {
			this.events[e] && this.events[e].push(t)
		};
		var a = r;
		t.default = a
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(24);
		var s = n(25),
			l = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t), this.bindEvents()
				}
				return (0, a.default)(e, [{
					key: "bindEvents",
					value: function() {
						var e = $(window).height(),
							t = $(document),
							n = e + 300,
							r = $(".immersion-banner-fixed"),
							i = t.scrollTop();
						i > 0 && ($(".immersion-banner-mask").css("background",
								"rgba(0,0,0,".concat(Math.sqrt(i / e), ")")
								), setTimeout((function() {
								var e = window.document.createEvent(
									"UIEvents");
								e.initUIEvent("scroll", !0, !1,
										window, 0), window
									.dispatchEvent(e)
							}), 200)), $(window).scroll((function() {
							var i = t.scrollTop();
							$(".immersion-banner-mask").css(
									"background", "rgba(0,0,0,"
									.concat(Math.sqrt(i / e), ")")),
								i > n ? r.hide() : r.show()
						})), $(".immersion-banner-container").on("click", (
							function() {
								window.open($(this).attr("data-link"))
							})), $(".link-column a").on("click", (function(
							e) {
							e.stopPropagation()
						}))
					}
				}, {
					key: "closeFixedStyleIE",
					value: function() {
						(0, s.isIE)() && ($(".immersion-banner-fixed").css(
							"position", "absolute"), $(
							".immersion-banner-fixed").css("top", "0"))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "immersion-banner"
					}
				}]), e
			}();
		t.default = l
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.isIE = function() {
			var e = navigator.userAgent;
			return -1 !== e.indexOf("compatible") && -1 !== e.indexOf("MSIE") || -1 !== e
				.indexOf("Edge") || -1 !== e.indexOf("Trident") && -1 !== e.indexOf(
					"rv:11.0")
		}
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(27);
		var s = r(n(28)),
			l = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t), this.init()
				}
				return (0, a.default)(e, [{
					key: "init",
					value: function() {
						/iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ?
							this.initBackground() : this.initAnimation()
					}
				}, {
					key: "initBackground",
					value: function() {
						this.$el.find(".home-frame-card i").each((function(e,
						t) {
							var n = $(t),
								r = n.attr("data-image");
							n.css({
								backgroundImage: "url(" +
									r + ")"
							})
						}))
					}
				}, {
					key: "initAnimation",
					value: function() {
						this.$el.find(".home-frame-card").on("mouseenter", (
							function(e) {
								$(e.currentTarget).addClass("hover")
							})).on("mouseleave", (function(e) {
							$(e.currentTarget).removeClass("hover")
						})).each((function(e, t) {
							var n = $(t);
							if (!(n.find("i img").length > 0)) {
								var r = n.find("i").attr(
									"data-image");
								$('<img src="' + r + '">').on(
									"load", (function(e) {
										var t = $(e
												.currentTarget
												),
											r = Math.floor(t
												.height() /
												t.width()) -
											1;
										n.addClass(
											"loaded"), n.on(
												"mouseenter",
												(function() {
													var e =
														n
														.data(
															"frameAnimation"
															);
													e || (e =
															new s
															.default(
																n
																.find(
																	"i"
																	)
																.get(
																	0
																	), {
																	useImage:
																		!
																		0,
																	startFrame: 0,
																	endFrame: r,
																	interval: 1e3 /
																		30
																}
																)
															),
														n
														.data(
															"frameAnimation",
															e
															),
														e
														.play()
												})).on(
												"mouseleave",
												(function() {
													var e =
														n
														.data(
															"frameAnimation"
															);
													e && e
														.playBackward()
												})), n
											.hasClass(
												"hover") &&
											n.trigger(
												"mouseenter"
												)
									})).appendTo(n.find("i"))
							}
						}))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "frames"
					}
				}]), e
			}();
		t.default = l
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));

		function s(e, t) {
			var n = Object.keys(e);
			if (Object.getOwnPropertySymbols) {
				var r = Object.getOwnPropertySymbols(e);
				t && (r = r.filter((function(t) {
					return Object.getOwnPropertyDescriptor(e, t).enumerable
				}))), n.push.apply(n, r)
			}
			return n
		}

		function l(e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = null != arguments[t] ? arguments[t] : {};
				t % 2 ? s(Object(n), !0).forEach((function(t) {
					(0, o.default)(e, t, n[t])
				})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object
					.getOwnPropertyDescriptors(n)) : s(Object(n)).forEach((function(t) {
					Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n,
						t))
				}))
			}
			return e
		}
		var u = {
				useImage: !1,
				auto: !0,
				frameWidth: null,
				frameHeight: null,
				spacing: 0,
				interval: 40,
				startFrame: 0,
				endFrame: null,
				loopStartFrame: null,
				loopEndFrame: null
			},
			c = void 0 !== document.body.style.transform ? "transform" : "webkitTransform",
			h = function() {
				function e(t) {
					var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					(0, i.default)(this, e), (0, o.default)(this, "element", void 0), (0, o
						.default)(this, "image", void 0), (0, o.default)(this, "opts", void 0),
					(0, o.default)(this, "currentFrame", 0), (0, o.default)(this, "timerIndex",
						null), (0, o.default)(this, "hasLoopFrames", void 0), this.element = t,
						this.opts = l(l({}, u), n), this.fixOpts(), this.opts.useImage && (this
							.image = this.element.querySelector("img")), this.opts.auto && this
						.auto()
				}
				return (0, a.default)(e, [{
					key: "fixOpts",
					value: function() {
						null === this.opts.frameWidth && (this.opts.frameWidth =
								this.element.clientWidth), null === this.opts
							.frameHeight && (this.opts.frameHeight = this
								.element.clientHeight), this.hasLoopFrames =
							this.opts.loopEndFrame > this.opts.loopStartFrame
					}
				}, {
					key: "auto",
					value: function() {
						var e = this;
						this.element.addEventListener("mouseenter", (
					function() {
							e.play()
						})), this.element.addEventListener("mouseleave", (
							function() {
								e.playBackward()
							}))
					}
				}, {
					key: "play",
					value: function() {
						var e = this;
						this.playForward((function() {
							e.playLoopFrames()
						}))
					}
				}, {
					key: "playForward",
					value: function(e) {
						this.currentFrame > this.opts.endFrame || this.playTo(
							this.opts.endFrame, e)
					}
				}, {
					key: "playBackward",
					value: function(e) {
						this.currentFrame < this.opts.startFrame || this.playTo(
							this.opts.startFrame, e)
					}
				}, {
					key: "playLoopFrames",
					value: function() {
						var e = this;
						this.hasLoopFrames && (clearInterval(this.timerIndex),
							this.timerIndex = setInterval((function() {
								e.currentFrame++, (e.currentFrame <
										e.opts.loopStartFrame || e
										.currentFrame > e.opts
										.loopEndFrame) && (e
										.currentFrame = e.opts
										.loopStartFrame), e
									.updateElement()
							}), this.opts.interval))
					}
				}, {
					key: "playFromTo",
					value: function(e, t, n) {
						this.currentFrame = e, this.updateElement(), this
							.playTo(t, n)
					}
				}, {
					key: "playTo",
					value: function(e, t) {
						var n = this;
						clearInterval(this.timerIndex), this.currentFrame !==
							e && (this.timerIndex = setInterval((function() {
								n.currentFrame - e < 0 ? n
									.currentFrame++ : n
									.currentFrame - e > 0 && n
									.currentFrame--, n
									.updateElement(), n
									.currentFrame === e && (
										clearInterval(n.timerIndex),
										t && t())
							}), this.opts.interval))
					}
				}, {
					key: "pause",
					value: function() {
						clearInterval(this.timerIndex)
					}
				}, {
					key: "stop",
					value: function() {
						clearInterval(this.timerIndex), this.currentFrame = 0,
							this.updateElement()
					}
				}, {
					key: "updateElement",
					value: function() {
						var e = 0 === this.currentFrame ? 0 : this.opts
							.frameHeight * this.currentFrame + this.opts
							.spacing * this.currentFrame;
						this.opts.useImage ? this.image.style[c] =
							"translateY(" + -e + "px)" : this.element.style
							.backgroundPositionY = -e + "px"
					}
				}]), e
			}();
		t.default = h
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(30);
		var s = r(n(9)),
			l = r(n(4)),
			u = r(n(31)),
			c = r(n(32)),
			h = r(n(5)),
			d = r(n(33)),
			f = r(n(34)),
			p = new d.default(f.default),
			v = (0, u.default)(300),
			m = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t),this.bindEvents()
				}
				return (0, a.default)(e, [{
					key: "getCustomerCookie",
					value: function(e) {
						var t = "",
							n = "";
						return document.cookie.length > 0 && -1 !== (t =
							document.cookie.indexOf(e + "=")) ? (t = t + e
							.length + 1, -1 === (n = document.cookie
								.indexOf(";", t)) && (n = document.cookie
								.length), decodeURI(document.cookie
								.substring(t, n))) : ""
					}
				},{
					key: "isIE",
					value: function() {
						var e = navigator.userAgent;
						return -1 !== e.indexOf("compatible") && -1 !== e
							.indexOf("MSIE") || -1 !== e.indexOf("Edge") || -
							1 !== e.indexOf("Trident") && -1 !== e.indexOf(
								"rv:11.0")
					}
				}, {
					key: "bindEvents",
					value: function() {
						(0, l.default)(1024) ? this.bindEvents_pc(): this
							.bindEvents_mb()
					}
				}, {
					key: "bindEvents_pc",
					value: function() {
						var e = this.$el,
							t = function(t) {
								var n = $(t);
								n.addClass("active").siblings().removeClass(
									"active");
								var r = n.attr("data-target"),
									i = e.find(".product-content").filter(
										'[data-name="' + r + '"]');
								i.addClass("show").siblings().removeClass(
									"show"), i.trigger("afterShow")
							};
						e.find(".product-nav-menus").on("mouseenter",
							".product-nav-menu", (function(e) {
								var n = this,
									r = c.default.getMoveAngle();
								$(e.relatedTarget).closest(
										".product-nav-menu").length >
									0 && r > -75 && r < 75 ? v((
										function() {
											t(n)
										})) : v((function() {
										t(n)
									}), 0)
							})), e.find(".product-nav-menus").on(
							"mouseleave", (function() {
								v((function() {}))
							}));
						var n = function(e) {
							var t;
							e.is(":visible") && e.find(".product-card")
								.each((function(e) {
									var n, r;
									e % 3 == 0 && (t = $("")), t = t
										.add($(this).find("p")), e %
										3 == 2 && (r = 0, (n = t)
											.height("").each((
												function() {
													var e = $(
														this
														);
													if (e.is(
															":visible"
															)) {
														var t =
															e
															.height();
														t > r &&
															(r =
																t)
													}
												})), n.filter(
												":visible").height(
												r))
								}))
						};
						e.closest(".section-group-product").find(
							".product-list").each((function() {
							var e;
							e = $(this), n(e), $(window).resize((
								function() {
									n(e)
								}))
						})), e.closest(".section-group-product").on(
							"afterShow", (function(e) {
								n($(e.currentTarget).find(
									".product-list"))
							}))
					}
				}, {
					key: "bindEvents_mb",
					value: function() {
						this.$el.on("click", ".product-m-tab > a", (function() {
							var e = $(this);
							if (!e.hasClass("active")) {
								var t, n, r = e.index(),
									i = e.offset().top - $(
										".header-container")
									.outerHeight(),
									a = e.closest(
										".product-m-tab-container")
									.find(".product-m-tab a"),
									o = a.filter(".active").parent()
									.next(".product-m-tab-wrapper"),
									s = e.parent().next(
										".product-m-tab-wrapper"),
									l = s.children(
										".product-m-tab-content")
									.eq(r);
								s.show().height(s.height()), a
									.removeClass("active"), e
									.addClass("active"), l.addClass(
										"show").siblings()
									.removeClass("show"), n = (t =
										s).children(".show")
									.outerHeight(), t.height(n), o[
										0] !== s[0] && (o.offset()
										.top < s.offset().top && (
											i -= o.height()),
										function(e) {
											var t = !1;
											e.one("transitionend", (
													function() {
														t = !0,
															e
															.hide()
													})).height(0),
												setTimeout((
													function() {
														t || e
															.trigger(
																"transitionend"
																)
													}), 350)
										}(o)), $("html,body")
									.animate({
										scrollTop: i
									})
							}
						}))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "product"
					}
				}]), e
			}();
		t.default = m
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = function(e) {
			var t;
			return function(n) {
				var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
					e;
				"number" == typeof t && clearTimeout(t), t = setTimeout(n, r)
			}
		}
	}, function(e, t, n) {
		"use strict";
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var r = [];
		$(document).mousemove((function(e) {
			var t = {
				x: e.pageX,
				y: e.pageY
			};
			if (0 === r.length)
				for (var n = 0; n < 2; n++) r.push(t);
			r.push(t), r.length > 3 && r.shift()
		}));
		var i = {
			getDirectionAngle: function(e, t, n, r) {
				var i = r - t,
					a = n - e,
					o = Math.atan(i / a) / Math.PI * 180;
				return a < 0 && i > 0 ? o = 180 + o : a < 0 && i < 0 && (o -= 180), o
			},
			getMoveAngle: function() {
				var e = r[0],
					t = r[r.length - 1];
				return e ? this.getDirectionAngle(e.x, e.y, t.x, t.y) : 0
			},
			getMouseLocus: function() {
				return r
			}
		};
		t.default = i
	}, function(t, n) {
		t.exports = e("@cloud/xtemplate-runtime")
	}, function(e, t, n) {
		"use strict";
		n.r(t);
		var r = function(e) {
			var t, n, r = this,
				i = r.root,
				a = r.buffer,
				o = r.scope,
				s = (r.runtime, r.name, r.pos),
				l = o.data,
				u = o.affix,
				c = i.nativeCommands,
				h = i.utils,
				d = (h.callFn, h.callDataFn, h.callCommand, c.range, c.void, c.foreach, c
					.forin, c.each),
				f = (c.with, c.if);
			c.set, c.include, c.includeOnce, c.parse, c.extend, c.block, c.macro, c
			.debugger;

			function p(e, r, i) {
				var a = e.data,
					o = e.affix;
				r.data +=
					'\n            <div class="product-label-angel product-label-angel-', s
					.line = 6;
				var l = (t = o.r) !== i || (t = a.r) !== i ? null != t ? null != (n = t
					.angle) ? n.type : n : t : e.resolveLooseUp(["r", "angle", "type"]);
				(r = r.writeEscaped(l)).data += '">\n                <span>', s.line = 7;
				var u = (t = o.r) !== i || (t = a.r) !== i ? null != t ? null != (n = t
					.angle) ? n.text : n : t : e.resolveLooseUp(["r", "angle", "text"]);
				return (r = r.writeEscaped(u)).data +=
					"</span>\n            </div>\n            ", r
			}

			function v(e, r, i) {
				var a = e.data,
					o = e.affix;
				r.data += '<span class="product-tag">';
				var s = (t = o.r) !== i || (t = a.r) !== i ? null != t ? n = t.tag : t : e
					.resolveLooseUp(["r", "tag"]);
				return (r = r.writeEscaped(s)).data += "</span>", r
			}

			function m(e, r, i) {
				var a = e.data,
					o = e.affix;
				r.data += '\n            <div class="product-price">', s.line = 13;
				var l = (t = o.r) !== i || (t = a.r) !== i ? null != t ? null != (n = t
					.prices) ? n[0] : n : t : e.resolveLooseUp(["r", "prices", 0]);
				return (r = r.write(l)).data += "</div>\n            ", r
			}

			function g(e, n, r) {
				var i = e.data,
					a = e.affix;
				n.data +=
					'\n                <div class="product-tag product-tag-outline-grey">',
					s.line = 18;
				var o = (t = a.label) !== r || (t = i.label) !== r ? t : e.resolveLooseUp([
					"label"
				]);
				return (n = n.writeEscaped(o)).data += "</div>\n                ", n
			}

			function y(e, i, a) {
				var o = e.data,
					l = e.affix;
				i.data += '\n            <div class="product-labels">\n                ', s
					.line = 17, s.line = 17;
				var u = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n = t.labels : t :
					e.resolveLooseUp(["r", "labels"]);
				return (i = d.call(r, e, {
					params: [u, "label", "i"],
					fn: g
				}, i)).data += "\n            </div>\n            ", i
			}
			a.data += "", s.line = 1;
			var x = (t = u.recommends) !== e || (t = l.recommends) !== e ? t : o
				.resolveLooseUp(["recommends"]);
			return a = d.call(r, o, {
				params: [x, "r", "index"],
				fn: function(e, i, a) {
					var o = e.data,
						l = e.affix;
					i.data += '\n<li bi_parent_name="default_', s.line = 2;
					var u = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.title : t : e.resolveLooseUp(["r", "title"]);
					(i = i.writeEscaped(u)).data += '" meta-data-product-i="';
					var c = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.recmaterial : t : e.resolveLooseUp(["r",
							"recmaterial"]);
					(i = i.writeEscaped(c)).data +=
						'">\n    <a class="product-card" href="', s.line = 3;
					var h = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.href : t : e.resolveLooseUp(["r", "href"]);
					(i = i.writeEscaped(h)).data +=
						'" target="_blank" bi_param_ab_test="';
					var d = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.abtest : t : e.resolveLooseUp(["r", "abtest"]);
					(i = i.writeEscaped(d)).data += '" bi_param_ab_version="';
					var g = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.abversion : t : e.resolveLooseUp(["r", "abversion"]);
					(i = i.writeEscaped(g)).data += '" bi_param_rec_channel="';
					var x = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.recchannel : t : e.resolveLooseUp(["r",
						"recchannel"]);
					(i = i.writeEscaped(x)).data += '" bi_param_rec_material="';
					var _ = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.recmaterial : t : e.resolveLooseUp(["r",
							"recmaterial"]);
					(i = i.writeEscaped(_)).data += '" bi_param_rec_source="';
					var b = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.recsource : t : e.resolveLooseUp(["r", "recsource"]);
					(i = i.writeEscaped(b)).data += '" bi_param_rec_position="';
					var w = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.recpostion : t : e.resolveLooseUp(["r",
						"recpostion"]);
					(i = i.writeEscaped(w)).data +=
						'">\n        <div class="product-card-inner">\n            ',
						s.line = 5, s.line = 5;
					var M = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.angle : t : e.resolveLooseUp(["r", "angle"]);
					(i = f.call(r, e, {
						params: [M],
						fn: p
					}, i)).data += "\n            <h5>", s.line = 10;
					var S = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.title : t : e.resolveLooseUp(["r", "title"]);
					(i = i.writeEscaped(S)).data += "";
					var T = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.tag : t : e.resolveLooseUp(["r", "tag"]);
					(i = f.call(r, e, {
						params: [T],
						fn: v
					}, i)).data += "</h5>\n            <p>", s.line = 11;
					var E = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.desc : t : e.resolveLooseUp(["r", "desc"]);
					(i = i.write(E)).data += "</p>\n            ", s.line = 12,
						s.line = 12;
					var A = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.prices : t : e.resolveLooseUp(["r", "prices"]);
					if (A) {
						var L = (t = l.r) !== a || (t = o.r) !== a ? null != t ?
							null != (n = t.prices) ? n.length : n : t : e
							.resolveLooseUp(["r", "prices", "length"]);
						A = L > 0
					}(i = f.call(r, e, {
						params: [A],
						fn: m
					}, i)).data += "\n            ", s.line = 15, s.line = 15;
					var k = (t = l.r) !== a || (t = o.r) !== a ? null != t ? n =
						t.labels : t : e.resolveLooseUp(["r", "labels"]);
					return (i = f.call(r, e, {
						params: [k],
						fn: y
					}, i)).data += "\n        </div>\n    </a>\n</li>\n", i
				}
			}, a), a.data += "\n", a
		};
		r.TPL_NAME = "recommends.xtpl", t.default = r
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(36);
		var s = function() {
			function e(t) {
				(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
					t), this.init()
			}
			return (0, a.default)(e, [{
				key: "init",
				value: function() {
					window.innerWidth > 1024 ? this.init_PC() : this
					.init_m()
				}
			}, {
				key: "init_PC",
				value: function() {
					var e = this.$el;
					$("[data-src-pc]").each((function() {
						var t = $(this),
							n = t.attr("data-src-pc");
						$('<div class="preload" style="background-image: url('
								.concat(n, ')">')).appendTo(e),
							t.css({
								backgroundImage: "url("
									.concat(n, ")")
							})
					}))
				}
			}, {
				key: "init_m",
				value: function() {
					var e = this;
					$("[data-src-m]").each((function() {
						var e = $(this),
							t = e.attr("data-src-m");
						e.css({
							backgroundImage: "url("
								.concat(t, ")")
						})
					})), this.$el.on("click", ".por-collapse-trigger", (
						function(t) {
							var n = $(t.currentTarget),
								r = e.$el.find(
									".por-collapse-trigger.expended"
									),
								i = n.offset().top,
								a = i - $(".header-container")
								.outerHeight();
							r[0] && r[0] !== e && r.offset().top <
								i && (a -= r.siblings().height()),
								$("html,body").animate({
									scrollTop: a
								})
						})), this.$el.on("beforeShow",
						".por-tab-content", (function() {
							$(this).siblings().find(".por-collapse")
								.porCollapse("hide")
						}))
				}
			}], [{
				key: "moduleName",
				value: function() {
					return "company"
				}
			}]), e
		}();
		t.default = s
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(38);
		var s = function() {
				return window.innerWidth > 1023
			},
			l = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t), this.init()
				}
				return (0, a.default)(e, [{
					key: "init",
					value: function() {
						var e = {
							simulateTouch: !0
						};
						s() ? (e.navigation = {
								prevEl: this.$el.find(".solutions-prev")
									.get(0),
								nextEl: this.$el.find(".solutions-next")
									.get(0)
							}, e.speed = 1e3) : e.pagination = !0, this.$el
							.find(".por-carousel").porCarousel(e), this.$el
							.find(".por-carousel").on("dragstart", "a", (
								function() {
									return !1
								})), s() && this.$el.on("mouseenter",
								".solutions-list > li", (function() {
									var e = $(this).children(),
										t = e.closest(".solutions-list"),
										n = e.find("p"),
										r = .4 * t.width() - 16 - 64;
									n.width(r)
								}))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "solutions"
					}
				}]), e
			}();
		t.default = l
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(40);
		var s = function() {
			function e(t) {
				(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
					t), this.init()
			}
			return (0, a.default)(e, [{
				key: "init",
				value: function() {}
			}], [{
				key: "moduleName",
				value: function() {
					return "stack"
				}
			}]), e
		}();
		t.default = s
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(42);
		var s = function() {
			function e(t) {
				(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
					t), this.init()
			}
			return (0, a.default)(e, [{
				key: "init",
				value: function() {
					window.innerWidth > 1023 && (this.initTab(), this
						.initLogoTab())
				}
			}, {
				key: "initTab",
				value: function() {
					var e = this;
					this.$el.on("click", ".customers-tab-item", (function(
					t) {
						var n = $(t.currentTarget),
							r = n.index(),
							i = n.closest(".customers-tab")
							.find(".customers-tab-content"),
							a = i.eq(r);
						n.addClass("active").siblings()
							.removeClass("active"), i
							.removeClass("show"), a.addClass(
								"show"), e.setBg(a.find(
								".customers-logo.active"))
					}))
				}
			}, {
				key: "initLogoTab",
				value: function() {
					var e = this;
					this.$el.find(".customers-logo").each((function(t, n) {
						var r = $(n),
							i = r.attr("data-section-bg"),
							a = $(
								'<div class="customers-bg"></div>'
								);
						r.data("$bg", a), a.css(
							"background-image", 'url("'
							.concat(i, '")')).appendTo(e.$el
							.find(".customers-bgs"))
					})), this.$el.on("click", ".customers-logo", (
						function(t) {
							var n = $(t.currentTarget),
								r = n.index();
							n.addClass("active").siblings()
								.removeClass("active"), n.closest(
									".customers-tab-content").find(
									".customers-text").removeClass(
									"show").eq(r).addClass("show"),
								e.setBg(n)
						}))
				}
			}, {
				key: "setBg",
				value: function(e) {
					e.data("$bg").prependTo(this.$el.find(".customers-bgs"))
				}
			}], [{
				key: "moduleName",
				value: function() {
					return "customers"
				}
			}]), e
		}();
		t.default = s
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(44);
		var s = r(n(5)),
			l = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t), this.init()
				}
				return (0, a.default)(e, [{
					key: "init",
					value: function() {
						window.innerWidth > 1023 && new s.default({
							containerSelector: this.$el.get(0),
							innerSelector: ".information-frontground",
							startTop: 600,
							endTop: 100
						}).$inners.addClass("init-parallax")
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "information"
					}
				}]), e
			}();
		t.default = l
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(46);
		var s = function() {
			function e(t) {
				(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
					t), this.init()
			}
			return (0, a.default)(e, [{
				key: "init",
				value: function() {}
			}], [{
				key: "moduleName",
				value: function() {
					return "safety"
				}
			}]), e
		}();
		t.default = s
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(48);
		var s = r(n(5)),
			l = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t), this.init(), this.bindEvents()
				}
				return (0, a.default)(e, [{
					key: "init",
					value: function() {
						if (window.innerWidth > 1023) {
							var e = $(window).height();
							new s.default({
								containerSelector: this.$el.get(0),
								innerSelector: ".home-world-sites .section",
								startTop: e,
								endTop: e - 100,
								neverEnd: !0
							}).$inners.addClass("init-parallax")
						}
					}
				}, {
					key: "bindEvents",
					value: function() {
						this.$el.on("click", ".sites-tab-item", (function() {
							var e = $(this),
								t = e.index();
							e.addClass("active").siblings()
								.removeClass("active"), e.closest(
									".sites-tab").find(
									".sites-tab-content")
								.removeClass("show").eq(t).addClass(
									"show")
						}))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "world-sites"
					}
				}]), e
			}();
		t.default = l
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(10);
		var s = r(n(4)),
			l = r(n(5)),
			u = r(n(50)),
			c = function() {
				function e(t) {
					(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
						t),this.bindEvents()
				}
				return (0, a.default)(e, [{
					key: "bindEvents",
					value: function() {
						var e = $(".tab-seletor");
						e.click((function() {
							e.removeClass("active"), $(this)
								.addClass("active"), $(
									".tab-section").removeClass(
									"show"), $(
									".tab-section[data-name=" + $(
										this).attr("data-key") + "]"
									).addClass("show")
						}))
					}
				}], [{
					key: "moduleName",
					value: function() {
						return "global-site-3d"
					}
				}]), e
			}();
		t.default = c
	}, function(e, t, n) {
		"use strict";
		var r = n(0),
			i = n(6);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var a = r(n(11)),
			o = r(n(12)),
			s = r(n(1)),
			l = r(n(2)),
			u = r(n(3));
		n(10);
		var c = function(e, t) {
				if (!t && e && e.__esModule) return e;
				if (null === e || "object" !== i(e) && "function" != typeof e) return {
					default: e
				};
				var n = d(t);
				if (n && n.has(e)) return n.get(e);
				var r = {},
					a = Object.defineProperty && Object.getOwnPropertyDescriptor;
				for (var o in e)
					if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
						var s = a ? Object.getOwnPropertyDescriptor(e, o) : null;
						s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = e[o]
					} r.default = e, n && n.set(e, r);
				return r
			}(n(13)),
			h = n(61);

		function d(e) {
			if ("function" != typeof WeakMap) return null;
			var t = new WeakMap,
				n = new WeakMap;
			return (d = function(e) {
				return e ? n : t
			})(e)
		}

		function f(e, t) {
			var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
			if (!n) {
				if (Array.isArray(e) || (n = function(e, t) {
						if (!e) return;
						if ("string" == typeof e) return p(e, t);
						var n = Object.prototype.toString.call(e).slice(8, -1);
						"Object" === n && e.constructor && (n = e.constructor.name);
						if ("Map" === n || "Set" === n) return Array.from(e);
						if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/
							.test(n)) return p(e, t)
					}(e)) || t && e && "number" == typeof e.length) {
					n && (e = n);
					var r = 0,
						i = function() {};
					return {
						s: i,
						n: function() {
							return r >= e.length ? {
								done: !0
							} : {
								done: !1,
								value: e[r++]
							}
						},
						e: function(e) {
							throw e
						},
						f: i
					}
				}
				throw new TypeError(
					"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
					)
			}
			var a, o = !0,
				s = !1;
			return {
				s: function() {
					n = n.call(e)
				},
				n: function() {
					var e = n.next();
					return o = e.done, e
				},
				e: function(e) {
					s = !0, a = e
				},
				f: function() {
					try {
						o || null == n.return || n.return()
					} finally {
						if (s) throw a
					}
				}
			}
		}

		function p(e, t) {
			(null == t || t > e.length) && (t = e.length);
			for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
			return r
		}
	}, function(e, t, n) {
		var r = function(e) {
			"use strict";
			var t, n = Object.prototype,
				r = n.hasOwnProperty,
				i = "function" == typeof Symbol ? Symbol : {},
				a = i.iterator || "@@iterator",
				o = i.asyncIterator || "@@asyncIterator",
				s = i.toStringTag || "@@toStringTag";

			function l(e, t, n) {
				return Object.defineProperty(e, t, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}), e[t]
			}
			try {
				l({}, "")
			} catch (e) {
				l = function(e, t, n) {
					return e[t] = n
				}
			}

			function u(e, t, n, r) {
				var i = t && t.prototype instanceof m ? t : m,
					a = Object.create(i.prototype),
					o = new L(r || []);
				return a._invoke = function(e, t, n) {
					var r = h;
					return function(i, a) {
						if (r === f) throw new Error(
						"Generator is already running");
						if (r === p) {
							if ("throw" === i) throw a;
							return R()
						}
						for (n.method = i, n.arg = a;;) {
							var o = n.delegate;
							if (o) {
								var s = T(o, n);
								if (s) {
									if (s === v) continue;
									return s
								}
							}
							if ("next" === n.method) n.sent = n._sent = n.arg;
							else if ("throw" === n.method) {
								if (r === h) throw r = p, n.arg;
								n.dispatchException(n.arg)
							} else "return" === n.method && n.abrupt("return", n
								.arg);
							r = f;
							var l = c(e, t, n);
							if ("normal" === l.type) {
								if (r = n.done ? p : d, l.arg === v) continue;
								return {
									value: l.arg,
									done: n.done
								}
							}
							"throw" === l.type && (r = p, n.method = "throw", n
								.arg = l.arg)
						}
					}
				}(e, n, o), a
			}

			function c(e, t, n) {
				try {
					return {
						type: "normal",
						arg: e.call(t, n)
					}
				} catch (e) {
					return {
						type: "throw",
						arg: e
					}
				}
			}
			e.wrap = u;
			var h = "suspendedStart",
				d = "suspendedYield",
				f = "executing",
				p = "completed",
				v = {};

			function m() {}

			function g() {}

			function y() {}
			var x = {};
			l(x, a, (function() {
				return this
			}));
			var _ = Object.getPrototypeOf,
				b = _ && _(_(k([])));
			b && b !== n && r.call(b, a) && (x = b);
			var w = y.prototype = m.prototype = Object.create(x);

			function M(e) {
				["next", "throw", "return"].forEach((function(t) {
					l(e, t, (function(e) {
						return this._invoke(t, e)
					}))
				}))
			}

			function S(e, t) {
				function n(i, a, o, s) {
					var l = c(e[i], e, a);
					if ("throw" !== l.type) {
						var u = l.arg,
							h = u.value;
						return h && "object" == typeof h && r.call(h, "__await") ? t
							.resolve(h.__await).then((function(e) {
								n("next", e, o, s)
							}), (function(e) {
								n("throw", e, o, s)
							})) : t.resolve(h).then((function(e) {
								u.value = e, o(u)
							}), (function(e) {
								return n("throw", e, o, s)
							}))
					}
					s(l.arg)
				}
				var i;
				this._invoke = function(e, r) {
					function a() {
						return new t((function(t, i) {
							n(e, r, t, i)
						}))
					}
					return i = i ? i.then(a, a) : a()
				}
			}

			function T(e, n) {
				var r = e.iterator[n.method];
				if (r === t) {
					if (n.delegate = null, "throw" === n.method) {
						if (e.iterator.return && (n.method = "return", n.arg = t, T(e, n),
								"throw" === n.method)) return v;
						n.method = "throw", n.arg = new TypeError(
							"The iterator does not provide a 'throw' method")
					}
					return v
				}
				var i = c(r, e.iterator, n.arg);
				if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n
					.delegate = null, v;
				var a = i.arg;
				return a ? a.done ? (n[e.resultName] = a.value, n.next = e.nextLoc,
					"return" !== n.method && (n.method = "next", n.arg = t), n
					.delegate = null, v) : a : (n.method = "throw", n.arg =
					new TypeError("iterator result is not an object"), n.delegate =
					null, v)
			}

			function E(e) {
				var t = {
					tryLoc: e[0]
				};
				1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc =
					e[3]), this.tryEntries.push(t)
			}

			function A(e) {
				var t = e.completion || {};
				t.type = "normal", delete t.arg, e.completion = t
			}

			function L(e) {
				this.tryEntries = [{
					tryLoc: "root"
				}], e.forEach(E, this), this.reset(!0)
			}

			function k(e) {
				if (e) {
					var n = e[a];
					if (n) return n.call(e);
					if ("function" == typeof e.next) return e;
					if (!isNaN(e.length)) {
						var i = -1,
							o = function n() {
								for (; ++i < e.length;)
									if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
								return n.value = t, n.done = !0, n
							};
						return o.next = o
					}
				}
				return {
					next: R
				}
			}

			function R() {
				return {
					value: t,
					done: !0
				}
			}
			return g.prototype = y, l(w, "constructor", y), l(y, "constructor", g), g
				.displayName = l(y, s, "GeneratorFunction"), e.isGeneratorFunction =
				function(e) {
					var t = "function" == typeof e && e.constructor;
					return !!t && (t === g || "GeneratorFunction" === (t.displayName || t
						.name))
				}, e.mark = function(e) {
					return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e
							.__proto__ = y, l(e, s, "GeneratorFunction")), e.prototype =
						Object.create(w), e
				}, e.awrap = function(e) {
					return {
						__await: e
					}
				}, M(S.prototype), l(S.prototype, o, (function() {
					return this
				})), e.AsyncIterator = S, e.async = function(t, n, r, i, a) {
					void 0 === a && (a = Promise);
					var o = new S(u(t, n, r, i), a);
					return e.isGeneratorFunction(n) ? o : o.next().then((function(e) {
						return e.done ? e.value : o.next()
					}))
				}, M(w), l(w, s, "Generator"), l(w, a, (function() {
					return this
				})), l(w, "toString", (function() {
					return "[object Generator]"
				})), e.keys = function(e) {
					var t = [];
					for (var n in e) t.push(n);
					return t.reverse(),
						function n() {
							for (; t.length;) {
								var r = t.pop();
								if (r in e) return n.value = r, n.done = !1, n
							}
							return n.done = !0, n
						}
				}, e.values = k, L.prototype = {
					constructor: L,
					reset: function(e) {
						if (this.prev = 0, this.next = 0, this.sent = this._sent = t,
							this.done = !1, this.delegate = null, this.method = "next",
							this.arg = t, this.tryEntries.forEach(A), !e)
							for (var n in this) "t" === n.charAt(0) && r.call(this,
								n) && !isNaN(+n.slice(1)) && (this[n] = t)
					},
					stop: function() {
						this.done = !0;
						var e = this.tryEntries[0].completion;
						if ("throw" === e.type) throw e.arg;
						return this.rval
					},
					dispatchException: function(e) {
						if (this.done) throw e;
						var n = this;

						function i(r, i) {
							return s.type = "throw", s.arg = e, n.next = r, i && (n
								.method = "next", n.arg = t), !!i
						}
						for (var a = this.tryEntries.length - 1; a >= 0; --a) {
							var o = this.tryEntries[a],
								s = o.completion;
							if ("root" === o.tryLoc) return i("end");
							if (o.tryLoc <= this.prev) {
								var l = r.call(o, "catchLoc"),
									u = r.call(o, "finallyLoc");
								if (l && u) {
									if (this.prev < o.catchLoc) return i(o.catchLoc, !
									0);
									if (this.prev < o.finallyLoc) return i(o.finallyLoc)
								} else if (l) {
									if (this.prev < o.catchLoc) return i(o.catchLoc, !0)
								} else {
									if (!u) throw new Error(
										"try statement without catch or finally"
										);
									if (this.prev < o.finallyLoc) return i(o.finallyLoc)
								}
							}
						}
					},
					abrupt: function(e, t) {
						for (var n = this.tryEntries.length - 1; n >= 0; --n) {
							var i = this.tryEntries[n];
							if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this
								.prev < i.finallyLoc) {
								var a = i;
								break
							}
						}
						a && ("break" === e || "continue" === e) && a.tryLoc <= t &&
							t <= a.finallyLoc && (a = null);
						var o = a ? a.completion : {};
						return o.type = e, o.arg = t, a ? (this.method = "next", this
							.next = a.finallyLoc, v) : this.complete(o)
					},
					complete: function(e, t) {
						if ("throw" === e.type) throw e.arg;
						return "break" === e.type || "continue" === e.type ? this.next =
							e.arg : "return" === e.type ? (this.rval = this.arg = e.arg,
								this.method = "return", this.next = "end") :
							"normal" === e.type && t && (this.next = t), v
					},
					finish: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var n = this.tryEntries[t];
							if (n.finallyLoc === e) return this.complete(n.completion, n
								.afterLoc), A(n), v
						}
					},
					catch: function(e) {
						for (var t = this.tryEntries.length - 1; t >= 0; --t) {
							var n = this.tryEntries[t];
							if (n.tryLoc === e) {
								var r = n.completion;
								if ("throw" === r.type) {
									var i = r.arg;
									A(n)
								}
								return i
							}
						}
						throw new Error("illegal catch attempt")
					},
					delegateYield: function(e, n, r) {
						return this.delegate = {
							iterator: k(e),
							resultName: n,
							nextLoc: r
						}, "next" === this.method && (this.arg = t), v
					}
				}, e
		}(e.exports);
		try {
			regeneratorRuntime = r
		} catch (e) {
			"object" == typeof globalThis ? globalThis.regeneratorRuntime = r : Function("r",
				"regeneratorRuntime = r")(r)
		}
	}, function(e, t, n) {
		var r = n(53),
			i = n(54),
			a = n(55),
			o = n(57);
		e.exports = function(e, t) {
			return r(e) || i(e, t) || a(e, t) || o()
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e) {
			if (Array.isArray(e)) return e
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e, t) {
			var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] ||
				e["@@iterator"];
			if (null != n) {
				var r, i, a = [],
					o = !0,
					s = !1;
				try {
					for (n = n.call(e); !(o = (r = n.next()).done) && (a.push(r.value), !
							t || a.length !== t); o = !0);
				} catch (e) {
					s = !0, i = e
				} finally {
					try {
						o || null == n.return || n.return()
					} finally {
						if (s) throw i
					}
				}
				return a
			}
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		var r = n(56);
		e.exports = function(e, t) {
			if (e) {
				if ("string" == typeof e) return r(e, t);
				var n = Object.prototype.toString.call(e).slice(8, -1);
				return "Object" === n && e.constructor && (n = e.constructor.name),
					"Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n ||
					/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e, t) : void 0
			}
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function(e, t) {
			(null == t || t > e.length) && (t = e.length);
			for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
			return r
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		e.exports = function() {
			throw new TypeError(
				"Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
				)
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		var r = n(59);

		function i(t, n, a) {
			return "undefined" != typeof Reflect && Reflect.get ? (e.exports = i = Reflect.get,
				e.exports.default = e.exports, e.exports.__esModule = !0) : (e.exports = i =
				function(e, t, n) {
					var i = r(e, t);
					if (i) {
						var a = Object.getOwnPropertyDescriptor(i, t);
						return a.get ? a.get.call(n) : a.value
					}
				}, e.exports.default = e.exports, e.exports.__esModule = !0), i(t, n, a ||
				t)
		}
		e.exports = i, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		var r = n(7);
		e.exports = function(e, t) {
			for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = r(e)););
			return e
		}, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t) {
		function n(t, r) {
			return e.exports = n = Object.setPrototypeOf || function(e, t) {
				return e.__proto__ = t, e
			}, e.exports.default = e.exports, e.exports.__esModule = !0, n(t, r)
		}
		e.exports = n, e.exports.default = e.exports, e.exports.__esModule = !0
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.MapControls = t.OrbitControls = void 0;
		var i = r(n(1)),
			a = r(n(8)),
			o = r(n(14)),
			s = r(n(15)),
			l = r(n(7)),
			u = n(13);

		function c(e) {
			var t = function() {
				if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
				if (Reflect.construct.sham) return !1;
				if ("function" == typeof Proxy) return !0;
				try {
					return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (
						function() {}))), !0
				} catch (e) {
					return !1
				}
			}();
			return function() {
				var n, r = (0, l.default)(e);
				if (t) {
					var i = (0, l.default)(this).constructor;
					n = Reflect.construct(r, arguments, i)
				} else n = r.apply(this, arguments);
				return (0, s.default)(this, n)
			}
		}
		var h = {
				type: "change"
			},
			d = {
				type: "start"
			},
			f = {
				type: "end"
			},
			p = function(e) {
				(0, o.default)(n, e);
				var t = c(n);

				function n(e, r) {
					var o, s, l, c, p, v, m;
					(0, i.default)(this, n), o = t.call(this), void 0 === r && console.warn(
							'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
							), r === document && console.error(
							'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
							), o.object = e, o.domElement = r, o.enabled = !0, o.target = new u
						.Vector3, o.minDistance = 0, o.maxDistance = 1 / 0, o.minZoom = 0, o
						.maxZoom = 1 / 0, o.minPolarAngle = 0, o.maxPolarAngle = Math.PI, o
						.minAzimuthAngle = -1 / 0, o.maxAzimuthAngle = 1 / 0, o
						.enableDamping = !1, o.dampingFactor = .05, o.enableZoom = !0, o
						.zoomSpeed = 1, o.enableRotate = !0, o.rotateSpeed = 1, o.enablePan = !
						0, o.panSpeed = 1, o.screenSpacePanning = !0, o.keyPanSpeed = 7, o
						.autoRotate = !1, o.autoRotateSpeed = 2, o.keys = {
							LEFT: "ArrowLeft",
							UP: "ArrowUp",
							RIGHT: "ArrowRight",
							BOTTOM: "ArrowDown"
						}, o.mouseButtons = {
							LEFT: u.MOUSE.ROTATE,
							MIDDLE: u.MOUSE.DOLLY,
							RIGHT: u.MOUSE.PAN
						}, o.touches = {
							ONE: u.TOUCH.ROTATE,
							TWO: u.TOUCH.DOLLY_PAN
						}, o.target0 = o.target.clone(), o.position0 = o.object.position
					.clone(), o.zoom0 = o.object.zoom, o._domElementKeyEvents = null, o
						.getPolarAngle = function() {
							return b.phi
						}, o.getAzimuthalAngle = function() {
							return b.theta
						}, o.listenToKeyEvents = function(e) {
							e.addEventListener("keydown", ne), this._domElementKeyEvents = e
						}, o.saveState = function() {
							g.target0.copy(g.target), g.position0.copy(g.object.position), g
								.zoom0 = g.object.zoom
						}, o.reset = function() {
							g.target.copy(g.target0), g.object.position.copy(g.position0), g
								.object.zoom = g.zoom0, g.object.updateProjectionMatrix(), g
								.dispatchEvent(h), g.update(), x = y.NONE
						}, o.update = (s = new u.Vector3, l = (new u.Quaternion)
							.setFromUnitVectors(e.up, new u.Vector3(0, 1, 0)), c = l.clone()
							.invert(), p = new u.Vector3, v = new u.Quaternion, m = 2 * Math.PI,
							function() {
								var e = g.object.position;
								s.copy(e).sub(g.target), s.applyQuaternion(l), b.setFromVector3(
									s), g.autoRotate && x === y.NONE && O(2 * Math.PI / 60 /
									60 * g.autoRotateSpeed), g.enableDamping ? (b.theta += w
									.theta * g.dampingFactor, b.phi += w.phi * g
									.dampingFactor) : (b.theta += w.theta, b.phi += w.phi);
								var t = g.minAzimuthAngle,
									n = g.maxAzimuthAngle;
								return isFinite(t) && isFinite(n) && (t < -Math.PI ? t += m :
										t > Math.PI && (t -= m), n < -Math.PI ? n += m : n >
										Math.PI && (n -= m), b.theta = t <= n ? Math.max(t, Math
											.min(n, b.theta)) : b.theta > (t + n) / 2 ? Math
										.max(t, b.theta) : Math.min(n, b.theta)), b.phi = Math
									.max(g.minPolarAngle, Math.min(g.maxPolarAngle, b.phi)), b
									.makeSafe(), b.radius *= M, b.radius = Math.max(g
										.minDistance, Math.min(g.maxDistance, b.radius)), !0 ===
									g.enableDamping ? g.target.addScaledVector(S, g
										.dampingFactor) : g.target.add(S), s.setFromSpherical(
									b), s.applyQuaternion(c), e.copy(g.target).add(s), g.object
									.lookAt(g.target), !0 === g.enableDamping ? (w.theta *= 1 -
										g.dampingFactor, w.phi *= 1 - g.dampingFactor, S
										.multiplyScalar(1 - g.dampingFactor)) : (w.set(0, 0, 0),
										S.set(0, 0, 0)), M = 1, !!(T || p.distanceToSquared(g
										.object.position) > _ || 8 * (1 - v.dot(g.object
										.quaternion)) > _) && (g.dispatchEvent(h), p.copy(g
											.object.position), v.copy(g.object.quaternion),
										T = !1, !0)
							}), o.dispose = function() {
							g.domElement.removeEventListener("contextmenu", oe), g.domElement
								.removeEventListener("pointerdown", Q), g.domElement
								.removeEventListener("wheel", te), g.domElement
								.removeEventListener("touchstart", re), g.domElement
								.removeEventListener("touchend", ae), g.domElement
								.removeEventListener("touchmove", ie), g.domElement
								.ownerDocument.removeEventListener("pointermove", K), g
								.domElement.ownerDocument.removeEventListener("pointerup", ee),
								null !== g._domElementKeyEvents && g._domElementKeyEvents
								.removeEventListener("keydown", ne)
						};
					var g = (0, a.default)(o),
						y = {
							NONE: -1,
							ROTATE: 0,
							DOLLY: 1,
							PAN: 2,
							TOUCH_ROTATE: 3,
							TOUCH_PAN: 4,
							TOUCH_DOLLY_PAN: 5,
							TOUCH_DOLLY_ROTATE: 6
						},
						x = y.NONE,
						_ = 1e-6,
						b = new u.Spherical,
						w = new u.Spherical,
						M = 1,
						S = new u.Vector3,
						T = !1,
						E = new u.Vector2,
						A = new u.Vector2,
						L = new u.Vector2,
						k = new u.Vector2,
						R = new u.Vector2,
						C = new u.Vector2,
						P = new u.Vector2,
						I = new u.Vector2,
						D = new u.Vector2;

					function N() {
						return Math.pow(.95, g.zoomSpeed)
					}

					function O(e) {
						w.theta -= e
					}

					function B(e) {
						w.phi -= e
					}
					var z, F = (z = new u.Vector3, function(e, t) {
							z.setFromMatrixColumn(t, 0), z.multiplyScalar(-e), S.add(z)
						}),
						H = function() {
							var e = new u.Vector3;
							return function(t, n) {
								!0 === g.screenSpacePanning ? e.setFromMatrixColumn(n, 1) :
									(e.setFromMatrixColumn(n, 0), e.crossVectors(g.object
										.up, e)), e.multiplyScalar(t), S.add(e)
							}
						}(),
						U = function() {
							var e = new u.Vector3;
							return function(t, n) {
								var r = g.domElement;
								if (g.object.isPerspectiveCamera) {
									var i = g.object.position;
									e.copy(i).sub(g.target);
									var a = e.length();
									a *= Math.tan(g.object.fov / 2 * Math.PI / 180), F(2 *
										t * a / r.clientHeight, g.object.matrix), H(2 *
										n * a / r.clientHeight, g.object.matrix)
								} else g.object.isOrthographicCamera ? (F(t * (g.object
										.right - g.object.left) / g.object.zoom / r
									.clientWidth, g.object.matrix), H(n * (g.object
										.top - g.object.bottom) / g.object.zoom / r
									.clientHeight, g.object.matrix)) : (console.warn(
									"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
									), g.enablePan = !1)
							}
						}();

					function G(e) {
						g.object.isPerspectiveCamera ? M /= e : g.object.isOrthographicCamera ?
							(g.object.zoom = Math.max(g.minZoom, Math.min(g.maxZoom, g.object
								.zoom * e)), g.object.updateProjectionMatrix(), T = !0) : (
								console.warn(
									"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
									), g.enableZoom = !1)
					}

					function V(e) {
						g.object.isPerspectiveCamera ? M *= e : g.object.isOrthographicCamera ?
							(g.object.zoom = Math.max(g.minZoom, Math.min(g.maxZoom, g.object
								.zoom / e)), g.object.updateProjectionMatrix(), T = !0) : (
								console.warn(
									"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
									), g.enableZoom = !1)
					}

					function W(e) {
						E.set(e.clientX, e.clientY)
					}

					function j(e) {
						k.set(e.clientX, e.clientY)
					}

					function q(e) {
						if (1 == e.touches.length) E.set(e.touches[0].pageX, e.touches[0]
						.pageY);
						else {
							var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
								n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
							E.set(t, n)
						}
					}

					function X(e) {
						if (1 == e.touches.length) k.set(e.touches[0].pageX, e.touches[0]
						.pageY);
						else {
							var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
								n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
							k.set(t, n)
						}
					}

					function Y(e) {
						var t = e.touches[0].pageX - e.touches[1].pageX,
							n = e.touches[0].pageY - e.touches[1].pageY,
							r = Math.sqrt(t * t + n * n);
						P.set(0, r)
					}

					function $(e) {
						if (1 == e.touches.length) A.set(e.touches[0].pageX, e.touches[0]
						.pageY);
						else {
							var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
								n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
							A.set(t, n)
						}
						L.subVectors(A, E).multiplyScalar(g.rotateSpeed);
						var r = g.domElement;
						O(2 * Math.PI * L.x / r.clientHeight), B(2 * Math.PI * L.y / r
							.clientHeight), E.copy(A)
					}

					function Z(e) {
						if (1 == e.touches.length) R.set(e.touches[0].pageX, e.touches[0]
						.pageY);
						else {
							var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
								n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
							R.set(t, n)
						}
						C.subVectors(R, k).multiplyScalar(g.panSpeed), U(C.x, C.y), k.copy(R)
					}

					function J(e) {
						var t = e.touches[0].pageX - e.touches[1].pageX,
							n = e.touches[0].pageY - e.touches[1].pageY,
							r = Math.sqrt(t * t + n * n);
						I.set(0, r), D.set(0, Math.pow(I.y / P.y, g.zoomSpeed)), G(D.y), P.copy(
							I)
					}

					function Q(e) {
						if (!1 !== g.enabled) switch (e.pointerType) {
							case "mouse":
							case "pen":
								! function(e) {
									var t;
									switch (e.preventDefault(), g.domElement.focus ? g
										.domElement.focus() : window.focus(), e.button) {
										case 0:
											t = g.mouseButtons.LEFT;
											break;
										case 1:
											t = g.mouseButtons.MIDDLE;
											break;
										case 2:
											t = g.mouseButtons.RIGHT;
											break;
										default:
											t = -1
									}
									switch (t) {
										case u.MOUSE.DOLLY:
											if (!1 === g.enableZoom) return;
											! function(e) {
												P.set(e.clientX, e.clientY)
											}(e), x = y.DOLLY;
											break;
										case u.MOUSE.ROTATE:
											if (e.ctrlKey || e.metaKey || e.shiftKey) {
												if (!1 === g.enablePan) return;
												j(e), x = y.PAN
											} else {
												if (!1 === g.enableRotate) return;
												W(e), x = y.ROTATE
											}
											break;
										case u.MOUSE.PAN:
											if (e.ctrlKey || e.metaKey || e.shiftKey) {
												if (!1 === g.enableRotate) return;
												W(e), x = y.ROTATE
											} else {
												if (!1 === g.enablePan) return;
												j(e), x = y.PAN
											}
											break;
										default:
											x = y.NONE
									}
									x !== y.NONE && (g.domElement.ownerDocument
										.addEventListener("pointermove", K), g
										.domElement.ownerDocument.addEventListener(
											"pointerup", ee), g.dispatchEvent(d))
								}(e)
						}
					}

					function K(e) {
						if (!1 !== g.enabled) switch (e.pointerType) {
							case "mouse":
							case "pen":
								! function(e) {
									if (!1 === g.enabled) return;
									switch (e.preventDefault(), x) {
										case y.ROTATE:
											if (!1 === g.enableRotate) return;
											! function(e) {
												A.set(e.clientX, e.clientY), L.subVectors(A,
													E).multiplyScalar(g.rotateSpeed);
												var t = g.domElement;
												O(2 * Math.PI * L.x / t.clientHeight), B(2 *
														Math.PI * L.y / t.clientHeight), E
													.copy(A), g.update()
											}(e);
											break;
										case y.DOLLY:
											if (!1 === g.enableZoom) return;
											! function(e) {
												I.set(e.clientX, e.clientY), D.subVectors(I,
													P), D.y > 0 ? G(N()) : D.y < 0 && V(
													N()), P.copy(I), g.update()
											}(e);
											break;
										case y.PAN:
											if (!1 === g.enablePan) return;
											! function(e) {
												R.set(e.clientX, e.clientY), C.subVectors(R,
													k).multiplyScalar(g.panSpeed), U(C
													.x, C.y), k.copy(R), g.update()
											}(e)
									}
								}(e)
						}
					}

					function ee(e) {
						switch (e.pointerType) {
							case "mouse":
							case "pen":
								! function(e) {
									if (g.domElement.ownerDocument.removeEventListener(
											"pointermove", K), g.domElement.ownerDocument
										.removeEventListener("pointerup", ee), !1 === g.enabled)
										return;
									g.dispatchEvent(f), x = y.NONE
								}()
						}
					}

					function te(e) {
						!1 === g.enabled || !1 === g.enableZoom || x !== y.NONE && x !== y
							.ROTATE || (e.preventDefault(), g.dispatchEvent(d), function(e) {
								e.deltaY < 0 ? V(N()) : e.deltaY > 0 && G(N()), g.update()
							}(e), g.dispatchEvent(f))
					}

					function ne(e) {
						!1 !== g.enabled && !1 !== g.enablePan && function(e) {
							var t = !1;
							switch (e.code) {
								case g.keys.UP:
									U(0, g.keyPanSpeed), t = !0;
									break;
								case g.keys.BOTTOM:
									U(0, -g.keyPanSpeed), t = !0;
									break;
								case g.keys.LEFT:
									U(g.keyPanSpeed, 0), t = !0;
									break;
								case g.keys.RIGHT:
									U(-g.keyPanSpeed, 0), t = !0
							}
							t && (e.preventDefault(), g.update())
						}(e)
					}

					function re(e) {
						if (!1 !== g.enabled) {
							switch (e.preventDefault(), e.touches.length) {
								case 1:
									switch (g.touches.ONE) {
										case u.TOUCH.ROTATE:
											if (!1 === g.enableRotate) return;
											q(e), x = y.TOUCH_ROTATE;
											break;
										case u.TOUCH.PAN:
											if (!1 === g.enablePan) return;
											X(e), x = y.TOUCH_PAN;
											break;
										default:
											x = y.NONE
									}
									break;
								case 2:
									switch (g.touches.TWO) {
										case u.TOUCH.DOLLY_PAN:
											if (!1 === g.enableZoom && !1 === g.enablePan)
												return;
											! function(e) {
												g.enableZoom && Y(e), g.enablePan && X(e)
											}(e), x = y.TOUCH_DOLLY_PAN;
											break;
										case u.TOUCH.DOLLY_ROTATE:
											if (!1 === g.enableZoom && !1 === g.enableRotate)
												return;
											! function(e) {
												g.enableZoom && Y(e), g.enableRotate && q(e)
											}(e), x = y.TOUCH_DOLLY_ROTATE;
											break;
										default:
											x = y.NONE
									}
									break;
								default:
									x = y.NONE
							}
							x !== y.NONE && g.dispatchEvent(d)
						}
					}

					function ie(e) {
						if (!1 !== g.enabled) switch (e.preventDefault(), x) {
							case y.TOUCH_ROTATE:
								if (!1 === g.enableRotate) return;
								$(e), g.update();
								break;
							case y.TOUCH_PAN:
								if (!1 === g.enablePan) return;
								Z(e), g.update();
								break;
							case y.TOUCH_DOLLY_PAN:
								if (!1 === g.enableZoom && !1 === g.enablePan) return;
								! function(e) {
									g.enableZoom && J(e), g.enablePan && Z(e)
								}(e), g.update();
								break;
							case y.TOUCH_DOLLY_ROTATE:
								if (!1 === g.enableZoom && !1 === g.enableRotate) return;
								! function(e) {
									g.enableZoom && J(e), g.enableRotate && $(e)
								}(e), g.update();
								break;
							default:
								x = y.NONE
						}
					}

					function ae(e) {
						!1 !== g.enabled && (g.dispatchEvent(f), x = y.NONE)
					}

					function oe(e) {
						!1 !== g.enabled && e.preventDefault()
					}
					return g.domElement.addEventListener("contextmenu", oe), g.domElement
						.addEventListener("pointerdown", Q), g.domElement.addEventListener(
							"wheel", te, {
								passive: !1
							}), g.domElement.addEventListener("touchstart", re, {
							passive: !1
						}), g.domElement.addEventListener("touchend", ae), g.domElement
						.addEventListener("touchmove", ie, {
							passive: !1
						}), o.update(), o
				}
				return n
			}(u.EventDispatcher);
		t.OrbitControls = p;
		var v = function(e) {
			(0, o.default)(n, e);
			var t = c(n);

			function n(e, r) {
				var a;
				return (0, i.default)(this, n), (a = t.call(this, e, r))
					.screenSpacePanning = !1, a.mouseButtons.LEFT = u.MOUSE.PAN, a
					.mouseButtons.RIGHT = u.MOUSE.ROTATE, a.touches.ONE = u.TOUCH.PAN, a
					.touches.TWO = u.TOUCH.DOLLY_ROTATE, a
			}
			return n
		}(p);
		t.MapControls = v
	}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2));
		n(63);
		var o = function() {
			function e() {
				(0, i.default)(this, e)
			}
			return (0, a.default)(e, null, [{
				key: "moduleName",
				value: function() {
					return "register"
				}
			}]), e
		}();
		t.default = o
	}, function(e, t, n) {}, function(e, t, n) {
		"use strict";
		var r = n(0);
		Object.defineProperty(t, "__esModule", {
			value: !0
		}), t.default = void 0;
		var i = r(n(1)),
			a = r(n(2)),
			o = r(n(3));
		n(65);
		var s = function() {
			function e(t) {
				(0, i.default)(this, e), (0, o.default)(this, "$el", void 0), this.$el = $(
					t), this.init(), this.bindEvents()
			}
			return (0, a.default)(e, [{
				key: "init",
				value: function() {}
			}, {
				key: "bindEvents",
				value: function() {}
			}], [{
				key: "moduleName",
				value: function() {
					return "activity-nav"
				}
			}]), e
		}();
		t.default = s
	}, function(e, t, n) {}])
}));
